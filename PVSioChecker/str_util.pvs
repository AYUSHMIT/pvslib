str_util: THEORY
BEGIN

  str_length(str: string): nat = length(str)

  StringChar : TYPE = {str:string | length(str) = 1}

  %% Split str using separator
  str_split(str: string, separator: StringChar): list[string]

  NotAQuotedString : ExceptionTag[string] ="NotAQuotedString"

  %% Is string str of the form Q...., where Q is the quotechar, e.g., \", \', etc.
  left_quotedstring?(quotechar:StringChar)(str:string): bool =
    LET len = str_length(str) IN
      len >= 1 AND
      LET prefix  = substr(str,0,0) IN
        strcmp(prefix,quotechar) = 0

  %% Is string str of the form ...Q, where Q is the quotechar, e.g., \", \', etc.
  right_quotedstring?(quotechar:StringChar)(str:string): bool =
    LET len = str_length(str) IN
      len >= 1 AND
      LET postfix = substr(str,len-1,len-1) IN
        strcmp(postfix,quotechar) = 0

  %% Is string str of the form Q....Q, where Q is the quotechar, e.g., \", \', etc.
  quotedstring?(quotechar:StringChar)(str:string): bool =
    LET len = str_length(str) IN
      len >= 2 AND
      LET prefix  = substr(str,0,0),
          postfix = substr(str,len-1,len-1) IN
        strcmp(prefix,postfix) = 0 AND
        strcmp(prefix,quotechar) = 0

  unquote_string(quotechar:StringChar)(str:(quotedstring?(quotechar))): string =
    substr(str,1,length(str)-2)

  str_split_with_qchar_rec(tokens: list[string], separator,quotechar: StringChar, leftstr: string):
    RECURSIVE list[string] =
    LET inside_str : bool = str_length(leftstr) > 0 IN
    IF null?(tokens) THEN
      IF inside_str THEN (: leftstr :) ELSE tokens
      ENDIF
    ELSE
      LET token    = car(tokens),
          str_trim = trim(token),
	  lstr     = left_quotedstring?(quotechar)(str_trim),
	  rstr     = right_quotedstring?(quotechar)(str_trim) IN
        IF inside_str THEN % leftstr is not empty
	  LET newstr = format("~a~a~a",{| leftstr, separator, token |}) IN
	  IF rstr THEN
	      cons(newstr,str_split_with_qchar_rec(cdr(tokens),separator,quotechar,""))
	  ELSE
	      str_split_with_qchar_rec(cdr(tokens),separator,quotechar,newstr)
	  ENDIF
	ELSE 
 	  IF lstr AND (rstr IMPLIES str_length(str_trim) = 1) THEN
 	    str_split_with_qchar_rec(cdr(tokens),separator,quotechar,token)
          ELSE % leftstr is empty
	    cons(token,str_split_with_qchar_rec(cdr(tokens),separator,quotechar,""))
	  ENDIF
	ENDIF
    ENDIF
    MEASURE tokens BY <<

  %% Split str using separator, but avoid splitting within quotechar 
  str_split_with_quotechar(str: string, separator,quotechar: StringChar): list[string] =
    LET split = str_split(str,separator) IN
    str_split_with_qchar_rec(split,separator,quotechar,"")

  %%% Manipulation of rational numbers

  numerator(r:rat) : int

  denominator(r:rat) : posnat

  % Returns the precision of the decimal representation of the given rational,          % -1 if infinite decimal
  decimal_precision(r:rat) : int

  % Returns a rational number close to the real number
  rationalize(r:real) : rat 

  %% Print rat as decimal whenever possible
  print_rat(r:rat) : string =
    LET prec = decimal_precision(r) IN
    IF prec > 0 THEN
      rat2decstr(r,prec)
    ELSE
      format("~a",r)
    ENDIF

  n : VAR nat

  charcode_ax : AXIOM
    length(charcode(n)) = 1

  charcode_j : JUDGEMENT
    charcode(n) HAS_TYPE StringChar

  doublequote_j : JUDGEMENT
    doublequote HAS_TYPE StringChar

  singlequote_j : JUDGEMENT
    singlequote HAS_TYPE StringChar

  backquote_j : JUDGEMENT
    backquote HAS_TYPE StringChar

END str_util
