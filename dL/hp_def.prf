(hp_def
 (dlvar_inj 0
  (dlvar_inj-1 nil 3899226353
   ("" (induct "v1")
    (("" (skeep)
      (("" (induct "v2") (("" (skeep) (("" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((dlvar adt-constructor-decl "[nat -> (dlvar?)]" hp_def nil)
    (dlvar? adt-recognizer-decl "[dLVar -> boolean]" hp_def nil)
    (dLVar_induction formula-decl nil hp_def nil)
    (dlvar_index adt-accessor-decl "[dLVar -> nat]" hp_def nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (dLVar type-decl nil hp_def nil))
   shostak))
 (dlvar_eq 0
  (dlvar_eq-1 nil 3903515235
   ("" (skeep) (("" (decompose-equality 1) nil nil)) nil)
   ((dlvar? adt-recognizer-decl "[dLVar -> boolean]" hp_def nil)
    (boolean nonempty-type-decl nil booleans nil)
    (dLVar type-decl nil hp_def nil)
    (dLVar_dlvar_extensionality formula-decl nil hp_def nil)
    (dlvar_index adt-accessor-decl "[dLVar -> nat]" hp_def nil)
    (dlvar adt-constructor-decl "[nat -> (dlvar?)]" hp_def nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (mapexpr_inj_TCC1 0
  (mapexpr_inj_TCC1-1 nil 3786461579 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (subrange type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil))
   shostak
   (mapexpr_inj subtype "hp_def.i" "below[length[MapExpr](l)]")))
 (mapexpr_inj_TCC2 0
  (mapexpr_inj_TCC2-1 nil 3790609695 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (subrange type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil))
   shostak
   (mapexpr_inj subtype "hp_def.j" "below[length[MapExpr](l)]")))
 (mapexpr_inj_cons 0
  (mapexpr_inj_cons-1 nil 3790613034
   ("" (skeep)
    (("" (expand "mapexpr_inj")
      (("" (skeep :preds? t)
        (("" (inst -4 "i+1" "j+1")
          (("1" (grind) nil nil) ("2" (grind) nil nil)
           ("3" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((mapexpr_inj const-decl "bool" hp_def nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def nil)
    (RealExpr type-eq-decl nil hp_def nil)
    (Environment type-eq-decl nil hp_def nil)
    (dLVar type-decl nil hp_def nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (subrange type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) (nth def-decl "T" list_props nil))
   shostak))
 (mapexpr_inj_eq 0
  (mapexpr_inj_eq-1 nil 3786461627
   ("" (skeep)
    (("" (split)
      (("1" (flatten)
        (("1" (expand "mapexpr_inj")
          (("1" (skeep)
            (("1" (case "i < j")
              (("1" (inst -2 "i" "j")
                (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)
               ("2" (inst -1 "j" "i")
                (("1" (assert) nil nil) ("2" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (flatten)
        (("2" (expand "mapexpr_inj")
          (("2" (skeep)
            (("2" (insteep -1) (("2" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((mapexpr_inj const-decl "bool" hp_def nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def nil)
    (RealExpr type-eq-decl nil hp_def nil)
    (Environment type-eq-decl nil hp_def nil)
    (dLVar type-decl nil hp_def nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (subrange type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   shostak))
 (mapexpr_inj_eq_index 0
  (mapexpr_inj_eq_index-1 nil 3903529769
   ("" (skeep)
    (("" (lemma "mapexpr_inj_eq")
      (("" (inst?)
        (("" (replaces -1)
          (("" (split)
            (("1" (flatten)
              (("1" (skeep)
                (("1" (insteep)
                  (("1" (assert)
                    (("1" (flatten)
                      (("1" (decompose-equality 1) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (flatten)
              (("2" (skeep)
                (("2" (insteep) (("2" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((mapexpr_inj_eq formula-decl nil hp_def nil)
    (TRUE const-decl "bool" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (dLVar_dlvar_extensionality formula-decl nil hp_def nil)
    (dlvar? adt-recognizer-decl "[dLVar -> boolean]" hp_def nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil) (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def nil)
    (RealExpr type-eq-decl nil hp_def nil)
    (Environment type-eq-decl nil hp_def nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (dLVar type-decl nil hp_def nil))
   shostak))
 (null_MapExprInj 0
  (null_MapExprInj-1 nil 3790613251
   ("" (expand "mapexpr_inj") (("" (grind) nil nil)) nil)
   ((nth def-decl "T" list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (subrange type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (length def-decl "nat" list_props nil)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def nil)
    (RealExpr type-eq-decl nil hp_def nil)
    (Environment type-eq-decl nil hp_def nil)
    (dLVar type-decl nil hp_def nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (mapexpr_inj const-decl "bool" hp_def nil))
   shostak
   (null_MapExprInj subtype "list_adt[[hp_def.dLVar, RealExpr]].null"
    "MapExprInj")))
 (cdr_is_MapExprInj 0
  (cdr_is_MapExprInj-1 nil 3782823687
   ("" (expand "mapexpr_inj")
    (("" (skeep*)
      (("" (typepred "l")
        (("" (expand "mapexpr_inj")
          (("" (inst -1 "i+1" "j+1")
            (("1" (assert)
              (("1" (expand "nth" 1) (("1" (propax) nil nil)) nil))
              nil)
             ("2" (typepred "j")
              (("2" (expand "length" 1) (("2" (assert) nil nil)) nil))
              nil)
             ("3" (typepred "i")
              (("3" (expand "length" 1) (("3" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((null_MapExprInj name-judgement "MapExprInj" hp_def nil)
    (TRUE const-decl "bool" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nth def-decl "T" list_props nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (subrange type-eq-decl nil integers nil)
    (j skolem-const-decl "subrange(1 + i, length(cdr[MapExpr](l)) - 1)"
     hp_def nil)
    (i skolem-const-decl "below(length(cdr[MapExpr](l)))" hp_def nil)
    (below type-eq-decl nil naturalnumbers nil)
    (l skolem-const-decl "{l: MapExprInj | cons?(l)}" hp_def nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (length def-decl "nat" list_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (dLVar type-decl nil hp_def nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def nil)
    (RealExpr type-eq-decl nil hp_def nil)
    (MapExpr type-eq-decl nil hp_def nil)
    (list type-decl nil list_adt nil)
    (MapExprInj type-eq-decl nil hp_def nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def nil))
   shostak
   (cdr_is_MapExprInj subtype "list_adt[MapExpr].cdr(hp_def.l)"
    "MapExprInj")))
 (sub_mapexpr_inj_is_mapexpr_inj 0
  (sub_mapexpr_inj_is_mapexpr_inj-1 nil 3796803795
   ("" (skeep :preds? t)
    (("" (expand "mapexpr_inj")
      (("" (skeep :preds? t)
        (("" (lemma "sublist_respects_order[MapExpr]")
          (("" (inst -1 "l2" "l1" "i" "j")
            (("" (skeep :preds? t)
              (("" (inst -9 "i2" "j2") (("" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((mapexpr_inj const-decl "bool" hp_def nil)
    (MapExpr type-eq-decl nil hp_def nil)
    (RealExpr type-eq-decl nil hp_def nil)
    (Environment type-eq-decl nil hp_def nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (dLVar type-decl nil hp_def nil)
    (sublist_respects_order formula-decl nil more_list_props
     structures)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (subrange type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil) (list type-decl nil list_adt nil)
    (sublist? def-decl "bool" more_list_props structures)
    (MapExprInj type-eq-decl nil hp_def nil)
    (sublist_alt_def rec-application-judgement
     "{b: bool | b = EXISTS (l_: list[T] | suffix?(l_, l2)): prefix?(l1, l_)}"
     more_list_props structures)
    (null_MapExprInj name-judgement "MapExprInj" hp_def nil))
   shostak))
 (in_map_cons 0
  (in_map_cons-1 nil 3798041729
   ("" (skeep :preds? t)
    (("" (split)
      (("1" (flatten)
        (("1" (expand "in_map")
          (("1" (skolem -1 "i1")
            (("1" (skolem -4 "i2")
              (("1" (rewrite "mapexpr_inj_eq")
                (("1" (rewrite "mapexpr_inj_eq")
                  (("1" (case "i1 = 0")
                    (("1" (inst -6 "i1" "i2+1")
                      (("1" (expand "nth" -6 2)
                        (("1" (assert)
                          (("1" (decompose-equality) nil nil)) nil))
                        nil)
                       ("2" (expand "length" 1)
                        (("2" (assert) nil nil)) nil))
                      nil)
                     ("2" (hide (-3 -4))
                      (("2" (inst -3 "i1" "0")
                        (("2" (assert)
                          (("2" (flatten)
                            (("2" (expand "nth" 2 2)
                              (("2"
                                (lemma "dLVar_dlvar_extensionality")
                                (("2"
                                  (inst?)
                                  (("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (flatten)
        (("2" (expand "in_map")
          (("2" (skeep :preds? t)
            (("2" (inst 2 "i_1+1")
              (("1" (expand "nth" 2) (("1" (propax) nil nil)) nil)
               ("2" (expand "length" 1) (("2" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((in_map const-decl "bool" hp_def nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (dLVar_dlvar_extensionality formula-decl nil hp_def nil)
    (dlvar? adt-recognizer-decl "[dLVar -> boolean]" hp_def nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (MapExprInj type-eq-decl nil hp_def nil)
    (mapexpr_inj const-decl "bool" hp_def nil)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def nil)
    (RealExpr type-eq-decl nil hp_def nil)
    (Environment type-eq-decl nil hp_def nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (dLVar type-decl nil hp_def nil)
    (mapexpr_inj_eq formula-decl nil hp_def nil)
    (null_MapExprInj name-judgement "MapExprInj" hp_def nil))
   shostak))
 (in_map_null_false 0
  (in_map_null_false-1 nil 3798036858 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (dLVar type-decl nil hp_def nil)
    (Environment type-eq-decl nil hp_def nil)
    (RealExpr type-eq-decl nil hp_def nil)
    (MapExpr type-eq-decl nil hp_def nil)
    (list type-decl nil list_adt nil)
    (length def-decl "nat" list_props nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (null_MapExprInj name-judgement "MapExprInj" hp_def nil)
    (in_map const-decl "bool" hp_def nil))
   shostak))
 (not_in_map_null 0
  (not_in_map_null-1 nil 3798036642 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (dLVar type-decl nil hp_def nil)
    (Environment type-eq-decl nil hp_def nil)
    (RealExpr type-eq-decl nil hp_def nil)
    (MapExpr type-eq-decl nil hp_def nil)
    (list type-decl nil list_adt nil)
    (length def-decl "nat" list_props nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (null_MapExprInj name-judgement "MapExprInj" hp_def nil)
    (/= const-decl "boolean" notequal nil)
    (not_in_map const-decl "bool" hp_def nil))
   shostak))
 (index_of_j 0
  (index_of_j-1 nil 3798040255
   ("" (skeep :preds? t)
    (("" (expand "singleton?")
      (("" (expand "in_map")
        (("" (skeep -2)
          (("" (inst 1 "i_1")
            (("1" (skeep :preds? t)
              (("1" (rewrite "mapexpr_inj_eq")
                (("1" (inst -3 "i_1" "y")
                  (("1" (assert)
                    (("1" (expand "index_of")
                      (("1" (flatten)
                        (("1" (lemma "dlvar_inj")
                          (("1" (inst?) (("1" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (expand "index_of") (("2" (propax) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((singleton? const-decl "bool" sets nil)
    (dlvar_inj formula-decl nil hp_def nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (mapexpr_inj_eq formula-decl nil hp_def nil)
    (MapExprInj type-eq-decl nil hp_def nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (dLVar type-decl nil hp_def nil)
    (Environment type-eq-decl nil hp_def nil)
    (RealExpr type-eq-decl nil hp_def nil)
    (MapExpr type-eq-decl nil hp_def nil)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (index_of const-decl "bool" hp_def nil)
    (me skolem-const-decl "MapExprInj" hp_def nil)
    (i skolem-const-decl "(in_map(me))" hp_def nil)
    (i_1 skolem-const-decl "below(length(me))" hp_def nil)
    (in_map const-decl "bool" hp_def nil)
    (null_MapExprInj name-judgement "MapExprInj" hp_def nil))
   nil
   (index_of_j subtype "hp_def.index_of(hp_def.me, hp_def.i)"
    "(sets[naturalnumbers.below(list_props[MapExpr].length(hp_def.me))].singleton?)")))
 (expr_car_TCC1 0
  (expr_car_TCC1-1 nil 3798044273
   ("" (skeep)
    (("" (expand "in_map")
      (("" (inst 1 "0")
        (("1" (expand "nth") (("1" (propax) nil nil)) nil)
         ("2" (expand "length") (("2" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((in_map const-decl "bool" hp_def nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (< const-decl "bool" reals nil) (dLVar type-decl nil hp_def nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def nil)
    (RealExpr type-eq-decl nil hp_def nil)
    (MapExpr type-eq-decl nil hp_def nil)
    (list type-decl nil list_adt nil)
    (length def-decl "nat" list_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (mapexpr skolem-const-decl "MapExpr" hp_def nil)
    (mapexpr_inj const-decl "bool" hp_def nil)
    (MapExprInj type-eq-decl nil hp_def nil)
    (me skolem-const-decl "MapExprInj" hp_def nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (null_MapExprInj name-judgement "MapExprInj" hp_def nil))
   nil
   (expr_car subtype "hp_def.dlvar_index(hp_def.mapexpr`1)"
    "(hp_def.in_map(list_adt[MapExpr].cons(hp_def.mapexpr, hp_def.me)))")))
 (expr_car 0
  (expr_car-1 nil 3798046110
   ("" (skeep)
    (("" (expand "expr")
      ((""
        (case-replace
         "the(index_of(cons(mapexpr, me), dlvar_index(mapexpr`1))) = 0")
        (("1" (expand "nth") (("1" (propax) nil nil)) nil)
         ("2" (hide 2)
          (("2" (rewrite "mapexpr_inj_eq")
            (("2"
              (typepred
               "the(index_of(cons(mapexpr, me), dlvar_index(mapexpr`1)))")
              (("2"
                (name-replace "THE"
                 "the(index_of(cons(mapexpr, me), dlvar_index(mapexpr`1)))")
                (("2" (expand "index_of")
                  (("2" (inst -3 "0" "THE")
                    (("1" (assert)
                      (("1" (expand "nth" -3 1)
                        (("1" (lemma "dLVar_dlvar_extensionality")
                          (("1" (inst?) (("1" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil)
                     ("2" (expand "length" 1) (("2" (assert) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((expr const-decl "RealExpr" hp_def nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (dLVar_dlvar_extensionality formula-decl nil hp_def nil)
    (dlvar? adt-recognizer-decl "[dLVar -> boolean]" hp_def nil)
    (below type-eq-decl nil nat_types nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (mapexpr_inj_eq formula-decl nil hp_def nil)
    (nth def-decl "T" list_props nil)
    (dlvar_index adt-accessor-decl "[dLVar -> nat]" hp_def nil)
    (index_of const-decl "bool" hp_def nil)
    (in_map const-decl "bool" hp_def nil)
    (the const-decl "(p)" sets nil)
    (singleton? const-decl "bool" sets nil)
    (set type-eq-decl nil sets nil)
    (below type-eq-decl nil naturalnumbers nil)
    (MapExprInj type-eq-decl nil hp_def nil)
    (mapexpr_inj const-decl "bool" hp_def nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (length def-decl "nat" list_props nil)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def nil)
    (RealExpr type-eq-decl nil hp_def nil)
    (Environment type-eq-decl nil hp_def nil)
    (dLVar type-decl nil hp_def nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (index_of_j application-judgement
     "(singleton?[below(length[MapExpr](me))])" hp_def nil)
    (null_MapExprInj name-judgement "MapExprInj" hp_def nil))
   shostak))
 (expr_not_car_TCC1 0
  (expr_not_car_TCC1-1 nil 3798037314
   ("" (skeep* :preds? t)
    (("" (expand "in_map")
      (("" (skeep :preds? t)
        (("" (inst 2 "i_1+1")
          (("1" (expand "nth" 2) (("1" (propax) nil nil)) nil)
           ("2" (expand "length" 1) (("2" (assert) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((in_map const-decl "bool" hp_def nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (mapexpr skolem-const-decl "MapExpr" hp_def nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (i_1 skolem-const-decl "below(length(me))" hp_def nil)
    (below type-eq-decl nil naturalnumbers nil)
    (me skolem-const-decl "MapExprInj" hp_def nil)
    (MapExprInj type-eq-decl nil hp_def nil)
    (mapexpr_inj const-decl "bool" hp_def nil)
    (length def-decl "nat" list_props nil)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def nil)
    (RealExpr type-eq-decl nil hp_def nil)
    (Environment type-eq-decl nil hp_def nil)
    (dLVar type-decl nil hp_def nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (nth def-decl "T" list_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (null_MapExprInj name-judgement "MapExprInj" hp_def nil))
   nil
   (expr_not_car subtype "hp_def.i"
    "(hp_def.in_map(list_adt[MapExpr].cons(hp_def.mapexpr, hp_def.me)))")))
 (expr_not_car 0
  (expr_not_car-1 nil 3798037540
   ("" (skeep :preds? t)
    (("" (expand "expr")
      ((""
        (case-replace
         "the(index_of(cons(mapexpr, me), i)) = 1+the(index_of(me, i))")
        (("1" (expand "nth" 2 1) (("1" (assert) nil nil)) nil)
         ("2" (hide 3)
          (("2" (typepred "the(index_of(cons(mapexpr, me), i))")
            (("2" (typepred "the(index_of(me, i))")
              (("2" (expand "index_of" -2 1)
                (("2" (expand "index_of" -4 1)
                  (("2"
                    (case-replace
                     "the(index_of(cons(mapexpr, me), i)) = 0")
                    (("1" (expand "nth" -5) (("1" (propax) nil nil))
                      nil)
                     ("2" (expand "nth" -4)
                      (("2" (assert)
                        (("2"
                          (name-replace "THE1" "the(index_of(me, i))")
                          (("2"
                            (name-replace "THE2"
                             "the(index_of(cons(mapexpr, me), i))")
                            (("2" (rewrite "mapexpr_inj_eq" -5)
                              (("2"
                                (inst -5 "THE1" "THE2-1")
                                (("1"
                                  (assert)
                                  (("1"
                                    (lemma
                                     "dLVar_dlvar_extensionality")
                                    (("1"
                                      (inst? -1)
                                      (("1"
                                        (inst? - :where -5)
                                        (("1" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((expr const-decl "RealExpr" hp_def nil)
    (mapexpr_inj_eq formula-decl nil hp_def nil)
    (dlvar? adt-recognizer-decl "[dLVar -> boolean]" hp_def nil)
    (below type-eq-decl nil nat_types nil)
    (dLVar_dlvar_extensionality formula-decl nil hp_def nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nth def-decl "T" list_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (index_of const-decl "bool" hp_def nil)
    (in_map const-decl "bool" hp_def nil)
    (the const-decl "(p)" sets nil)
    (singleton? const-decl "bool" sets nil)
    (set type-eq-decl nil sets nil)
    (below type-eq-decl nil naturalnumbers nil)
    (MapExprInj type-eq-decl nil hp_def nil)
    (mapexpr_inj const-decl "bool" hp_def nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (length def-decl "nat" list_props nil)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def nil)
    (RealExpr type-eq-decl nil hp_def nil)
    (Environment type-eq-decl nil hp_def nil)
    (dLVar type-decl nil hp_def nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (index_of_j application-judgement
     "(singleton?[below(length[MapExpr](me))])" hp_def nil)
    (null_MapExprInj name-judgement "MapExprInj" hp_def nil))
   shostak))
 (same_var_eq 0
  (same_var_eq-1 nil 3899400431
   ("" (grind)
    (("" (lemma "dLVar_dlvar_extensionality")
      (("" (inst?) (("" (assert) nil nil)) nil)) nil))
    nil)
   ((dLVar_dlvar_extensionality formula-decl nil hp_def nil)
    (dlvar? adt-recognizer-decl "[dLVar -> boolean]" hp_def nil)
    (boolean nonempty-type-decl nil booleans nil)
    (dLVar type-decl nil hp_def nil)
    (same_var const-decl "bool" hp_def nil))
   shostak))
 (max_var_rec_TCC1 0
  (max_var_rec_TCC1-1 nil 3785145622 ("" (subtype-tcc) nil nil)
   ((null_MapExprInj name-judgement "MapExprInj" hp_def nil)) nil
   (max_var_rec subtype "hp_def.ode" "(list_adt[MapExpr].cons?)")))
 (max_var_rec_TCC2 0
  (max_var_rec_TCC3-1 nil 3785145622 ("" (termination-tcc) nil nil)
   ((null_MapExprInj name-judgement "MapExprInj" hp_def nil)
    (length def-decl "nat" list_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (max_var_rec termination
    "hp_def.max_var_rec(list_adt[MapExpr].cdr(hp_def.ode), real_defs.max(hp_def.mx, hp_def.dlvar_index(list_adt[MapExpr].car(hp_def.ode)`1)))"
    "nil")))
 (max_var_rec_pull 0
  (max_var_rec_pull-1 nil 3798384892
   ("" (induct "ode")
    (("1" (skeep) (("1" (grind) nil nil)) nil)
     ("2" (skeep)
      (("2" (skeep)
        (("2" (case "cons2_var=null")
          (("1" (hide -2) (("1" (grind) nil nil)) nil)
           ("2" (expand "max_var_rec" 2 1)
            (("2" (inst-cp -1 "max(0, dlvar_index(cons1_var`1))")
              (("2" (replace -2 2 rl)
                (("2" (hide -2)
                  (("2" (expand "max_var_rec" 2 2)
                    (("2" (inst -1 "max(mx, dlvar_index(cons1_var`1))")
                      (("2" (replace -1 2 rl)
                        (("2" (hide -1) (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (int_max application-judgement "{k: int | i <= k AND j <= k}"
     real_defs nil)
    (dlvar_index adt-accessor-decl "[dLVar -> nat]" hp_def nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (null_MapExprInj name-judgement "MapExprInj" hp_def nil)
    (list_induction formula-decl nil list_adt nil)
    (dLVar type-decl nil hp_def nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def nil)
    (RealExpr type-eq-decl nil hp_def nil)
    (MapExpr type-eq-decl nil hp_def nil)
    (max_var_rec def-decl "nat" hp_def nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil))
   shostak))
 (max_var_max 0
  (max_var_max-1 nil 3798385144
   ("" (induct "ode")
    (("1" (skeep)
      (("1" (grind) (("1" (typepred "i") (("1" (grind) nil nil)) nil))
        nil))
      nil)
     ("2" (skeep)
      (("2" (case "cons2_var=null")
        (("1" (hide -2)
          (("1" (skeep)
            (("1" (typepred "i")
              (("1" (expand "length" -1)
                (("1" (expand "length" -1)
                  (("1" (assert) (("1" (grind) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (skeep)
          (("2" (case "i=0")
            (("1" (expand "nth" 2 1)
              (("1" (assert)
                (("1" (expand "max_var" 2 1)
                  (("1" (expand "max_var_rec" 2 1)
                    (("1" (lemma "max_var_rec_pull")
                      (("1" (inst?)
                        (("1" (replace -1 2 rl)
                          (("1" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (expand "nth" 3 1)
              (("2" (assert)
                (("2" (expand "max_var" 3 1)
                  (("2" (expand "max_var_rec" 3 1)
                    (("2" (lemma "max_var_rec_pull")
                      (("2" (inst?)
                        (("2" (replace -1 3 rl)
                          (("2" (inst -2 "i-1")
                            (("2" (expand "max_var" -2)
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (max_var_rec_pull formula-decl nil hp_def nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (int_max application-judgement "{k: int | i <= k AND j <= k}"
     real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (max_var_rec def-decl "nat" hp_def nil)
    (null_MapExprInj name-judgement "MapExprInj" hp_def nil)
    (list_induction formula-decl nil list_adt nil)
    (dLVar type-decl nil hp_def nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def nil)
    (RealExpr type-eq-decl nil hp_def nil)
    (MapExpr type-eq-decl nil hp_def nil)
    (max_var const-decl "nat" hp_def nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (dlvar_index adt-accessor-decl "[dLVar -> nat]" hp_def nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil) (list type-decl nil list_adt nil))
   shostak))
 (max_var_exist 0
  (max_var_exist-1 nil 3798389200
   ("" (induct "ode")
    (("1" (assert) nil nil) ("2" (assert) nil nil)
     ("3" (skeep)
      (("3" (case "cons2_var=null")
        (("1" (hide -2)
          (("1" (inst 1 "0")
            (("1" (grind) nil nil)
             ("2" (expand "length" 1 1) (("2" (assert) nil nil)) nil))
            nil))
          nil)
         ("2" (assert)
          (("2" (expand "max_var" 2 1)
            (("2" (expand "max_var_rec" 2 1)
              (("2" (lemma "max_var_rec_pull")
                (("2"
                  (inst -1 "cons2_var"
                   "max(0, dlvar_index(cons1_var`1))")
                  (("2" (replace -1 2 rl)
                    (("2" (hide -1)
                      (("2"
                        (case "dlvar_index(cons1_var`1) >= max_var_rec(cons2_var, 0)")
                        (("1" (inst 2 "0")
                          (("1" (expand "nth" 2)
                            (("1" (expand "max" 2)
                              (("1"
                                (lift-if 2)
                                (("1"
                                  (split 2)
                                  (("1"
                                    (flatten)
                                    (("1" (assert) nil nil))
                                    nil)
                                   ("2"
                                    (flatten)
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (expand "length" 1 1)
                            (("2" (assert) nil nil)) nil))
                          nil)
                         ("2" (skeep -1)
                          (("2" (expand "max_var" -1)
                            (("2" (inst 3 "i+1")
                              (("1"
                                (expand "nth" 3 1)
                                (("1" (grind) nil nil))
                                nil)
                               ("2"
                                (expand "length" 1 1)
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((AND const-decl "[bool, bool -> bool]" booleans nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (max_var_rec_pull formula-decl nil hp_def nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (max_var_rec def-decl "nat" hp_def nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (int_max application-judgement "{k: int | i <= k AND j <= k}"
     real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null_MapExprInj name-judgement "MapExprInj" hp_def nil)
    (list_induction formula-decl nil list_adt nil)
    (dLVar type-decl nil hp_def nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def nil)
    (RealExpr type-eq-decl nil hp_def nil)
    (MapExpr type-eq-decl nil hp_def nil)
    (max_var const-decl "nat" hp_def nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (dlvar_index adt-accessor-decl "[dLVar -> nat]" hp_def nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (pigeon_map 0
  (pigeon_map-1 nil 3798388885
   ("" (induct "n")
    (("1" (assert) nil nil) ("2" (assert) nil nil)
     ("3" (skeep)
      (("3" (case "j=0")
        (("1" (hide -2)
          (("1" (skeep)
            (("1" (assert)
              (("1" (inst -3 "0") (("1" (assert) nil nil)) nil)) nil))
            nil))
          nil)
         ("2" (assert)
          (("2" (skeep)
            (("2" (case "NOT EXISTS(i:below(1+j)): f(i) = j-1")
              (("1" (inst -1 "f")
                (("1" (assert)
                  (("1" (split -1)
                    (("1" (skeep) (("1" (inst 3 "j1" "j2") nil nil))
                      nil)
                     ("2" (skeep)
                      (("2" (assert)
                        (("2" (inst 2 "i")
                          (("2" (inst -2 "i") (("2" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (skeep -1)
                (("2"
                  (inst -2
                   "LAMBDA(n:nat): IF n<i THEN f(n) ELSE f(n+1) ENDIF")
                  (("2" (assert)
                    (("2" (split -2)
                      (("1" (skeep)
                        (("1" (assert)
                          (("1" (lift-if -1)
                            (("1" (split -1)
                              (("1"
                                (flatten)
                                (("1"
                                  (lift-if -2)
                                  (("1"
                                    (split -2)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (assert)
                                        (("1"
                                          (inst 2 "j1" "j2")
                                          nil
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (assert)
                                      (("2"
                                        (flatten)
                                        (("2"
                                          (inst 3 "j1" "1+j2")
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (flatten)
                                (("2"
                                  (lift-if -1)
                                  (("2"
                                    (split -1)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (inst 3 "1+j1" "j2")
                                        (("1" (assert) nil nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (flatten)
                                      (("2"
                                        (inst 4 "j1+1" "j2+1")
                                        (("2" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (skeep)
                        (("2" (lift-if 1)
                          (("2" (split 1)
                            (("1" (flatten)
                              (("1"
                                (inst -4 "i_1")
                                (("1"
                                  (assert)
                                  (("1"
                                    (inst 3 "i_1" "i")
                                    (("1" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (flatten)
                              (("2"
                                (assert)
                                (("2"
                                  (inst -3 "1+i_1")
                                  (("2"
                                    (inst 4 "1+i_1" "i")
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (/= const-decl "boolean" notequal nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (max_var_length 0
  (max_var_length-2 nil 3899309623
   ("" (skeep)
    (("" (case "null?(ode)")
      (("1" (grind) nil nil)
       ("2"
        (case "FORALL(i:below(length(ode))): dlvar_index(nth(ode,i)`1) < length(ode)-1")
        (("1" (lemma "pigeon_map")
          (("1"
            (inst -1
             "LAMBDA(i:nat): IF i<length(ode) THEN dlvar_index(nth(ode,i)`1) ELSE 0 ENDIF"
             "length(ode)")
            (("1" (assert)
              (("1" (split -1)
                (("1" (skeep)
                  (("1" (typepred "ode")
                    (("1" (rewrite "mapexpr_inj_eq")
                      (("1" (inst -1 "j1" "j2")
                        (("1" (assert)
                          (("1" (flatten)
                            (("1" (lemma "dLVar_dlvar_extensionality")
                              (("1"
                                (inst?)
                                (("1" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (propax) nil nil))
                nil))
              nil)
             ("2" (expand "length" 1 1) (("2" (assert) nil nil)) nil))
            nil))
          nil)
         ("2" (skeep)
          (("2" (lemma "max_var_exist")
            (("2" (inst?)
              (("1" (skeep)
                (("1" (lemma "max_var_max")
                  (("1" (inst -1 "ode" "i") (("1" (assert) nil nil))
                    nil))
                  nil))
                nil)
               ("2" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ODEs type-eq-decl nil hp_def nil)
    (mapexpr_inj const-decl "bool" hp_def nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def nil)
    (RealExpr type-eq-decl nil hp_def nil)
    (Environment type-eq-decl nil hp_def nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (dLVar type-decl nil hp_def nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (length def-decl "nat" list_props nil)
    (max_var const-decl "nat" hp_def nil)
    (max_var_rec def-decl "nat" hp_def nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (max_var_max formula-decl nil hp_def nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (max_var_exist formula-decl nil hp_def nil)
    (pigeon_map formula-decl nil hp_def nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (mapexpr_inj_eq formula-decl nil hp_def nil)
    (dLVar_dlvar_extensionality formula-decl nil hp_def nil)
    (dlvar? adt-recognizer-decl "[dLVar -> boolean]" hp_def nil)
    (/= const-decl "boolean" notequal nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (dlvar_index adt-accessor-decl "[dLVar -> nat]" hp_def nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (null_MapExprInj name-judgement "MapExprInj" hp_def nil))
   nil)
  (max_var_length-1 nil 3798374085
   ("" (skeep)
    (("" (case "null?(ode)")
      (("1" (grind) nil nil)
       ("2"
        (case "FORALL(i:below(length(ode))): nth(ode,i)`1 < length(ode)-1")
        (("1" (lemma "pigeon_map")
          (("1"
            (inst -1
             "LAMBDA(i:nat): IF i<length(ode) THEN nth(ode,i)`1 ELSE 0 ENDIF"
             "length(ode)")
            (("1" (assert)
              (("1" (split -1)
                (("1" (skeep)
                  (("1" (typepred "ode")
                    (("1" (expand "mapexpr_inj")
                      (("1" (inst -1 "j1" "j2")
                        (("1" (assert) nil nil)
                         ("2" (typepred "ode")
                          (("2" (expand "mapexpr_inj")
                            (("2" (inst -1 "j2" "j1")
                              (("1" (assert) nil nil)
                               ("2" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (propax) nil nil))
                nil))
              nil)
             ("2" (expand "length" 1 1) (("2" (assert) nil nil)) nil))
            nil))
          nil)
         ("2" (skeep)
          (("2" (lemma "max_var_exist")
            (("2" (inst?)
              (("1" (skeep)
                (("1" (assert)
                  (("1" (flip-ineq 1)
                    (("1" (lemma "max_var_max")
                      (("1" (inst -1 "ode" "i")
                        (("1" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak))
 (nip_max_var 0
  (nip_max_var-1 nil 3798373840
   (""
    (case " FORALL(m:nat, ode: ODEs, i: above(max_var(ode))): length(ode)=m IMPLIES not_in_map(ode)(i)")
    (("1" (skeep) (("1" (inst -1 "length(ode)" "ode" "i") nil nil))
      nil)
     ("2" (hide 2)
      (("2" (skeep)
        (("2" (case "i=0")
          (("1" (expand "not_in_map" 1 1)
            (("1" (typepred "i")
              (("1" (skeep)
                (("1" (typepred "i_1") (("1" (assert) nil nil)) nil))
                nil))
              nil))
            nil)
           ("2" (expand "not_in_map" 2 1)
            (("2" (skeep)
              (("2" (typepred "i")
                (("2" (lemma "max_var_max")
                  (("2" (inst -1 "ode" "i_1") (("2" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (max_var_max formula-decl nil hp_def nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (null_MapExprInj name-judgement "MapExprInj" hp_def nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (dLVar type-decl nil hp_def nil)
    (Environment type-eq-decl nil hp_def nil)
    (RealExpr type-eq-decl nil hp_def nil)
    (MapExpr type-eq-decl nil hp_def nil)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def nil)
    (ODEs type-eq-decl nil hp_def nil) (> const-decl "bool" reals nil)
    (max_var const-decl "nat" hp_def nil)
    (above nonempty-type-eq-decl nil integers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (MapExprInj type-eq-decl nil hp_def nil)
    (not_in_map const-decl "bool" hp_def nil))
   shostak)))

