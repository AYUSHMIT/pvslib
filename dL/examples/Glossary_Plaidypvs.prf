(Glossary_Plaidypvs
 (dl_axiom_example 0
  (n "n" 3876421024 ("" (skeep) (("" (dl-axiom 3) nil nil)) nil)
   ((dl_axiom formula-decl nil dynamic_logic dL)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (append def-decl "list[T]" list_props nil)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (TRUE const-decl "bool" booleans nil)
    (length def-decl "nat" list_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (Formulas type-eq-decl nil bool_expr dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (RealExpr type-eq-decl nil hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (dLVar type-decl nil hp_def dL) (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (dl_moveR formula-decl nil dynamic_logic dL))
   shostak)
  (dl_axiom_example-1 nil 3876420819
   ("" (dl-flatten) (("" (postpone) nil nil)) nil)
   ((dl_axiom formula-decl nil dynamic_logic dL)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (val const-decl "real" hp_def dL) (list type-decl nil list_adt nil)
    (Formulas type-eq-decl nil bool_expr dL)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil))
   shostak))
 (dl_andL_example 0
  (dl_andL_example-1 nil 3876421306
   ("" (skeep) (("" (dl-andL) (("" (dl-axiom) nil nil)) nil)) nil)
   ((null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (val const-decl "real" hp_def dL) (dLVar type-decl nil hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (gamma__45 skolem-const-decl "(cons?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (dl_andL formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (cnst const-decl "real" hp_def dL)
    (delta__46 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (dl_axiom formula-decl nil dynamic_logic dL))
   shostak))
 (dl_andR_example 0
  (dl_andR_example-1 nil 3876422373
   ("" (skeep)
    (("" (dl-flatten)
      (("" (dl-andR)
        (("1" (dl-axiom) nil nil) ("2" (dl-assert) nil nil)) nil))
      nil))
    nil)
   ((gamma__47 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (Formulas type-eq-decl nil bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (dLVar type-decl nil hp_def dL) (val const-decl "real" hp_def dL)
    (DLAND const-decl "bool" bool_expr dL)
    (cnst const-decl "real" hp_def dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (delta__48 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (\|- const-decl "bool" dynamic_logic dL)
    (length def-decl "nat" list_props nil)
    (for const-decl "T" for_iterate structures)
    (nth def-decl "T" list_props nil) (<= const-decl "bool" reals nil)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (iterate_left const-decl "T" for_iterate structures)
    (dl_axiom formula-decl nil dynamic_logic dL)
    (delta__50 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (gamma__49 skolem-const-decl "(cons?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (dl_andR formula-decl nil dynamic_logic dL))
   shostak))
 (dl_anyb_example 0
  (dl_anyb_example-1 nil 3873836410
   ("" (skeep)
    (("" (dl-anyb)
      (("" (dl-skolem "X")
        (("" (dl-subs)
          (("" (dl-flatten) (("" (dl-assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (delta__86 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (dl_anyb_with formula-decl nil dynamic_logic dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (dLVar type-decl nil hp_def dL) (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (gamma__85 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (QBoolExpr type-eq-decl nil hp_def dL)
    (DLFORALL const-decl "bool" bool_expr dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (Substitution type-eq-decl nil substitution dL)
    (SUB const-decl "bool" substitution dL)
    (DLIMPLIES const-decl "bool" bool_expr dL)
    (same_var const-decl "bool" hp_def dL)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (dl_sub_implies formula-decl nil substitution dL)
    (dl_sub_ge formula-decl nil substitution dL)
    (dl_subre_const formula-decl nil substitution dL)
    (dl_subre_val formula-decl nil substitution dL)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (\|- const-decl "bool" dynamic_logic dL)
    (length def-decl "nat" list_props nil)
    (for const-decl "T" for_iterate structures)
    (nth def-decl "T" list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (<= const-decl "bool" reals nil)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (iterate_left const-decl "T" for_iterate structures)
    (delta__90 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (gamma__89 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (gamma__87 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (x skolem-const-decl "dLVar" Glossary_Plaidypvs nil)
    (Formulas type-eq-decl nil bool_expr dL)
    (dl_forallR formula-decl nil dynamic_logic dL)
    (delta__88 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil))
   shostak))
 (dl_anyd_example 0
  (dl_anyd_example-1 nil 3873837253
   ("" (skeep)
    (("" (dl-anyd)
      (("" (dl-inst "1")
        (("" (dl-subs)
          (("" (dl-andR)
            (("1" (dl-assert) nil nil) ("2" (dl-assert) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (delta__94 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (dl_anyd_with formula-decl nil dynamic_logic dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (dLVar type-decl nil hp_def dL) (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (gamma__93 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (DLAND const-decl "bool" bool_expr dL)
    (SUB const-decl "bool" substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (DLEXISTS const-decl "bool" bool_expr dL)
    (QBoolExpr type-eq-decl nil hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (same_var const-decl "bool" hp_def dL)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (dl_sub_and formula-decl nil substitution dL)
    (dl_sub_ge formula-decl nil substitution dL)
    (dl_subre_const formula-decl nil substitution dL)
    (dl_subre_val formula-decl nil substitution dL)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (\|- const-decl "bool" dynamic_logic dL)
    (length def-decl "nat" list_props nil)
    (for const-decl "T" for_iterate structures)
    (nth def-decl "T" list_props nil) (<= const-decl "bool" reals nil)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (iterate_left const-decl "T" for_iterate structures)
    (gamma__97 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (dl_andR formula-decl nil dynamic_logic dL)
    (delta__98 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (delta__96 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (dl_existsR formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (x skolem-const-decl "dLVar" Glossary_Plaidypvs nil)
    (gamma__95 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil))
   shostak))
 (dl_assert_example 0
  (dl_assert_example-1 nil 3876423003
   ("" (beta) (("" (dl-assert) nil nil)) nil)
   ((null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (> const-decl "BoolExpr" bool_expr dL)
    (DLOR const-decl "bool" bool_expr dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (ASSIGN adt-constructor-decl "[Assigns -> (assign?)]" HP_adt dL)
    (assign? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (Assigns type-eq-decl nil hp_def dL)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (UNION adt-constructor-decl "[[HP, HP] -> (union?)]" HP_adt dL)
    (union? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (boolean nonempty-type-decl nil booleans nil)
    (HP type-decl nil HP_adt dL)
    (dl_composeb formula-decl nil dynamic_logic dL)
    (dl_choiceb formula-decl nil dynamic_logic dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (dl_assignb formula-decl nil dynamic_logic dL)
    (Substitution type-eq-decl nil substitution dL)
    (SUB const-decl "bool" substitution dL)
    (TRUE const-decl "bool" booleans nil)
    (dl_sub_or formula-decl nil substitution dL)
    (dl_sub_gt formula-decl nil substitution dL)
    (SUB_Re const-decl "real" substitution dL)
    (dl_subre_const formula-decl nil substitution dL)
    (dl_subre_minus formula-decl nil substitution dL)
    (dl_subre_val formula-decl nil substitution dL)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (FALSE const-decl "bool" booleans nil)
    (dl_subre_plus formula-decl nil substitution dL)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (length def-decl "nat" list_props nil)
    (for const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (> const-decl "bool" reals nil) (nth def-decl "T" list_props nil)
    (iterate_left const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (dl_orR formula-decl nil dynamic_logic dL)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (dl_andR formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (same_var const-decl "bool" hp_def dL)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil))
   shostak))
 (dl_assignb_example 0
  (dl_assignb_example-1 nil 3876423972
   ("" (dl-assignb) (("" (dl-assert) nil nil)) nil)
   ((real_plus_real_is_real application-judgement "real" reals nil)
    (\|- const-decl "bool" dynamic_logic dL)
    (for const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (nth def-decl "T" list_props nil)
    (iterate_left const-decl "T" for_iterate structures)
    (length def-decl "nat" list_props nil)
    (same_var const-decl "bool" hp_def dL)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (dl_sub_eq formula-decl nil substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (dl_subre_const formula-decl nil substitution dL)
    (dl_subre_val formula-decl nil substitution dL)
    (Assigns type-eq-decl nil hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (dl_assignb formula-decl nil dynamic_logic dL)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL))
   shostak))
 (dl_assignd_example 0
  (dl_assignd_example-1 nil 3876424097
   ("" (dl-assignd) (("" (dl-assert) nil nil)) nil)
   ((real_plus_real_is_real application-judgement "real" reals nil)
    (\|- const-decl "bool" dynamic_logic dL)
    (for const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (nth def-decl "T" list_props nil)
    (iterate_left const-decl "T" for_iterate structures)
    (length def-decl "nat" list_props nil)
    (same_var const-decl "bool" hp_def dL)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (dl_sub_eq formula-decl nil substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (dl_subre_const formula-decl nil substitution dL)
    (dl_subre_val formula-decl nil substitution dL)
    (Assigns type-eq-decl nil hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (dl_assignd formula-decl nil dynamic_logic dL)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL))
   shostak))
 (dl_boxd_example 0
  (dl_boxd_example-1 nil 3876424196
   ("" (relabel (:pairing |fn!:724|) (1))
    (("" (lemma "dl_boxd")
      (("" (touch (delabel (|gamma_:725| |delta_:726|)))
        (("" (inst?)
          (("" (replace -1 1 rl)
            (("" (hide -1)
              (("" (dl-assignb) (("" (dl-assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((dl_boxd formula-decl nil dynamic_logic dL)
    (HP type-decl nil HP_adt dL)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (Assigns type-eq-decl nil hp_def dL)
    (assign? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ASSIGN adt-constructor-decl "[Assigns -> (assign?)]" HP_adt dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (val const-decl "real" hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (cnst const-decl "real" hp_def dL)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (\|- const-decl "bool" dynamic_logic dL)
    (for const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (nth def-decl "T" list_props nil) (<= const-decl "bool" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (iterate_left const-decl "T" for_iterate structures)
    (length def-decl "nat" list_props nil)
    (same_var const-decl "bool" hp_def dL)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (dl_sub_ge formula-decl nil substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (dl_subre_const formula-decl nil substitution dL)
    (dl_subre_val formula-decl nil substitution dL)
    (dl_assignb formula-decl nil dynamic_logic dL)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (dl_choiceb_example 0
  (dl_choiceb_example-1 nil 3876424762
   ("" (dl-choiceb)
    (("" (dl-andR)
      (("1" (dl-assert) nil nil) ("2" (dl-assert) nil nil)) nil))
    nil)
   ((dl_andR formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (same_var const-decl "bool" hp_def dL)
    (length def-decl "nat" list_props nil)
    (iterate_left const-decl "T" for_iterate structures)
    (<= const-decl "bool" reals nil) (nth def-decl "T" list_props nil)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (dl_subre_val formula-decl nil substitution dL)
    (dl_subre_const formula-decl nil substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (dl_sub_ge formula-decl nil substitution dL)
    (dl_assignb formula-decl nil dynamic_logic dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (DLAND const-decl "bool" bool_expr dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (val const-decl "real" hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (ASSIGN adt-constructor-decl "[Assigns -> (assign?)]" HP_adt dL)
    (assign? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (Assigns type-eq-decl nil hp_def dL) (HP type-decl nil HP_adt dL)
    (dl_choiceb formula-decl nil dynamic_logic dL)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cnst const-decl "real" hp_def dL))
   shostak))
 (dl_choiced_example 0
  (dl_choiced_example-1 nil 3876428543
   ("" (dl-choiced)
    (("" (dl-ground)
      (("" (dl-hide 2)
        (("" (dl-assignd) (("" (dl-assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((dl_orR formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (dl_assignd formula-decl nil dynamic_logic dL)
    (dl_subre_val formula-decl nil substitution dL)
    (dl_subre_const formula-decl nil substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (dl_sub_ge formula-decl nil substitution dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (same_var const-decl "bool" hp_def dL)
    (iterate_left const-decl "T" for_iterate structures)
    (<= const-decl "bool" reals nil) (nth def-decl "T" list_props nil)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (dl_hideR formula-decl nil dynamic_logic dL)
    (dl_moveR formula-decl nil dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (length def-decl "nat" list_props nil)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (append def-decl "list[T]" list_props nil)
    (DLOR const-decl "bool" bool_expr dL)
    (SOMERUNS const-decl "bool" bool_expr dL)
    (val const-decl "real" hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (ASSIGN adt-constructor-decl "[Assigns -> (assign?)]" HP_adt dL)
    (assign? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (Assigns type-eq-decl nil hp_def dL) (HP type-decl nil HP_adt dL)
    (dl_choiced formula-decl nil dynamic_logic dL)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cnst const-decl "real" hp_def dL))
   shostak))
 (dl_composeb_example 0
  (dl_composeb_example-1 nil 3876430667
   ("" (dl-composeb)
    (("" (dl-assignb)
      (("" (dl-testb)
        (("" (dl-flatten) (("" (dl-assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((dl_assignb formula-decl nil dynamic_logic dL)
    (dl_subre_val formula-decl nil substitution dL)
    (dl_subre_const formula-decl nil substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (dl_sub_lt formula-decl nil substitution dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (same_var const-decl "bool" hp_def dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (length def-decl "nat" list_props nil)
    (iterate_left const-decl "T" for_iterate structures)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (<= const-decl "bool" reals nil) (nth def-decl "T" list_props nil)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (DLIMPLIES const-decl "bool" bool_expr dL)
    (dl_testb formula-decl nil dynamic_logic dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (< const-decl "BoolExpr" bool_expr dL)
    (ASSIGN adt-constructor-decl "[Assigns -> (assign?)]" HP_adt dL)
    (assign? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (Assigns type-eq-decl nil hp_def dL)
    (val const-decl "real" hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (TEST adt-constructor-decl "[BoolExpr -> (test?)]" HP_adt dL)
    (test? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (HP type-decl nil HP_adt dL)
    (dl_composeb formula-decl nil dynamic_logic dL)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cnst const-decl "real" hp_def dL)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil))
   shostak))
 (dl_composed_example 0
  (dl_composed_example-1 nil 3876430708
   ("" (dl-flatten)
    (("" (dl-composed)
      (("" (dl-testd)
        (("" (rewrite "dl_testd")
          (("" (dl-assignd) (("" (dl-assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((dl_composed formula-decl nil dynamic_logic dL)
    (dl_testd formula-decl nil dynamic_logic dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (length def-decl "nat" list_props nil)
    (iterate_left const-decl "T" for_iterate structures)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (<= const-decl "bool" reals nil) (nth def-decl "T" list_props nil)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (dl_andR formula-decl nil dynamic_logic dL)
    (DLAND const-decl "bool" bool_expr dL)
    (same_var const-decl "bool" hp_def dL)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (dl_sub_ge formula-decl nil substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (dl_subre_const formula-decl nil substitution dL)
    (dl_subre_val formula-decl nil substitution dL)
    (dl_assignd formula-decl nil dynamic_logic dL)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (ASSIGN adt-constructor-decl "[Assigns -> (assign?)]" HP_adt dL)
    (assign? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (Assigns type-eq-decl nil hp_def dL)
    (TEST adt-constructor-decl "[BoolExpr -> (test?)]" HP_adt dL)
    (test? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (SEQ adt-constructor-decl "[[HP, HP] -> (seq?)]" HP_adt dL)
    (seq? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (SOMERUNS const-decl "bool" bool_expr dL)
    (HP type-decl nil HP_adt dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL))
   shostak))
 (dl_case_example 0
  (dl_case_example-1 nil 3876430559
   ("" (skeep)
    (("" (dl-case "cnst(c)>=0")
      (("1" (dl-choiceb)
        (("1" (dl-andR)
          (("1" (dl-assert) nil nil) ("2" (dl-assert) nil nil)) nil))
        nil)
       ("2" (dl-assert) nil nil))
      nil))
    nil)
   ((dl_cut formula-decl nil dynamic_logic dL)
    (val const-decl "real" hp_def dL)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (DLNOT const-decl "bool" bool_expr dL)
    (ASSIGN adt-constructor-decl "[Assigns -> (assign?)]" HP_adt dL)
    (assign? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (Assigns type-eq-decl nil hp_def dL)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (TEST adt-constructor-decl "[BoolExpr -> (test?)]" HP_adt dL)
    (test? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (SEQ adt-constructor-decl "[[HP, HP] -> (seq?)]" HP_adt dL)
    (seq? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (UNION adt-constructor-decl "[[HP, HP] -> (union?)]" HP_adt dL)
    (union? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (HP type-decl nil HP_adt dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (Formulas type-eq-decl nil bool_expr dL)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (TRUE const-decl "bool" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (dl_andR formula-decl nil dynamic_logic dL)
    (same_var const-decl "bool" hp_def dL)
    (dl_axiom formula-decl nil dynamic_logic dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (dl_subre_val formula-decl nil substitution dL)
    (dl_subre_const formula-decl nil substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (dl_sub_ge formula-decl nil substitution dL)
    (dl_assignb formula-decl nil dynamic_logic dL)
    (dl_testb formula-decl nil dynamic_logic dL)
    (dl_composeb formula-decl nil dynamic_logic dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (dl_notL formula-decl nil dynamic_logic dL)
    (DLAND const-decl "bool" bool_expr dL)
    (dl_choiceb formula-decl nil dynamic_logic dL)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (dl_moveR formula-decl nil dynamic_logic dL)
    (DLIMPLIES const-decl "bool" bool_expr dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (length def-decl "nat" list_props nil)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (append def-decl "list[T]" list_props nil)
    (\|- const-decl "bool" dynamic_logic dL)
    (for const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (nth def-decl "T" list_props nil) (<= const-decl "bool" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (iterate_left const-decl "T" for_iterate structures)
    (real_plus_real_is_real application-judgement "real" reals nil))
   shostak))
 (dl_diffcase_example 0
  (dl_diffcase_example-1 nil 3877099018
   ("" (dl-flatten)
    (("" (dl-diffcase "val(x) ^ 2 > cnst(5)")
      (("1" (dl-assert) nil nil) ("2" (dl-assert) nil nil)) nil))
    nil)
   ((dl_dC formula-decl nil dynamic_logic dL)
    (dl_axiom formula-decl nil dynamic_logic dL)
    (append def-decl "list[T]" list_props nil)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (length def-decl "nat" list_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (dl_moveL formula-decl nil dynamic_logic dL)
    (dl_andL formula-decl nil dynamic_logic dL)
    (cnst const-decl "real" hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (DLBOOL const-decl "bool" bool_expr dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (val const-decl "real" hp_def dL)
    (> const-decl "BoolExpr" bool_expr dL)
    (DIFF adt-constructor-decl "[[ODEs, BoolExpr] -> (diff?)]" HP_adt
     dL)
    (diff? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ODEs type-eq-decl nil hp_def dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (HP type-decl nil HP_adt dL) (DLAND const-decl "bool" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL))
   shostak))
 (dl_diffghost_example 0
  (dl_diffghost_example-1 nil 3882037909
   ("" (beta)
    (("" (dl-flatten)
      ((""
        (dl-diffghost "cnst(-1/2)" "cnst(0)" "G"
         "val(x)*val(G)^2=cnst(1)")
        (("1" (dl-inst "div_safe_re(cnst(1),val(x)^^(1/2))")
          (("1" (dl-diffinv)
            (("1" (grind :exclude "^^")
              (("1" (grind) nil nil)
               ("2" (lemma "sqrt_hathat") (("2" (grind) nil nil)) nil))
              nil)
             ("2" (dl-assert) nil nil))
            nil))
          nil)
         ("2" (dl-assert) nil nil) ("3" (dl-assert) nil nil))
        nil))
      nil))
    nil)
   ((Formulas type-eq-decl nil bool_expr dL)
    (> const-decl "BoolExpr" bool_expr dL)
    (cnst const-decl "real" hp_def dL) (HP type-decl nil HP_adt dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (ODEs type-eq-decl nil hp_def dL)
    (diff? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (DIFF adt-constructor-decl "[[ODEs, BoolExpr] -> (diff?)]" HP_adt
     dL)
    (DLBOOL const-decl "bool" bool_expr dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (val const-decl "real" hp_def dL)
    (dl_axiom formula-decl nil dynamic_logic dL)
    (dl_existsrRf formula-decl nil dynamic_logic dL)
    (^^ const-decl "RealExpr" differentiation dL)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (fresh_re_div_safe formula-decl nil fresh_props dL)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (fresh_re_exp formula-decl nil fresh_props dL)
    (dl_composeb formula-decl nil dynamic_logic dL)
    (Substitution type-eq-decl nil substitution dL)
    (SUB const-decl "bool" substitution dL)
    (dl_assignb formula-decl nil dynamic_logic dL)
    (dl_subf formula-decl nil dynamic_logic dL)
    (dl_trueL formula-decl nil dynamic_logic dL)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (\|- const-decl "bool" dynamic_logic dL)
    (^ const-decl "real" exponentiation nil)
    (expt def-decl "real" exponentiation nil)
    (iterate_left const-decl "T" for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (div_safe const-decl "real" reals_safe_ops reals)
    (nth def-decl "T" list_props nil)
    (length def-decl "nat" list_props nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nzreal_div_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil)
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil)
    (int_times_even_is_even application-judgement "even_int" integers
     nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (exp_0 formula-decl nil ln_exp lnexp_fnd)
    (expt const-decl "real" differentiation dL)
    (^^ const-decl "nnreal" expt lnexp_fnd)
    (ln const-decl "real" ln_exp lnexp_fnd)
    (Integral const-decl "real" integral_def analysis)
    (posreal_div_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (sqrt_hathat formula-decl nil differentiation dL)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (FALSE const-decl "bool" booleans nil)
    (same_var const-decl "bool" hp_def dL)
    (diff_re_cnst formula-decl nil diff_re_props dL)
    (diff_re_prod formula-decl nil diff_re_props dL)
    (diff_re? const-decl "bool" chain_rule_re dL)
    (diff_re_pow formula-decl nil diff_re_props dL)
    (diff_re_val formula-decl nil diff_re_props dL)
    (derivable_M_nqbool? inductive-decl "bool" chain_rule_re dL)
    (dl_dift_const formula-decl nil differentiation dL)
    (dl_dift_pow formula-decl nil differentiation dL)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<= const-decl "bool" reals nil)
    (dl_dift_val formula-decl nil differentiation dL)
    (derivable_up? const-decl "bool" differentiation dL)
    (ddl_dom_upto? const-decl "bool" differentiation dL)
    (dl_derivable_up_val formula-decl nil differentiation dL)
    (dl_derivable_up_pow formula-decl nil differentiation dL)
    (ddt def-decl "RealExpr" differentiation dL)
    (dl_dift_mult formula-decl nil differentiation dL)
    (const_fun const-decl "[T -> real]" real_fun_ops reals)
    (scal_function formula-decl nil real_fun_ops reals)
    (max_var const-decl "nat" hp_def dL)
    (DIFT def-decl "BoolExpr" differentiation dL)
    (SUB_DIFT const-decl "BoolExpr" differentiation dL)
    (normalize_rec def-decl "{nnqbe: NormNQBool |
   FORALL (env: Environment):
     nqb_to_be(nnqbe)(env) = (pos IFF nqb_to_be(nqbe)(env))}" bool_expr
     dL)
    (dl_dI_dlTRUE formula-decl nil dynamic_logic dL)
    (nqb_rel const-decl "BoolExpr" bool_expr dL)
    (nqb_eq adt-constructor-decl "(nqb_eq?)" hp_def dL)
    (nqb_eq? adt-recognizer-decl "[NQB_REL -> boolean]" hp_def dL)
    (NQB_rel adt-constructor-decl
     "[[NQB_REL, RealExpr, RealExpr] -> (nqb_rel?)]" NQBool_adt dL)
    (nqb_rel? adt-recognizer-decl "[NQBool -> boolean]" NQBool_adt dL)
    (NQB_REL type-decl nil hp_def dL)
    (normalize const-decl
     "{nnqbe: NormNQBool | nqb_to_be(nnqbe) = nqb_to_be(nqbe)}"
     bool_expr dL)
    (nqb_to_be def-decl "BoolExpr" bool_expr dL)
    (NormNQBool type-eq-decl nil bool_expr dL)
    (nqb_normal? inductive-decl "bool" bool_expr dL)
    (NQBool type-decl nil NQBool_adt dL)
    (DLEXISTSRf const-decl "bool" bool_expr dL)
    (seq? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (SEQ adt-constructor-decl "[[HP, HP] -> (seq?)]" HP_adt dL)
    (assign? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ASSIGN adt-constructor-decl "[Assigns -> (assign?)]" HP_adt dL)
    (fresh_be_DLTRUE formula-decl nil fresh_props dL)
    (fresh_be_gt formula-decl nil fresh_props dL)
    (fresh_re_val formula-decl nil fresh_props dL)
    (fresh_re_cnst formula-decl nil fresh_props dL)
    (cont_re_cnst formula-decl nil continuity_re_props dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (Assigns type-eq-decl nil hp_def dL)
    (fresh_li? inductive-decl "bool" hp_expr dL)
    (fresh? def-decl "bool" bool_expr dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (= const-decl "BoolExpr" bool_expr dL)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (dl_true_DDL formula-decl nil differentiation dL)
    (dl_differential_ghost formula-decl nil dynamic_logic dL)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (odd? const-decl "bool" integers nil)
    (odd_posnat nonempty-type-eq-decl nil naturalnumbers nil))
   shostak))
 (dl_diffinit_example 0
  (dl_diffinit_example-1 nil 3877095523
   ("" (flatten) (("" (dl-diffinit) nil nil)) nil)
   ((ODEs type-eq-decl nil hp_def dL) (val const-decl "real" hp_def dL)
    (> const-decl "BoolExpr" bool_expr dL)
    (DLBOOL const-decl "bool" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (DIFF adt-constructor-decl "[[ODEs, BoolExpr] -> (diff?)]" HP_adt
     dL)
    (diff? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (HP type-decl nil HP_adt dL)
    (dl_dinit formula-decl nil dynamic_logic dL)
    (cnst const-decl "real" hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil))
   shostak))
 (dl_diffinv_example 0
  (dl_diffinv_example-1 nil 3876429090
   ("" (dl-flatten)
    (("" (dl-diffinv)
      (("1" (dl-assert) nil nil) ("2" (dl-assert) nil nil)) nil))
    nil)
   ((NQBool type-decl nil NQBool_adt dL)
    (nqb_normal? inductive-decl "bool" bool_expr dL)
    (NormNQBool type-eq-decl nil bool_expr dL)
    (nqb_to_be def-decl "BoolExpr" bool_expr dL)
    (normalize const-decl
     "{nnqbe: NormNQBool | nqb_to_be(nnqbe) = nqb_to_be(nqbe)}"
     bool_expr dL)
    (NQB_REL type-decl nil hp_def dL)
    (nqb_rel? adt-recognizer-decl "[NQBool -> boolean]" NQBool_adt dL)
    (NQB_rel adt-constructor-decl
     "[[NQB_REL, RealExpr, RealExpr] -> (nqb_rel?)]" NQBool_adt dL)
    (nqb_eq? adt-recognizer-decl "[NQB_REL -> boolean]" hp_def dL)
    (nqb_eq adt-constructor-decl "(nqb_eq?)" hp_def dL)
    (nqb_rel const-decl "BoolExpr" bool_expr dL)
    (dl_dI_dlTRUE formula-decl nil dynamic_logic dL)
    (normalize_rec def-decl "{nnqbe: NormNQBool |
   FORALL (env: Environment):
     nqb_to_be(nnqbe)(env) = (pos IFF nqb_to_be(nqbe)(env))}" bool_expr
     dL)
    (SUB_DIFT const-decl "BoolExpr" differentiation dL)
    (DIFT def-decl "BoolExpr" differentiation dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (max_var const-decl "nat" hp_def dL)
    (scal_function formula-decl nil real_fun_ops reals)
    (const_fun const-decl "[T -> real]" real_fun_ops reals)
    (dl_dift_plus formula-decl nil differentiation dL)
    (ddt def-decl "RealExpr" differentiation dL)
    (dl_true_DDL formula-decl nil differentiation dL)
    (dl_derivable_up_pow formula-decl nil differentiation dL)
    (dl_derivable_up_val formula-decl nil differentiation dL)
    (ddl_dom_upto? const-decl "bool" differentiation dL)
    (derivable_up? const-decl "bool" differentiation dL)
    (dl_dift_pow formula-decl nil differentiation dL)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (dl_dift_val formula-decl nil differentiation dL)
    (<= const-decl "bool" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (dl_dift_const formula-decl nil differentiation dL)
    (derivable_M_nqbool? inductive-decl "bool" chain_rule_re dL)
    (diff_re_val formula-decl nil diff_re_props dL)
    (diff_re_pow formula-decl nil diff_re_props dL)
    (diff_re? const-decl "bool" chain_rule_re dL)
    (diff_re_sum formula-decl nil diff_re_props dL)
    (diff_re_cnst formula-decl nil diff_re_props dL)
    (same_var const-decl "bool" hp_def dL)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (FALSE const-decl "bool" booleans nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (dl_axiom formula-decl nil dynamic_logic dL)
    (append def-decl "list[T]" list_props nil)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (length def-decl "nat" list_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (dl_moveL formula-decl nil dynamic_logic dL)
    (dl_trueL formula-decl nil dynamic_logic dL)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (\|- const-decl "bool" dynamic_logic dL)
    (for const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (nth def-decl "T" list_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (^ const-decl "real" exponentiation nil)
    (expt def-decl "real" exponentiation nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (iterate_left const-decl "T" for_iterate structures)
    (val const-decl "real" hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (DLBOOL const-decl "bool" bool_expr dL)
    (DIFF adt-constructor-decl "[[ODEs, BoolExpr] -> (diff?)]" HP_adt
     dL)
    (diff? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ODEs type-eq-decl nil hp_def dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (HP type-decl nil HP_adt dL) (cnst const-decl "real" hp_def dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (= const-decl "BoolExpr" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL))
   shostak))
 (dl_falseL_example 0
  (dl_falseL_example-1 nil 3877095184 ("" (dl-falseL) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (RealExpr type-eq-decl nil hp_def dL)
    (> const-decl "BoolExpr" bool_expr dL)
    (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (dl_falseL formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL))
   shostak))
 (dl_flatten_example 0
  (dl_flatten_example-1 nil 3873838249
   ("" (dl-flatten) (("" (dl-assert) nil nil)) nil)
   ((expt def-decl "real" exponentiation nil)
    (^ const-decl "real" exponentiation nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (iterate_left const-decl "T" for_iterate structures)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (<= const-decl "bool" reals nil) (nth def-decl "T" list_props nil)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (append def-decl "list[T]" list_props nil)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (length def-decl "nat" list_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (dl_moveL formula-decl nil dynamic_logic dL)
    (dl_orL formula-decl nil dynamic_logic dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (dl_andL formula-decl nil dynamic_logic dL)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (DLOR const-decl "bool" bool_expr dL)
    (val const-decl "real" hp_def dL)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (cnst const-decl "real" hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (DLAND const-decl "bool" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil))
   shostak))
 (dl_g_example 0
  (dl_g_example-1 nil 3882037873
   ("" (dl-Gb) (("" (dl-assert) nil nil)) nil)
   ((real_plus_real_is_real application-judgement "real" reals nil)
    (\|- const-decl "bool" dynamic_logic dL)
    (for const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (nth def-decl "T" list_props nil) (<= const-decl "bool" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (iterate_left const-decl "T" for_iterate structures)
    (length def-decl "nat" list_props nil)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (HP type-decl nil HP_adt dL)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (ODEs type-eq-decl nil hp_def dL)
    (diff? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (DIFF adt-constructor-decl "[[ODEs, BoolExpr] -> (diff?)]" HP_adt
     dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (val const-decl "real" hp_def dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (DLBOOL const-decl "bool" bool_expr dL)
    (TRUE const-decl "bool" booleans nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (cnst const-decl "real" hp_def dL)
    (dl_const formula-decl nil dynamic_logic dL))
   shostak))
 (dl_ghost_example 0
  (dl_ghost_example-1 nil 3882037814
   ("" (dl-flatten)
    (("" (dl-ghost "val(x)*val(y)")
      (("" (dl-diffinv)
        (("1" (dl-assert) nil nil) ("2" (dl-assert) nil nil)) nil))
      nil))
    nil)
   ((dl_discrete_ghost formula-decl nil dynamic_logic dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (DLIMPLIES const-decl "bool" bool_expr dL)
    (QBoolExpr type-eq-decl nil hp_def dL)
    (dl_forallR formula-decl nil dynamic_logic dL)
    (iterate_left const-decl "T" for_iterate structures)
    (minus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (nth def-decl "T" list_props nil)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (dl_trueL formula-decl nil dynamic_logic dL)
    (dl_moveL formula-decl nil dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (length def-decl "nat" list_props nil)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (append def-decl "list[T]" list_props nil)
    (dl_axiom formula-decl nil dynamic_logic dL)
    (FALSE const-decl "bool" booleans nil)
    (same_var const-decl "bool" hp_def dL)
    (diff_re_cnst formula-decl nil diff_re_props dL)
    (diff_re_prod formula-decl nil diff_re_props dL)
    (diff_re? const-decl "bool" chain_rule_re dL)
    (diff_re_val formula-decl nil diff_re_props dL)
    (derivable_M_nqbool? inductive-decl "bool" chain_rule_re dL)
    (dl_dift_const formula-decl nil differentiation dL)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<= const-decl "bool" reals nil)
    (dl_dift_val formula-decl nil differentiation dL)
    (ddl_dom_upto? const-decl "bool" differentiation dL)
    (dl_derivable_up_val formula-decl nil differentiation dL)
    (dl_true_DDL formula-decl nil differentiation dL)
    (ddt def-decl "RealExpr" differentiation dL)
    (dl_dift_mult formula-decl nil differentiation dL)
    (const_fun const-decl "[T -> real]" real_fun_ops reals)
    (scal_function formula-decl nil real_fun_ops reals)
    (max_var const-decl "nat" hp_def dL)
    (DIFT def-decl "BoolExpr" differentiation dL)
    (SUB_DIFT const-decl "BoolExpr" differentiation dL)
    (normalize_rec def-decl "{nnqbe: NormNQBool |
   FORALL (env: Environment):
     nqb_to_be(nnqbe)(env) = (pos IFF nqb_to_be(nqbe)(env))}" bool_expr
     dL)
    (dl_dI_dlTRUE formula-decl nil dynamic_logic dL)
    (nqb_rel const-decl "BoolExpr" bool_expr dL)
    (nqb_ge adt-constructor-decl "(nqb_ge?)" hp_def dL)
    (nqb_ge? adt-recognizer-decl "[NQB_REL -> boolean]" hp_def dL)
    (NQB_rel adt-constructor-decl
     "[[NQB_REL, RealExpr, RealExpr] -> (nqb_rel?)]" NQBool_adt dL)
    (nqb_rel? adt-recognizer-decl "[NQBool -> boolean]" NQBool_adt dL)
    (NQB_REL type-decl nil hp_def dL)
    (normalize const-decl
     "{nnqbe: NormNQBool | nqb_to_be(nnqbe) = nqb_to_be(nqbe)}"
     bool_expr dL)
    (nqb_to_be def-decl "BoolExpr" bool_expr dL)
    (NormNQBool type-eq-decl nil bool_expr dL)
    (nqb_normal? inductive-decl "bool" bool_expr dL)
    (NQBool type-decl nil NQBool_adt dL)
    (val const-decl "real" hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (DLBOOL const-decl "bool" bool_expr dL)
    (DIFF adt-constructor-decl "[[ODEs, BoolExpr] -> (diff?)]" HP_adt
     dL)
    (diff? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ODEs type-eq-decl nil hp_def dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (HP type-decl nil HP_adt dL) (cnst const-decl "real" hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL))
   shostak))
 (dl_grind_example 0
  (dl_grind_example-1 nil 3882037803 ("" (dl-grind) nil nil)
   ((iterate_left const-decl "T" for_iterate structures)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sqrt_pos application-judgement "posreal" sqrt reals)
    (expt def-decl "real" exponentiation nil)
    (^ const-decl "real" exponentiation nil)
    (<= const-decl "bool" reals nil) (nth def-decl "T" list_props nil)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (dl_orL formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (DLAND const-decl "bool" bool_expr dL)
    (DLOR const-decl "bool" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (nnreal type-eq-decl nil real_types nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt reals)
    (>= const-decl "BoolExpr" bool_expr dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (dl_andL formula-decl nil dynamic_logic dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (dl_moveL formula-decl nil dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (length def-decl "nat" list_props nil)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (append def-decl "list[T]" list_props nil))
   shostak))
 (dl_ground_example 0
  (dl_ground_example-1 nil 3882037789
   ("" (dl-ground)
    (("1" (dl-assert) nil nil) ("2" (dl-assert) nil nil)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (\|- const-decl "bool" dynamic_logic dL)
    (iterate_left const-decl "T" for_iterate structures)
    (nth def-decl "T" list_props nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (<= const-decl "bool" reals nil)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (length def-decl "nat" list_props nil)
    (dl_andL formula-decl nil dynamic_logic dL)
    (dl_orL formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (DLOR const-decl "bool" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (DLAND const-decl "bool" bool_expr dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (dl_orR formula-decl nil dynamic_logic dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil))
   shostak))
 (dl_hide_example 0
  (dl_hide_example-1 nil 3873839405
   ("" (dl-flatten)
    (("" (dl-hide -2)
      (("" (dl-hide + :but 3)
        (("" (dl-hide -2) (("" (dl-assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((length_singleton formula-decl nil more_list_props structures)
    (dl_moveL formula-decl nil dynamic_logic dL)
    (dl_hideL formula-decl nil dynamic_logic dL)
    (iterate_left const-decl "T" for_iterate structures)
    (expt def-decl "real" exponentiation nil)
    (^ const-decl "real" exponentiation nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (<= const-decl "bool" reals nil) (nth def-decl "T" list_props nil)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (dl_hideR formula-decl nil dynamic_logic dL)
    (dl_andL formula-decl nil dynamic_logic dL)
    (append def-decl "list[T]" list_props nil)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (length def-decl "nat" list_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (dl_moveR formula-decl nil dynamic_logic dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (dl_orR formula-decl nil dynamic_logic dL)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (/= const-decl "BoolExpr" bool_expr dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (DLOR const-decl "bool" bool_expr dL)
    (val const-decl "real" hp_def dL)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (cnst const-decl "real" hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (DLAND const-decl "bool" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil))
   shostak))
 (dl_hiderest_example 0
  (dl_hiderest_example-1 nil 3873839746
   ("" (dl-flatten)
    (("" (dl-hiderest (-1 3)) (("" (dl-assert) nil nil)) nil)) nil)
   ((dl_hide_restR formula-decl nil dynamic_logic dL)
    (dl_hide_restL formula-decl nil dynamic_logic dL)
    (iterate_left const-decl "T" for_iterate structures)
    (expt def-decl "real" exponentiation nil)
    (^ const-decl "real" exponentiation nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (<= const-decl "bool" reals nil) (nth def-decl "T" list_props nil)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (dl_andL formula-decl nil dynamic_logic dL)
    (append def-decl "list[T]" list_props nil)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (length def-decl "nat" list_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (dl_moveR formula-decl nil dynamic_logic dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (dl_orR formula-decl nil dynamic_logic dL)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (/= const-decl "BoolExpr" bool_expr dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (DLOR const-decl "bool" bool_expr dL)
    (val const-decl "real" hp_def dL)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (cnst const-decl "real" hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (DLAND const-decl "bool" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil))
   shostak))
 (dl_iff_example 0
  (dl_iff_example-1 nil 3882037750
   ("" (dl-iffR) (("1" (dl-assert) nil nil) ("2" (dl-assert) nil nil))
    nil)
   ((\|- const-decl "bool" dynamic_logic dL)
    (for const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (nth def-decl "T" list_props nil)
    (expt def-decl "real" exponentiation nil)
    (^ const-decl "real" exponentiation nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (iterate_left const-decl "T" for_iterate structures)
    (length def-decl "nat" list_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (Formulas type-eq-decl nil bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (dl_equivR formula-decl nil dynamic_logic dL)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (dl_inst_example 0
  (dl_inst_example-1 nil 3882037720
   ("" (dl-inst "-1")
    (("" (dl-flatten) (("" (dl-assert) nil nil)) nil)) nil)
   ((dl_impliesR formula-decl nil dynamic_logic dL)
    (length def-decl "nat" list_props nil)
    (for const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (<= const-decl "bool" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nth def-decl "T" list_props nil)
    (iterate_left const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (dl_testb formula-decl nil dynamic_logic dL)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (dl_existsR formula-decl nil dynamic_logic dL)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (>= const-decl "BoolExpr" bool_expr dL)
    (TEST adt-constructor-decl "[BoolExpr -> (test?)]" HP_adt dL)
    (test? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (HP type-decl nil HP_adt dL) (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (DLIMPLIES const-decl "bool" bool_expr dL)
    (QBoolExpr type-eq-decl nil hp_def dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil))
   shostak))
 (dl_impliesL_example 0
  (dl_impliesL_example-1 nil 3877103939
   ("" (flatten) (("" (dl-impliesL) nil nil)) nil)
   ((minus_odd_is_odd application-judgement "odd_int" integers nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (> const-decl "BoolExpr" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (dl_impliesL formula-decl nil dynamic_logic dL)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL)
    (< const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (dl_impliesR_example 0
  (dl_impliesR_example-1 nil 3877432643
   ("" (flatten) (("" (dl-impliesR) nil nil)) nil)
   ((dl_impliesR formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (> const-decl "BoolExpr" bool_expr dL)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (< const-decl "BoolExpr" bool_expr dL)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (dl_iterated_example 0
  (dl_iterated_example-1 nil 3882037631
   ("" (dl-flatten) (("" (dl-iterated) (("" (dl-assert) nil nil)) nil))
    nil)
   ((dl_iterated formula-decl nil dynamic_logic dL)
    (DLOR const-decl "bool" bool_expr dL)
    (dl_axiom formula-decl nil dynamic_logic dL)
    (SUB const-decl "bool" substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (dl_orR formula-decl nil dynamic_logic dL)
    (dl_assignd formula-decl nil dynamic_logic dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (ASSIGN adt-constructor-decl "[Assigns -> (assign?)]" HP_adt dL)
    (assign? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (Assigns type-eq-decl nil hp_def dL)
    (STAR adt-constructor-decl "[HP -> (star?)]" HP_adt dL)
    (star? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (SOMERUNS const-decl "bool" bool_expr dL)
    (HP type-decl nil HP_adt dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL))
   shostak))
 (dl_K_example 0
  (dl_K_example-1 nil 3882037583
   ("" (dl-K) (("" (dl-assert) nil nil)) nil)
   ((null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (dl_assignb formula-decl nil dynamic_logic dL)
    (dl_sub_implies formula-decl nil substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (dl_sub_ge formula-decl nil substitution dL)
    (dl_subre_const formula-decl nil substitution dL)
    (dl_subre_val formula-decl nil substitution dL)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (FALSE const-decl "bool" booleans nil)
    (length def-decl "nat" list_props nil)
    (iterate_left const-decl "T" for_iterate structures)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (<= const-decl "bool" reals nil) (nth def-decl "T" list_props nil)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (same_var const-decl "bool" hp_def dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (DLIMPLIES const-decl "bool" bool_expr dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (ASSIGN adt-constructor-decl "[Assigns -> (assign?)]" HP_adt dL)
    (assign? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (Assigns type-eq-decl nil hp_def dL) (HP type-decl nil HP_adt dL)
    (dl_distimpliesb formula-decl nil dynamic_logic dL)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL))
   shostak))
 (dl_loop_example 0
  (dl_loop_example-1 nil 3882037490
   ("" (dl-flatten)
    (("" (dl-loop "val(x)>=cnst(1) and val(y) >=cnst(1)")
      (("1" (dl-assert) nil nil) ("2" (dl-assert) nil nil)
       ("3" (dl-assignb) (("3" (dl-assert) nil nil)) nil))
      nil))
    nil)
   ((dl_loop formula-decl nil dynamic_logic dL)
    (dl_andR formula-decl nil dynamic_logic dL)
    (dl_axiom formula-decl nil dynamic_logic dL)
    (\|- const-decl "bool" dynamic_logic dL)
    (iterate_left const-decl "T" for_iterate structures)
    (nth def-decl "T" list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (<= const-decl "bool" reals nil)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (length def-decl "nat" list_props nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (FALSE const-decl "bool" booleans nil)
    (same_var const-decl "bool" hp_def dL)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (dl_sub_and formula-decl nil substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (dl_sub_ge formula-decl nil substitution dL)
    (dl_subre_const formula-decl nil substitution dL)
    (dl_subre_val formula-decl nil substitution dL)
    (dl_assignb formula-decl nil dynamic_logic dL)
    (dl_andL formula-decl nil dynamic_logic dL)
    (val const-decl "real" hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (ASSIGN adt-constructor-decl "[Assigns -> (assign?)]" HP_adt dL)
    (assign? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (Assigns type-eq-decl nil hp_def dL)
    (STAR adt-constructor-decl "[HP -> (star?)]" HP_adt dL)
    (star? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (HP type-decl nil HP_adt dL) (cnst const-decl "real" hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (DLAND const-decl "bool" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL))
   shostak))
 (dl_Mb_example 0
  (dl_Mb_example-1 nil 3882037475
   ("" (dl-Mb) (("" (dl-assert) nil nil)) nil)
   ((length def-decl "nat" list_props nil)
    (iterate_left const-decl "T" for_iterate structures)
    (/= const-decl "boolean" notequal nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (nth def-decl "T" list_props nil)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (DLIMPLIES const-decl "bool" bool_expr dL)
    (HP type-decl nil HP_adt dL) (ODEs type-eq-decl nil hp_def dL)
    (diff? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (DIFF adt-constructor-decl "[[ODEs, BoolExpr] -> (diff?)]" HP_adt
     dL)
    (DLBOOL const-decl "bool" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (/= const-decl "BoolExpr" bool_expr dL)
    (cnst const-decl "real" hp_def dL)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (dl_impliesallrunsb formula-decl nil dynamic_logic dL)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (val const-decl "real" hp_def dL))
   shostak))
 (dl_monob_example 0
  (dl_monob_example-1 nil 3882037373
   ("" (skeep)
    (("" (dl-flatten)
      (("" (dl-monob "val(x) = cnst(0) AND val(y) = cnst(c)")
        (("1" (dl-assert) nil nil) ("2" (dl-assert) nil nil)) nil))
      nil))
    nil)
   ((Formulas type-eq-decl nil bool_expr dL)
    (DLAND const-decl "bool" bool_expr dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (cnst const-decl "real" hp_def dL) (HP type-decl nil HP_adt dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (Assigns type-eq-decl nil hp_def dL)
    (assign? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ASSIGN adt-constructor-decl "[Assigns -> (assign?)]" HP_adt dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (val const-decl "real" hp_def dL)
    (dl_andL formula-decl nil dynamic_logic dL)
    (for const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (^ const-decl "real" exponentiation nil)
    (expt def-decl "real" exponentiation nil)
    (nth def-decl "T" list_props nil)
    (iterate_left const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (dl_assignb formula-decl nil dynamic_logic dL)
    (dl_sub_and formula-decl nil substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (dl_sub_eq formula-decl nil substitution dL)
    (dl_subre_const formula-decl nil substitution dL)
    (dl_subre_val formula-decl nil substitution dL)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (FALSE const-decl "bool" booleans nil)
    (dl_moveL formula-decl nil dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (length def-decl "nat" list_props nil)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (append def-decl "list[T]" list_props nil)
    (dl_axiom formula-decl nil dynamic_logic dL)
    (dl_andR formula-decl nil dynamic_logic dL)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (same_var const-decl "bool" hp_def dL)
    (dl_MbR formula-decl nil dynamic_logic dL))
   shostak))
 (dl_move_example 0
  (dl_move_example-1 nil 3873840108
   ("" (dl-flatten)
    (("" (dl-move -2) (("" (dl-move 2) (("" (dl-assert) nil nil)) nil))
      nil))
    nil)
   ((dl_moveL formula-decl nil dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (length def-decl "nat" list_props nil)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (append def-decl "list[T]" list_props nil)
    (\|- const-decl "bool" dynamic_logic dL)
    (iterate_left const-decl "T" for_iterate structures)
    (nth def-decl "T" list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (<= const-decl "bool" reals nil)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (dl_moveR formula-decl nil dynamic_logic dL)
    (dl_andL formula-decl nil dynamic_logic dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (dl_orR formula-decl nil dynamic_logic dL)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (DLOR const-decl "bool" bool_expr dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (DLAND const-decl "bool" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL))
   shostak))
 (dl_notL_example 0
  (dl_notL_example-1 nil 3877105333
   ("" (flatten) (("" (dl-notL) nil nil)) nil)
   ((> const-decl "BoolExpr" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (dl_notL formula-decl nil dynamic_logic dL)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL)
    (< const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (dl_notR_example 0
  (dl_notR_example-1 nil 3877432902
   ("" (flatten) (("" (dl-notR) nil nil)) nil)
   ((dl_notR formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (> const-decl "BoolExpr" bool_expr dL)
    (< const-decl "BoolExpr" bool_expr dL)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (dl_orL_example 0
  (dl_orL_example-1 nil 3877433988
   ("" (flatten) (("" (dl-orL) nil nil)) nil)
   ((Formulas type-eq-decl nil bool_expr dL)
    (dl_orL formula-decl nil dynamic_logic dL)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (<= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (dl_orR_example 0
  (dl_orR_example-1 nil 3877433188
   ("" (flatten) (("" (dl-orR) nil nil)) nil)
   ((dl_orR formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (> const-decl "BoolExpr" bool_expr dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL)
    (< const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (dl_pp_example 0
  (dl_pp_example-1 nil 3873840274
   ("" (dl-pp) (("" (dl-assert) nil nil)) nil)
   ((\|- const-decl "bool" dynamic_logic dL)
    (iterate_left const-decl "T" for_iterate structures)
    (nth def-decl "T" list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (<= const-decl "bool" reals nil)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (length def-decl "nat" list_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (RealExpr type-eq-decl nil hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil))
   shostak))
 (dl_skolem_example 0
  (dl_skolem_example-1 nil 3877439517
   ("" (dl-skolem) (("" (dl-assert) nil nil)) nil)
   ((dl_axiom formula-decl nil dynamic_logic dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (Formulas type-eq-decl nil bool_expr dL)
    (QBoolExpr type-eq-decl nil hp_def dL)
    (DLIMPLIES const-decl "bool" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (> const-decl "BoolExpr" bool_expr dL)
    (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (dl_forallR formula-decl nil dynamic_logic dL)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (dl_solve_example1 0
  (dl_solve_example1-1 nil 3882037333
   ("" (dl-flatten) (("" (dl-solve) (("" (dl-assert) nil nil)) nil))
    nil)
   ((solution_domain_ax_cnst_imp_zip formula-decl nil dl_solution dL)
    (cnst_lins? const-decl "bool" dl_solution dL)
    (MapExprInj type-eq-decl nil hp_def dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nth def-decl "T" list_props nil)
    (ASSIGN adt-constructor-decl "[Assigns -> (assign?)]" HP_adt dL)
    (Assigns type-eq-decl nil hp_def dL)
    (UPTO const-decl "BoolExpr" bool_expr dL)
    (QHP type-eq-decl nil bool_expr dL)
    (DLFORALL const-decl "bool" bool_expr dL)
    (QBoolExpr type-eq-decl nil hp_def dL)
    (\|- const-decl "bool" dynamic_logic dL)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (assign? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (zs const-decl "MapExprInj" dl_solution dL)
    (Y_sol_ex const-decl "[Environment -> real]" dl_solution dL)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (init_zip_sol def-decl "{a: MapExprInj |
   length(a) = length(ode) AND
    FORALL (i: below(length(a))): nth(a, i) = (nth(ode, i)`1, y(i)(t))}"
     dl_solution dL)
    (below type-eq-decl nil nat_types nil)
    (get_val_cnst_id_ex const-decl "{vc: [below(length(l)), real] |
   vc`1 /= i AND
    nth(l, i)`2 = cnst(vc`2) + val(nth(l, vc`1)`1) AND
     (FORALL (c: real, m: below(length(l))):
        nth(l, i)`2 = cnst(c) + val(nth(l, m)`1) IMPLIES
         (m = vc`1 AND vc`2 = c))}" dl_solution dL)
    (is_val_not_in_map? const-decl "bool" dl_solution dL)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (is_cnst? const-decl "bool" dl_solution dL)
    (in_map_ex def-decl "bool" dl_solution dL)
    (env_c const-decl "real" dl_solution dL)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (env_nat_shift const-decl "real" dl_solution dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (DLAND const-decl "bool" bool_expr dL)
    (DLIMPLIES const-decl "bool" bool_expr dL)
    (dl_forallR formula-decl nil dynamic_logic dL)
    (dl_andL formula-decl nil dynamic_logic dL)
    (dl_assignb formula-decl nil dynamic_logic dL)
    (dl_assignb_restricted formula-decl nil dynamic_logic dL)
    (dl_sub_bool_restricted formula-decl nil substitution dL)
    (FALSE const-decl "bool" booleans nil)
    (same_var const-decl "bool" hp_def dL)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (dl_sub_le formula-decl nil substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (dl_subre_val formula-decl nil substitution dL)
    (for const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (real_times_real_is_real application-judgement "real" reals nil)
    (<= const-decl "bool" reals nil)
    (iterate_left const-decl "T" for_iterate structures)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (append def-decl "list[T]" list_props nil)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (length_singleton formula-decl nil more_list_props structures)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (dl_moveL formula-decl nil dynamic_logic dL)
    (dl_hideL formula-decl nil dynamic_logic dL)
    (cnst const-decl "real" hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (DLBOOL const-decl "bool" bool_expr dL)
    (DIFF adt-constructor-decl "[[ODEs, BoolExpr] -> (diff?)]" HP_adt
     dL)
    (diff? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ODEs type-eq-decl nil hp_def dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (HP type-decl nil HP_adt dL) (val const-decl "real" hp_def dL)
    (<= const-decl "BoolExpr" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL))
   shostak))
 (dl_solve_example2 0
  (dl_solve_example2-1 nil 3882037272
   ("" (dl-solve)
    (("" (dl-inst "t")
      (("" (dl-flatten)
        (("" (dl-ground) (("" (dl-assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((dl_forallL formula-decl nil dynamic_logic dL)
    (dl_moveL formula-decl nil dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (append def-decl "list[T]" list_props nil)
    (dl_impliesL formula-decl nil dynamic_logic dL)
    (dl_axiom formula-decl nil dynamic_logic dL)
    (dl_andR formula-decl nil dynamic_logic dL)
    (for const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (iterate_left const-decl "T" for_iterate structures)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (same_var const-decl "bool" hp_def dL)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (dl_subre_val formula-decl nil substitution dL)
    (dl_sub_eq formula-decl nil substitution dL)
    (PRED type-eq-decl nil defined_types nil)
    (Substitution type-eq-decl nil substitution dL)
    (SUB const-decl "bool" substitution dL)
    (dl_assignb_restricted formula-decl nil dynamic_logic dL)
    (dl_assignb formula-decl nil dynamic_logic dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (dl_andL formula-decl nil dynamic_logic dL)
    (/= const-decl "boolean" notequal nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (dl_forallR formula-decl nil dynamic_logic dL)
    (DLIMPLIES const-decl "bool" bool_expr dL)
    (DLAND const-decl "bool" bool_expr dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (FALSE const-decl "bool" booleans nil)
    (env_c_val formula-decl nil dl_solution dL)
    (env_nat_shift const-decl "real" dl_solution dL)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (env_c const-decl "real" dl_solution dL)
    (in_map_ex def-decl "bool" dl_solution dL)
    (is_cnst? const-decl "bool" dl_solution dL)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (is_val_not_in_map? const-decl "bool" dl_solution dL)
    (get_val_cnst_id_ex const-decl "{vc: [below(length(l)), real] |
   vc`1 /= i AND
    nth(l, i)`2 = cnst(vc`2) + val(nth(l, vc`1)`1) AND
     (FORALL (c: real, m: below(length(l))):
        nth(l, i)`2 = cnst(c) + val(nth(l, m)`1) IMPLIES
         (m = vc`1 AND vc`2 = c))}" dl_solution dL)
    (init_zip_sol def-decl "{a: MapExprInj |
   length(a) = length(ode) AND
    FORALL (i: below(length(a))): nth(a, i) = (nth(ode, i)`1, y(i)(t))}"
     dl_solution dL)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (Y_sol_ex const-decl "[Environment -> real]" dl_solution dL)
    (zs const-decl "MapExprInj" dl_solution dL)
    (ODEs type-eq-decl nil hp_def dL)
    (ASSIGN adt-constructor-decl "[Assigns -> (assign?)]" HP_adt dL)
    (Assigns type-eq-decl nil hp_def dL)
    (DIFF adt-constructor-decl "[[ODEs, BoolExpr] -> (diff?)]" HP_adt
     dL)
    (diff? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (UPTO const-decl "BoolExpr" bool_expr dL)
    (QHP type-eq-decl nil bool_expr dL)
    (DLFORALL const-decl "bool" bool_expr dL)
    (QBoolExpr type-eq-decl nil hp_def dL)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (\|- const-decl "bool" dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (assign? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (HP type-decl nil HP_adt dL)
    (cnst_val_com formula-decl nil dl_solution dL)
    (get_index def-decl
     "{n: below(length(l)) | dlvar_index(nth(l, n)`1) = j}" dl_solution
     dL)
    (below type-eq-decl nil nat_types nil)
    (in_map const-decl "bool" hp_def dL)
    (quad_cnst? const-decl "bool" dl_solution dL)
    (cnst_val_0 formula-decl nil dl_solution dL)
    (nth def-decl "T" list_props nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cnst_lins? const-decl "bool" dl_solution dL)
    (MapExprInj type-eq-decl nil hp_def dL)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (solution_domain_ax_cnst_imp_zip_no_hyp formula-decl nil
     dl_solution dL)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (dl_subs_example 0
  (dl_subs_example-1 nil 3873840950
   ("" (dl-flatten) (("" (dl-subs) (("" (dl-assert) nil nil)) nil))
    nil)
   ((dl_subre_val formula-decl nil substitution dL)
    (dl_subre_exp formula-decl nil substitution dL)
    (dl_subre_plus formula-decl nil substitution dL)
    (dl_subre_const formula-decl nil substitution dL)
    (dl_sub_eq formula-decl nil substitution dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (same_var const-decl "bool" hp_def dL)
    (FALSE const-decl "bool" booleans nil)
    (length def-decl "nat" list_props nil)
    (iterate_left const-decl "T" for_iterate structures)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posnat_expt application-judgement "posnat" exponentiation nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (^ const-decl "real" exponentiation nil)
    (expt def-decl "real" exponentiation nil)
    (nth def-decl "T" list_props nil)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (Substitution type-eq-decl nil substitution dL)
    (SUB const-decl "bool" substitution dL)
    (^ const-decl "[T -> real]" real_fun_ops reals))
   shostak))
 (dl_testb_example 0
  (dl_testb_example-1 nil 3877436527
   ("" (dl-flatten) (("" (dl-testb) (("" (dl-assert) nil nil)) nil))
    nil)
   ((append def-decl "list[T]" list_props nil)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (length def-decl "nat" list_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (dl_moveL formula-decl nil dynamic_logic dL)
    (dl_testb formula-decl nil dynamic_logic dL)
    (dl_axiom formula-decl nil dynamic_logic dL)
    (dl_impliesL formula-decl nil dynamic_logic dL)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (DLIMPLIES const-decl "bool" bool_expr dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (> const-decl "BoolExpr" bool_expr dL)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (TEST adt-constructor-decl "[BoolExpr -> (test?)]" HP_adt dL)
    (test? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (HP type-decl nil HP_adt dL)
    (Formulas type-eq-decl nil bool_expr dL))
   shostak))
 (dl_testd_example 0
  (dl_testd_example-1 nil 3877437670
   ("" (dl-flatten) (("" (dl-testd) (("" (dl-assert) nil nil)) nil))
    nil)
   ((dl_axiom formula-decl nil dynamic_logic dL)
    (dl_testd formula-decl nil dynamic_logic dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (DLAND const-decl "bool" bool_expr dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (> const-decl "BoolExpr" bool_expr dL)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (TEST adt-constructor-decl "[BoolExpr -> (test?)]" HP_adt dL)
    (test? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (SOMERUNS const-decl "bool" bool_expr dL)
    (HP type-decl nil HP_adt dL)
    (Formulas type-eq-decl nil bool_expr dL))
   shostak))
 (dl_trueR_example 0
  (dl_trueR_example-1 nil 3877101367 ("" (then (dl-trueR)) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (RealExpr type-eq-decl nil hp_def dL)
    (> const-decl "BoolExpr" bool_expr dL)
    (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (Formulas type-eq-decl nil bool_expr dL)
    (<= const-decl "BoolExpr" bool_expr dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (dl_trueR formula-decl nil dynamic_logic dL))
   shostak))
 (dl_Vb_example 0
  (dl_Vb_example-1 nil 3882037166
   ("" (dl-flatten) (("" (dl-Vb) (("" (dl-assert) nil nil)) nil)) nil)
   ((dl_V formula-decl nil dynamic_logic dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (BV def-decl "list[nat]" bound_variables_def dL)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (fresh_be_eq formula-decl nil fresh_props dL)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (fresh_re_pow formula-decl nil fresh_props dL)
    (/= const-decl "boolean" notequal nil)
    (fresh_re_val formula-decl nil fresh_props dL)
    (fresh_re_cnst formula-decl nil fresh_props dL)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (iterate_left const-decl "T" for_iterate structures)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (^ const-decl "real" exponentiation nil)
    (expt def-decl "real" exponentiation nil)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (val const-decl "real" hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (DLBOOL const-decl "bool" bool_expr dL)
    (DIFF adt-constructor-decl "[[ODEs, BoolExpr] -> (diff?)]" HP_adt
     dL)
    (diff? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ODEs type-eq-decl nil hp_def dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (HP type-decl nil HP_adt dL) (cnst const-decl "real" hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL))
   shostak))
 (dl_weak_example 0
  (dl_weak_example-1 nil 3882037184
   ("" (dl-flatten)
    (("" (dl-weak "val(y)=cnst(25)")
      (("1" (dl-assert) nil nil) ("2" (dl-assert) nil nil)) nil))
    nil)
   ((dl_weakR formula-decl nil dynamic_logic dL)
    (length def-decl "nat" list_props nil)
    (for const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (nth def-decl "T" list_props nil)
    (iterate_left const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (dl_andL formula-decl nil dynamic_logic dL)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (DLAND const-decl "bool" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL))
   shostak)))

