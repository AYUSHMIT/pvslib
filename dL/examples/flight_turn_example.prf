(flight_turn_example
 (turn_TCC1 0
  (turn_TCC1-1 nil 3878842223 ("" (eval-formula 1) nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (turn subtype
    "(: (flight_turn_example.x, (real_fun_ops[Environment].-)(hp_def.val(flight_turn_example.y))), (flight_turn_example.y, hp_def.val(flight_turn_example.x)) :)"
    "ODEs")))
 (straight_TCC1 0
  (straight_TCC1-1 nil 3878842223
   ("" (then (skeep) (eval-formula 1)) nil)
   ((TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (straight subtype
    "(: (flight_turn_example.x, hp_def.cnst(flight_turn_example.vx)), (flight_turn_example.y, hp_def.cnst(flight_turn_example.vy)) :)"
    "ODEs")))
 (path_equiv 0
  (path_equiv-1 nil 3879586982
   (""
    (then (beta) (skeep) (expand "path?") (decompose-equality) (grind))
    nil)
   ((Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (DLOR const-decl "bool" bool_expr dL)
    (DLAND const-decl "bool" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (> const-decl "BoolExpr" bool_expr dL)
    (dLVar type-decl nil hp_def dL) (val const-decl "real" hp_def dL)
    (x const-decl "dLVar" flight_turn_example nil)
    (cnst const-decl "real" hp_def dL)
    (circ? const-decl "BoolExpr" flight_turn_example nil)
    (<= const-decl "BoolExpr" bool_expr dL)
    (line? const-decl "BoolExpr" flight_turn_example nil)
    (DLIMPLIES const-decl "bool" bool_expr dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (y const-decl "dLVar" flight_turn_example nil)
    (expt def-decl "real" exponentiation nil)
    (^ const-decl "real" exponentiation nil)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (+ const-decl "[T -> real]" real_fun_ops reals)
    (= const-decl "BoolExpr" bool_expr dL)
    (* const-decl "[T -> real]" real_fun_ops reals)
    (path? const-decl "BoolExpr" flight_turn_example nil))
   shostak))
 (rotational_dynamics_line 0
  (rotational_dynamics_line-1 nil 3879585678
   (""
    (then (skeep) (beta) (dl-flatten)
     (spread (dl-loop "path?(C) AND cnst(C)>=0 AND val(y)>=0")
      ((then (expand "path?") (expand "line?") (expand "circ?")
        (dl-assert))
       (dl-assert)
       (then (expand "path?" 1) (expand "circ?") (expand "line?")
        (dl-flatten)
        (spread (dl-ground)
         ((then (dl-assert) (expand "turn")
           (spread (dl-ground)
            ((spread (dl-diffcase "cnst(C) >= cnst(0)")
              ((then (dl-diffinv) (dl-assert))
               (spread
                (dl-diffcase "DLAND(val(x) >= cnst(0), circ?(C))")
                ((then (expand "circ?")
                  (spread (dl-diffcase "circ?(C)")
                   ((then (expand "circ?") (dl-diffinv) (dl-assert))
                    (then (dl-diffweak) (expand "circ?")
                     (dl-assert)))))
                 (spread (dl-diffcase "val(y) >= cnst(0)")
                  ((then (dl-diffinv) (dl-assert))
                   (then (dl-diffweak)
                    (spread (dl-ground)
                     ((dl-assert) (then (expand "circ?") (dl-assert))
                      (then (expand "circ?") (dl-assert))
                      (then (expand "circ?" 1) (dl-assert)))))))))))
             (then (expand "straight" 1)
              (spread
               (dl-diffcase "DLAND(val(x) <= cnst(0), line?(0, 1, C))")
               ((then (expand "line?")
                 (spread (dl-diffcase "cnst(C) >= cnst(0)")
                  ((then (dl-diffinv) (dl-assert))
                   (then (dl-diffinv) (dl-assert)))))
                (spread (dl-diffcase "cnst(C) >= cnst(0)")
                 ((dl-diffinv)
                  (then (dl-diffweak)
                   (spread (dl-ground)
                    ((then (expand "line?" 1) (dl-assert))
                     (then (expand "line?" 1) (dl-assert))
                     (then (expand "line?" 1) (dl-assert)))))))))))))
          (then (dl-ground) (expand "turn") (expand "straight")
           (dl-ground) (dl-assert)
           (spread (dl-ground)
            ((then (dl-assert) (dl-hide +) (dl-assert))
             (spread (dl-diffcase "cnst(C)>=cnst(0)")
              ((then (dl-diffinv) (dl-assert))
               (spread (dl-diffcase "val(y)>=cnst(0)")
                ((then (dl-diffinv) (dl-assert))
                 (spread
                  (dl-diffcase
                   "DLAND(val(x) <= cnst(0), (cnst(0) * val(x) + cnst(1) * val(y) = cnst(C)))")
                  ((then (dl-diffinv) (dl-assert))
                   (then (dl-diffweak) (dl-flatten)
                    (dl-assert)))))))))))))))))
    nil)
   ((dl_loop formula-decl nil dynamic_logic dL)
    (gamma__1302 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1303 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (line? const-decl "BoolExpr" flight_turn_example nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (expt def-decl "real" exponentiation nil)
    (^ const-decl "real" exponentiation nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (<= const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nth def-decl "T" list_props nil)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (delta__1305 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1304 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (DLOR const-decl "bool" bool_expr dL)
    (+ const-decl "[T -> real]" real_fun_ops reals)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (* const-decl "[T -> real]" real_fun_ops reals)
    (dl_andR formula-decl nil dynamic_logic dL)
    (delta__1315 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1314 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (dl_axiom formula-decl nil dynamic_logic dL)
    (dl_orR formula-decl nil dynamic_logic dL)
    (gamma__1306 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1307 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (delta__1309 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1308 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1313 skolem-const-decl "(cons?)" flight_turn_example nil)
    (gamma__1312 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (dl_moveR formula-decl nil dynamic_logic dL)
    (delta__1311 skolem-const-decl "(cons?)" flight_turn_example nil)
    (gamma__1310 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (circ? const-decl "BoolExpr" flight_turn_example nil)
    (gamma__1318 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1319 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1317 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1316 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1321 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1320 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1323 skolem-const-decl "(cons?)" flight_turn_example nil)
    (gamma__1322 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1450 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1451 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1455 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1456 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (nnqb__1452 skolem-const-decl
     "{nnqbe: NormNQBool | nqb_to_be(nnqbe) = nqb_to_be(NQB_rel(nqb_ge, cnst(C), cnst(0)))}"
     flight_turn_example nil)
    (delta__1454 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1453 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1462 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1463 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (delta__1474 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1473 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1471 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1472 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1467 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1468 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1470 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1469 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (nnqb__1464 skolem-const-decl
     "{nnqbe: NormNQBool | nqb_to_be(nnqbe) = nqb_to_be(NQB_AND(NQB_rel(nqb_le, val(x), cnst(0)), NQB_rel(nqb_eq, cnst(0) * val(x) + cnst(1) * val(y), cnst(C))))}"
     flight_turn_example nil)
    (delta__1466 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1465 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1478 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1477 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1480 skolem-const-decl "(cons?)" flight_turn_example nil)
    (gamma__1479 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1482 skolem-const-decl "(cons?)" flight_turn_example nil)
    (gamma__1481 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1484 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1483 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1486 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1485 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1487 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1488 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1491 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1492 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1494 skolem-const-decl "(cons?)" flight_turn_example nil)
    (gamma__1493 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1496 skolem-const-decl "(cons?)" flight_turn_example nil)
    (gamma__1495 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1489 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1490 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (delta__1498 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1497 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1460 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1461 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (nnqb__1459 skolem-const-decl
     "{nnqbe: NormNQBool | nqb_to_be(nnqbe) = nqb_to_be(NQB_rel(nqb_ge, val(y), cnst(0)))}"
     flight_turn_example nil)
    (delta__1458 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1457 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1449 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1448 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (dl_hideR formula-decl nil dynamic_logic dL)
    (delta__1443 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1442 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1446 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1447 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1444 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1445 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (dl_choiceb formula-decl nil dynamic_logic dL)
    (dl_composeb formula-decl nil dynamic_logic dL)
    (dl_testb formula-decl nil dynamic_logic dL)
    (DLIMPLIES const-decl "bool" bool_expr dL)
    (delta__1333 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1332 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1335 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1334 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (- const-decl "[T -> real]" real_fun_ops reals)
    (DIFF adt-constructor-decl "[[ODEs, BoolExpr] -> (diff?)]" HP_adt
     dL)
    (diff? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ODEs type-eq-decl nil hp_def dL)
    (gamma__1330 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1331 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1341 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1342 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1343 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1344 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (nqb_eq? adt-recognizer-decl "[NQB_REL -> boolean]" hp_def dL)
    (nqb_eq adt-constructor-decl "(nqb_eq?)" hp_def dL)
    (gamma__1346 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1347 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (nnqb__1345 skolem-const-decl
     "{nnqbe: NormNQBool | nqb_to_be(nnqbe) = nqb_to_be(NQB_rel(nqb_eq, val(x) ^ 2 + val(y) ^ 2, cnst(C) ^ 2))}"
     flight_turn_example nil)
    (diff_re_sum formula-decl nil diff_re_props dL)
    (diff_re? const-decl "bool" chain_rule_re dL)
    (diff_re_pow formula-decl nil diff_re_props dL)
    (diff_re_val formula-decl nil diff_re_props dL)
    (delta__1349 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1348 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (dl_dift_plus formula-decl nil differentiation dL)
    (dl_derivable_up_pow formula-decl nil differentiation dL)
    (ddl_dom_upto? const-decl "bool" differentiation dL)
    (derivable_up? const-decl "bool" differentiation dL)
    (dl_derivable_up_val formula-decl nil differentiation dL)
    (dl_dift_pow formula-decl nil differentiation dL)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (dl_dift_val formula-decl nil differentiation dL)
    (dlvar_index adt-accessor-decl "[dLVar -> nat]" hp_def dL)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (max_var_max formula-decl nil hp_def dL)
    (below type-eq-decl nil nat_types nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (dl_derivable_up_cnst formula-decl nil differentiation dL)
    (* const-decl "[T -> real]" real_fun_ops reals)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (gamma__1354 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1355 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1352 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1353 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (delta__1357 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1356 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (dl_dW formula-decl nil dynamic_logic dL)
    (delta__1394 skolem-const-decl "(cons?)" flight_turn_example nil)
    (gamma__1393 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1379 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1380 skolem-const-decl "(cons?)" flight_turn_example nil)
    (gamma__1377 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1378 skolem-const-decl "(cons?)" flight_turn_example nil)
    (gamma__1375 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1376 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1373 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1374 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (delta__1382 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1381 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1392 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1391 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1383 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1384 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (delta__1386 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1385 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1390 skolem-const-decl "(cons?)" flight_turn_example nil)
    (gamma__1389 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1388 skolem-const-decl "(cons?)" flight_turn_example nil)
    (gamma__1387 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (max_var_rec def-decl "nat" hp_def dL)
    (gamma__1361 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1362 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (nnqb__1360 skolem-const-decl
     "{nnqbe: NormNQBool | nqb_to_be(nnqbe) = nqb_to_be(NQB_rel(nqb_ge, val(y), cnst(0)))}"
     flight_turn_example nil)
    (delta__1364 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1363 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1366 skolem-const-decl "(cons?)" flight_turn_example nil)
    (gamma__1365 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1368 skolem-const-decl "(cons?)" flight_turn_example nil)
    (gamma__1367 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1369 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (dl_hideL formula-decl nil dynamic_logic dL)
    (delta__1370 skolem-const-decl "(cons?)" flight_turn_example nil)
    (int_max application-judgement "{k: int | i <= k AND j <= k}"
     real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (delta__1359 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1358 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (NQBool type-decl nil NQBool_adt dL)
    (nqb_normal? inductive-decl "bool" bool_expr dL)
    (NormNQBool type-eq-decl nil bool_expr dL)
    (nqb_to_be def-decl "BoolExpr" bool_expr dL)
    (normalize const-decl
     "{nnqbe: NormNQBool | nqb_to_be(nnqbe) = nqb_to_be(nqbe)}"
     bool_expr dL)
    (NQB_REL type-decl nil hp_def dL)
    (nqb_rel? adt-recognizer-decl "[NQBool -> boolean]" NQBool_adt dL)
    (NQB_rel adt-constructor-decl
     "[[NQB_REL, RealExpr, RealExpr] -> (nqb_rel?)]" NQBool_adt dL)
    (nqb_ge? adt-recognizer-decl "[NQB_REL -> boolean]" hp_def dL)
    (nqb_ge adt-constructor-decl "(nqb_ge?)" hp_def dL)
    (nqb_rel const-decl "BoolExpr" bool_expr dL)
    (dl_dI_dlTRUE formula-decl nil dynamic_logic dL)
    (ddl_dom? const-decl "bool" differentiation dL)
    (DLBOOL const-decl "bool" bool_expr dL)
    (gamma__1339 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1340 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (nnqb__1338 skolem-const-decl
     "{nnqbe: NormNQBool | nqb_to_be(nnqbe) = nqb_to_be(NQB_rel(nqb_ge, cnst(C), cnst(0)))}"
     flight_turn_example nil)
    (normalize_rec def-decl
     "{nnqbe: NormNQBool | FORALL (env: Environment): nqb_to_be(nnqbe)(env) = (pos IFF nqb_to_be(nqbe)(env))}"
     bool_expr dL)
    (length_singleton formula-decl nil more_list_props structures)
    (derivable_M_nqbool? inductive-decl "bool" chain_rule_re dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (diff_re_cnst formula-decl nil diff_re_props dL)
    (max_var const-decl "nat" hp_def dL)
    (dl_true_DDL formula-decl nil differentiation dL)
    (SUB_DIFT const-decl "BoolExpr" differentiation dL)
    (DIFT def-decl "BoolExpr" differentiation dL)
    (dl_dift_const formula-decl nil differentiation dL)
    (ddt def-decl "RealExpr" differentiation dL)
    (delta__1337 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1336 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (dl_dC formula-decl nil dynamic_logic dL)
    (gamma__1395 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1396 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1397 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1398 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1402 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (dl_trueL formula-decl nil dynamic_logic dL)
    (delta__1403 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (nnqb__1399 skolem-const-decl
     "{nnqbe: NormNQBool | nqb_to_be(nnqbe) = nqb_to_be(NQB_rel(nqb_ge, cnst(C), cnst(0)))}"
     flight_turn_example nil)
    (delta__1401 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1400 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1410 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1409 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (dl_dift_mult formula-decl nil differentiation dL)
    (dl_derivable_up_prod formula-decl nil differentiation dL)
    (C skolem-const-decl "real" flight_turn_example nil)
    (dl_true_and formula-decl nil bool_expr dL)
    (delta__1408 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1407 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (diff_re_prod formula-decl nil diff_re_props dL)
    (nnqb__1404 skolem-const-decl
     "{nnqbe: NormNQBool | nqb_to_be(nnqbe) = nqb_to_be(NQB_AND(NQB_rel(nqb_le, val(x), cnst(0)), NQB_rel(nqb_eq, cnst(0) * val(x) + cnst(1) * val(y), cnst(C))))}"
     flight_turn_example nil)
    (delta__1406 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1405 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (nqb_le adt-constructor-decl "(nqb_le?)" hp_def dL)
    (nqb_le? adt-recognizer-decl "[NQB_REL -> boolean]" hp_def dL)
    (NQB_AND adt-constructor-decl "[[NQBool, NQBool] -> (nqb_and?)]"
     NQBool_adt dL)
    (nqb_and? adt-recognizer-decl "[NQBool -> boolean]" NQBool_adt dL)
    (gamma__1428 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1429 skolem-const-decl "(cons?)" flight_turn_example nil)
    (gamma__1426 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1427 skolem-const-decl "(cons?)" flight_turn_example nil)
    (gamma__1424 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1425 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1422 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1423 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (delta__1431 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1430 skolem-const-decl "(cons?)" flight_turn_example nil)
    (delta__1441 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1440 skolem-const-decl "(cons?)" flight_turn_example nil)
    (gamma__1432 skolem-const-decl "(cons?)" flight_turn_example nil)
    (delta__1433 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (delta__1435 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1434 skolem-const-decl "(cons?)" flight_turn_example nil)
    (delta__1439 skolem-const-decl "(cons?)" flight_turn_example nil)
    (gamma__1438 skolem-const-decl "(cons?)" flight_turn_example nil)
    (delta__1437 skolem-const-decl "(cons?)" flight_turn_example nil)
    (gamma__1436 skolem-const-decl "(cons?)" flight_turn_example nil)
    (nnqb__1413 skolem-const-decl
     "{nnqbe: NormNQBool | nqb_to_be(nnqbe) = nqb_to_be(NQB_rel(nqb_ge, cnst(C), cnst(0)))}"
     flight_turn_example nil)
    (delta__1419 skolem-const-decl "(cons?)" flight_turn_example nil)
    (gamma__1418 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1416 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1417 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1414 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1415 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (delta__1412 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1411 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1325 skolem-const-decl "(cons?)" flight_turn_example nil)
    (dl_orL formula-decl nil dynamic_logic dL)
    (gamma__1324 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (gamma__1328 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1329 skolem-const-decl "(cons?)" flight_turn_example nil)
    (gamma__1326 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1327 skolem-const-decl "(cons?)" flight_turn_example nil)
    (append def-decl "list[T]" list_props nil)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (length def-decl "nat" list_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (dl_moveL formula-decl nil dynamic_logic dL)
    (gamma__1300 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (delta__1301 skolem-const-decl "(cons?)" flight_turn_example nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (gamma__1298 skolem-const-decl "(cons?[BoolExpr])"
     flight_turn_example nil)
    (dl_andL formula-decl nil dynamic_logic dL)
    (delta__1299 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (delta__1297 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (minus_real_is_real application-judgement "real" reals nil)
    (Formulas type-eq-decl nil bool_expr dL)
    (DLAND const-decl "bool" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (cnst const-decl "real" hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (dLVar type-decl nil hp_def dL) (val const-decl "real" hp_def dL)
    (x const-decl "dLVar" flight_turn_example nil)
    (y const-decl "dLVar" flight_turn_example nil)
    (HP type-decl nil HP_adt dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (star? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (STAR adt-constructor-decl "[HP -> (star?)]" HP_adt dL)
    (union? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (UNION adt-constructor-decl "[[HP, HP] -> (union?)]" HP_adt dL)
    (seq? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (SEQ adt-constructor-decl "[[HP, HP] -> (seq?)]" HP_adt dL)
    (test? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (TEST adt-constructor-decl "[BoolExpr -> (test?)]" HP_adt dL)
    (> const-decl "BoolExpr" bool_expr dL)
    (turn const-decl "HP" flight_turn_example nil)
    (<= const-decl "BoolExpr" bool_expr dL)
    (straight const-decl "HP" flight_turn_example nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (path? const-decl "BoolExpr" flight_turn_example nil)
    (gamma__1296 skolem-const-decl "(null?[BoolExpr])"
     flight_turn_example nil))
   shostak))
 (turn_tr_odes_TCC1 0
  (turn_tr_odes_TCC1-1 nil 3882108298
   ("" (then (skeep) (eval-expr 1) (assert)) nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (cos_re const-decl "real" flight_turn_example nil)
    (y const-decl "dLVar" flight_turn_example nil)
    (theta const-decl "dLVar" flight_turn_example nil)
    (val const-decl "real" hp_def dL)
    (sin_re const-decl "real" flight_turn_example nil)
    (cnst const-decl "real" hp_def dL)
    (- const-decl "[T -> real]" real_fun_ops reals)
    (* const-decl "[T -> real]" real_fun_ops reals)
    (x const-decl "dLVar" flight_turn_example nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (dLVar type-decl nil hp_def dL)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL))
   nil
   (turn_tr_odes subtype
    "(: (flight_turn_example.x, real_fun_ops[Environment].*((real_fun_ops[Environment].-)(hp_def.cnst(flight_turn_example.c)), flight_turn_example.sin_re(hp_def.val(flight_turn_example.theta)))), (flight_turn_example.y, real_fun_ops[Environment].*(hp_def.cnst(flight_turn_example.c), flight_turn_example.cos_re(hp_def.val(flight_turn_example.theta)))), (flight_turn_example.theta, hp_def.cnst(1)) :)"
    "ODEs")))
 (fs_tr_r_equiv 0
  (fs_tr_r_equiv-1 nil 3882219335
   (""
    (then (skeep) (expand "fs_tr") (expand "fs_r")
     (spread (split 1)
      ((then (decompose-equality 1) (eval-expr "theta = x") (assert)
        (rewrite "dlvar_inj") (assert) (rewrite "cos_0") (assert))
       (then (decompose-equality 1) (eval-expr "theta = y") (assert)
        (rewrite "dlvar_inj") (assert) (rewrite "sin_0") (assert)))))
    nil)
   ((cos_range application-judgement "real_abs_le1" sincos trig)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (sin_range application-judgement "real_abs_le1" sincos trig)
    (fs_tr const-decl "real" flight_turn_example nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (FALSE const-decl "bool" booleans nil)
    (dlvar_inj formula-decl nil hp_def dL)
    (cos_0 formula-decl nil sincos_def trig)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (sin const-decl "real" sincos_def trig)
    (y const-decl "dLVar" flight_turn_example nil)
    (cos const-decl "real" sincos_def trig)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (x const-decl "dLVar" flight_turn_example nil)
    (theta const-decl "dLVar" flight_turn_example nil)
    (dlvar_index adt-accessor-decl "[dLVar -> nat]" hp_def dL)
    (dLVar type-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sin_0 formula-decl nil sincos_def trig)
    (fs_r const-decl "real" flight_turn_example nil))
   shostak))
 (turn_tr_sol_TCC1 0
  (turn_tr_sol_TCC1-1 nil 3882190940
   ("" (then (skeep) (skeep) (grind)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil)
    (turn_tr_odes const-decl "ODEs" flight_turn_example nil)
    (y const-decl "dLVar" flight_turn_example nil)
    (theta const-decl "dLVar" flight_turn_example nil)
    (x const-decl "dLVar" flight_turn_example nil))
   nil
   (turn_tr_sol subtype
    "flight_turn_example.fs_tr(flight_turn_example.envi, flight_turn_example.c)"
    "[naturalnumbers.below(list_props[MapExpr].length(flight_turn_example.turn_tr_odes(flight_turn_example.c))) -> [real -> real]]")))
 (turn_tr_sol 0
  (turn_tr_sol-1 nil 3882108472
   (""
    (then (skeep) (skoletin*) (expand "solution_odes?" 1)
     (spread (split 1)
      ((then (expand "derivable_odes?" 1) (skeep) (expand "restrict")
        (typepred "k")
        (spread (case "k=0")
         ((then (replace -1) (expand "fs_tr" 1) (hide -)
           (spread
            (case "derivable?[real] (LAMBDA (s: real): envi(dlvar_index(x)) - c * cos(envi(dlvar_index(theta))) + c * cos(s + envi(dlvar_index(theta))))")
            ((then (lemma "derivable_subtype[real,(D)]") (inst?)
              (assert) (expand "restrict" -1) (lemma "dd_deriv_domain")
              (lemma "dd_noe") (inst?) (inst?) (assert))
             (then (hide 2) (derivable)))))
          (spread (case "k=1")
           ((then (replace -1) (expand "fs_tr" 2) (hide -)
             (spread
              (case "derivable?[real] (LAMBDA (s: real): envi(dlvar_index(y)) - c * sin(envi(dlvar_index(theta))) + c * sin(s + envi(dlvar_index(theta))))")
              ((then (lemma "derivable_subtype[real,(D)]") (inst?)
                (assert) (expand "restrict") (lemma "dd_noe")
                (lemma "dd_deriv_domain") (inst?) (inst?) (assert))
               (then (hide 2 3) (derivable)))))
            (spread (case "NOT k=2")
             ((then (assert) (hide -2 4) (grind))
              (then (replace -1) (expand "fs_tr" 3) (hide -3)
               (derivable)))))))))
       (then (expand "env_at_t?") (skeep)
        (spread (case "k=0")
         ((then (replace -1) (expand "fs_tr" 1) (expand "nth" 1)
           (expand "turn_tr_odes" 1) (propax))
          (spread (case "k=1")
           ((then (replace -1) (expand "fs_tr" 2)
             (expand "turn_tr_odes" 2) (expand "nth" 2)
             (expand "nth" 2) (propax))
            (spread (case "k=2")
             ((then (replace -1) (expand "fs_tr" 3)
               (expand "turn_tr_odes" 3) (expand "nth" 3)
               (expand "nth" 3) (expand "nth" 3) (propax))
              (then (typepred "k") (hide -2) (hide 4)
               (expand "length" -1) (expand "length" -1) (assert)
               (expand "turn_tr_odes") (expand "length" -1)
               (expand "length" -1) (assert)))))))))
       (then (skeep) (expand "sol_at_t?" 1) (skeep)
        (spread (case "k=0")
         ((then (replace -1) (expand "turn_tr_odes" 1) (expand "nth" 1)
           (expand "restrict" 1) (expand "fs_tr" 1) (hide -2)
           (expand "sin_re") (expand "val") (expand "*" 1)
           (expand "cnst" 1) (assert) (expand "-" 1)
           (spread
            (case "deriv[real] (LAMBDA (s: real): envi(dlvar_index(x)) - c * cos(envi(dlvar_index(theta))) + c * cos(s + envi(dlvar_index(theta)))) (t) = -c * sin(env(dlvar_index(theta)))")
            ((then (lemma "  deriv_subtype_dd[real,(D)]") (inst?)
              (assert) (expand "restrict")
              (spread (split -1)
               ((then (decompose-equality -1) (inst -1 "t") (assert))
                (then (hide 2 -1) (derivable))
                (then (hide -1 2) (lemma "dd_deriv_domain") (inst?))
                (then (assert) (lemma "dd_noe") (inst?)))))
             (then (assert) (hide 2) (deriv) (typepred "env")
              (expand "env_at_t?" -1) (flatten)
              (spread (inst -2 "2")
               ((then (expand "nth" -2) (expand "turn_tr_odes" -2)
                 (expand "nth" -2) (expand "nth" -2)
                 (expand "fs_tr" -2) (assert))
                (then (hide -) (hide 2) (expand "turn_tr_odes")
                 (eval-expr 1) (assert)))))
             (then (hide 2) (derivable)))))
          (spread (case "k=1")
           ((then (replace -1) (hide -2) (expand "restrict")
             (expand "turn_tr_odes") (expand "fs_tr") (expand "nth")
             (expand "nth") (expand "cnst") (expand "*")
             (expand "cos_re") (assert)
             (spread
              (case "deriv[real] (LAMBDA (s: real): envi(dlvar_index(y)) - c * sin(envi(dlvar_index(theta))) + c * sin(s + envi(dlvar_index(theta)))) (t) = c * cos(val(theta)(env))")
              ((then (lemma "  deriv_subtype_dd[real,(D)]") (inst?)
                (spread (split -1)
                 ((spread (decompose-equality -1)
                   ((then (inst -1 "t") (expand "restrict") (assert))
                    (then (hide 3) (hide -) (derivable))
                    (then (lemma "dd_noe") (inst?))
                    (then (lemma "dd_deriv_domain") (inst?))))
                  (then (assert) (hide -1 2 3) (derivable))
                  (then (lemma "dd_deriv_domain") (inst?))
                  (then (assert) (lemma "dd_noe") (inst?)))))
               (then (assert) (hide 2 3) (typepred "env")
                (expand "env_at_t?") (flatten)
                (spread (inst -2 "2")
                 ((then (hide -1) (expand "fs_tr")
                   (expand "turn_tr_odes") (expand "nth")
                   (expand "nth") (expand "nth") (expand "val" 1)
                   (replace -1 1 rl) (hide -1) (deriv))
                  (then (hide 2) (expand "turn_tr_odes") (eval-expr 1)
                   (assert)))))
               (then (hide 2 3) (derivable)))))
            (spread (case "NOT k=2")
             ((then (typepred "k") (hide -2 4) (grind))
              (then (replace -1) (hide -2) (expand "restrict")
               (expand "turn_tr_odes") (expand "nth" 3)
               (expand "nth" 3) (expand "nth" 3) (expand "fs_tr")
               (expand "cnst") (assert) (hide -1 1 2)
               (spread
                (case "deriv[real](LAMBDA (s: real): s + envi(dlvar_index(theta)))(t) = 1")
                ((then (lemma "  deriv_subtype_dd[real,(D)]") (inst?)
                  (spread (split -1)
                   ((then (expand "restrict" -1)
                     (decompose-equality -1) (inst?) (assert))
                    (then (hide 2 -1) (derivable))
                    (then (lemma "dd_deriv_domain") (inst?))
                    (then (assert) (lemma "dd_noe") (inst?)))))
                 (then (hide 2) (deriv))
                 (then (hide 2) (derivable)))))))))))))))
    nil)
   ((solution_odes? const-decl "bool" hp_expr dL)
    (derivative_sin formula-decl nil sincos_def trig)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (deriv_sub_lam formula-decl nil derivatives_lam analysis)
    (deriv_scal1_lam formula-decl nil derivatives_lam analysis)
    (deriv_add_lam formula-decl nil derivatives_lam analysis)
    (deriv_const_lam formula-decl nil derivatives_lam analysis)
    (chain_rule formula-decl nil chain_rule analysis)
    (derivative_cos formula-decl nil sincos_def trig)
    (deriv_id_lam formula-decl nil derivatives_lam analysis)
    (zero_times1 formula-decl nil real_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cos_re const-decl "real" flight_turn_example nil)
    (deriv_subtype_dd formula-decl nil derivatives_subtype analysis)
    (minus_real_is_real application-judgement "real" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (deriv const-decl "[T -> real]" derivatives analysis)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (sin_re const-decl "real" flight_turn_example nil)
    (sol_at_t? const-decl "bool" hp_expr dL)
    (env_at_t? const-decl "bool" hp_expr dL)
    (nth def-decl "T" list_props nil)
    (derivable_odes? const-decl "bool" hp_expr dL)
    (restrict const-decl "R" restrict nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cos_range application-judgement "real_abs_le1" sincos trig)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (fs_tr const-decl "real" flight_turn_example nil)
    (derivable? const-decl "bool" derivatives analysis)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (x const-decl "dLVar" flight_turn_example nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (cos const-decl "real" sincos_def trig)
    (theta const-decl "dLVar" flight_turn_example nil)
    (dd_noe formula-decl nil hp_expr dL)
    (dd_deriv_domain formula-decl nil hp_expr dL)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (deriv_domain? const-decl "bool" deriv_domain_def analysis)
    (dd? const-decl "bool" hp_expr dL)
    (derivable_subtype formula-decl nil derivatives_subtype analysis)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (not_one_element formula-decl nil integral_split analysis)
    (deriv_domain_real formula-decl nil deriv_domain analysis)
    (derivable_scal1_lam formula-decl nil derivatives_lam analysis)
    (derivable_cos formula-decl nil sincos_def trig)
    (derivable_const_lam formula-decl nil derivatives_lam analysis)
    (derivable_id_lam formula-decl nil derivatives_lam analysis)
    (comp_derivable_fun formula-decl nil chain_rule analysis)
    (deriv_fun type-eq-decl nil derivatives analysis)
    (derivable_add_lam formula-decl nil derivatives_lam analysis)
    (pi_bound name-judgement
     "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig)
    (minus_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (derivable_sin formula-decl nil sincos_def trig)
    (sin const-decl "real" sincos_def trig)
    (y const-decl "dLVar" flight_turn_example nil)
    (sin_range application-judgement "real_abs_le1" sincos trig)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (length def-decl "nat" list_props nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (ODEs type-eq-decl nil hp_def dL)
    (turn_tr_odes const-decl "ODEs" flight_turn_example nil)
    (below type-eq-decl nil naturalnumbers nil))
   shostak))
 (turn_tr_sol_u 0
  (turn_tr_sol_u-1 nil 3882289728
   (""
    (then (skeep) (lemma "turn_tr_sol") (inst?) (inst -1 "D")
     (expand "solution_odes_u?" 1) (assert) (skeep)
     (spread (case " FORALL (t: (S)): ff(2)(t) = fs_tr(envi, c)(2)(t)")
      ((then (skeep)
        (spread (case "i=2")
         ((then (assert) (inst -2 "t") (assert))
          (spread (case "i=0")
           ((then (expand "solution_odes?" -4) (flatten)
             (inst -6 "t" "env_at_t(turn_tr_odes(c),ff,envi)(t)")
             (spread
              (lemma "derivs_funs_equal[( flight_turn_example.S)]")
              ((spread (case "EXISTS(a,b:(S)): a<b")
                ((then (skeep) (inst -2 "a" "b" "_" "_")
                  (spread
                   (inst -2 "LAMBDA(s:(S)): ff(i)(s)"
                    "LAMBDA(s:(S)):fs_tr(envi,c)(i)(s)")
                   ((then (assert)
                     (spread (split -2)
                      ((then (decompose-equality -1) (inst -1 "t"))
                       (then (assert) (skeep) (reveal -)
                        (inst -3 "x!1"
                         "env_at_t(turn_tr_odes(c),ff,envi)(x!1)")
                        (expand "sol_at_t?" -3) (inst -3 "0")
                        (expand "restrict" -3) (replace -7)
                        (replace -3 1) (expand "turn_tr_odes" 1)
                        (expand "nth" 1) (expand "*" 1)
                        (expand "cnst" 1) (expand "-" 1 1)
                        (expand "sin_re" 1 1) (expand "val" 1 1)
                        (typepred
                         "env_at_t((: (x, LAMBDA (x: Environment) -> real: (-LAMBDA (env: Environment) -> real: c)(x) * sin_re(val(theta))(x)), (y, LAMBDA (x: Environment) -> real: c * cos_re(val(theta))(x)), (theta, LAMBDA (env: Environment) -> real: 1) :), ff, envi) (x!1)")
                        (hide -2) (expand "env_at_t?" -1) (flatten)
                        (spread (inst -2 "2")
                         ((then (expand "nth" -2) (expand "nth" -2)
                           (expand "nth" -2) (replace -2 1 rl)
                           (inst -10 "x!1") (replace -10 1)
                           (expand "fs_tr" 1 1) (expand "fs_tr" 1)
                           (hide -) (hide 2 3) (lemma "dd_noe")
                           (inst -1 "S") (lemma "dd_deriv_domain")
                           (inst -1 "S") (label "good" *) (hide good)
                           (reveal good) (hide good)
                           (deriv
                            "LAMBDA (t: real): envi(dlvar_index(x)) - c * cos(envi(dlvar_index(theta))) + c * cos(t + envi(dlvar_index(theta)))")
                           (reveal good)
                           (lemma
                            "deriv_subtype_dd[real,(flight_turn_example.S)]")
                           (inst -1
                            "LAMBDA (t: real): envi(dlvar_index(x)) - c * cos(envi(dlvar_index(theta))) + c * cos(t + envi(dlvar_index(theta)))")
                           (assert) (decompose-equality -1)
                           (inst -1 "x!1") (expand "restrict") (assert)
                           (decompose-equality -4) (inst -1 "x!1")
                           (assert))
                          (then (expand "length" 1) (expand "length" 1)
                           (assert)))))
                       (spread (inst 1 "0")
                        ((then (expand "env_at_t?" -6) (inst -6 "i")
                          (replace -6 1) (expand "turn_tr_odes" 1 1)
                          (expand "nth" 1 1)
                          (expand "solution_odes?" -4) (flatten)
                          (expand "env_at_t?" -5) (inst -5 "0")
                          (expand "nth" -5) (expand "turn_tr_odes" -5)
                          (assert))
                         (then (typepred "S") (expand "dd?" -1)
                          (spread (split -1)
                           ((then (skeep) (replace -1) (hide-all-but 1)
                             (grind))
                            (then (replace -1) (hide-all-but 1)
                             (grind))))))))))
                    (then (lemma "solution_odes_sub")
                     (inst -1 "D" "turn_tr_odes(c)" "envi"
                      "fs_tr(envi,c)" "S")
                     (assert) (expand "solution_odes?" -1) (flatten)
                     (expand "derivable_odes?" -1) (inst -1 "0")
                     (expand "restrict" -1) (assert))
                    (then (expand "derivable_odes?" -5) (inst -5 "0")
                     (expand "restrict" -5) (assert)))))
                 (then (hide -) (hide 2 3) (typepred "S")
                  (expand "dd?" -1)
                  (spread (split -1)
                   ((then (skeep)
                     (spread (inst 1 "0" "b")
                      ((grind) (then (hide -2) (grind))
                       (then (hide -2) (grind)))))
                    (spread (inst 1 "0" "1")
                     ((assert) (then (hide -2) (grind))
                      (then (hide -2) (grind)))))))))
               (then (lemma "dd_noe") (inst -1 "S"))
               (then (lemma "dd_con") (inst -1 "S")))))
            (spread (case "i=1")
             ((spread
               (lemma "derivs_funs_equal[(flight_turn_example.S)]")
               ((spread (case "EXISTS(a,b:(S)): a<b")
                 ((then (skeep) (inst -2 "a" "b" "_" "_")
                   (spread
                    (inst -2 "LAMBDA(t:(S)): ff(i)(t)"
                     "LAMBDA(t:(S)): fs_tr(envi,c)(i)(t)")
                    ((then (assert)
                      (spread (split -2)
                       ((then (decompose-equality -1) (inst -1 "t"))
                        (then (skeep) (expand "solution_odes?" -5)
                         (flatten)
                         (inst -7 "x!1"
                          "env_at_t(turn_tr_odes(c),ff,envi)(x!1)")
                         (expand "sol_at_t?" -7) (inst -7 "i")
                         (replace -2) (expand "restrict")
                         (replace -7 1) (expand "turn_tr_odes" 1)
                         (expand "nth" 1) (expand "nth" 1)
                         (expand "*" 1 1) (expand "cnst" 1 1)
                         (expand "cos_re" 1) (expand "val" 1)
                         (typepred
                          "env_at_t((: (x, -cnst(c) * sin_re(LAMBDA (env: Environment) -> real: env(dlvar_index(theta)))), (y, cnst(c) * LAMBDA (env: Environment) -> real: cos(env(dlvar_index(theta)))), (theta, cnst(1)) :), ff, envi) (x!1)")
                         (hide -2) (expand "env_at_t?" -1) (flatten)
                         (hide -1)
                         (spread (inst -1 "2")
                          ((then (expand "nth" -1) (expand "nth" -1)
                            (expand "nth" -1) (replace -1 1 rl)
                            (inst-cp -4 "x!1") (replace -5 1)
                            (expand "fs_tr" 1 1) (expand "fs_tr" 1)
                            (hide -) (hide 2 3 4) (label "good" *)
                            (hide good)
                            (deriv
                             "LAMBDA (T: real): envi(dlvar_index(y)) - c * sin(envi(dlvar_index(theta))) + c * sin(T + envi(dlvar_index(theta)))")
                            (reveal good)
                            (lemma
                             "deriv_subtype_dd[real,(flight_turn_example.S)]")
                            (inst?) (assert)
                            (spread (split -1)
                             ((then (decompose-equality -2)
                               (spread
                                (decompose-equality -2)
                                ((then
                                  (inst -2 "x!1")
                                  (inst -1 "x!1")
                                  (expand "restrict")
                                  (assert))
                                 (then (lemma "dd_noe") (inst -1 "S"))
                                 (then
                                  (lemma "dd_deriv_domain")
                                  (inst -1 "S")))))
                              (then (assert) (lemma "dd_deriv_domain")
                               (inst -1 "S"))
                              (then (lemma "dd_noe") (inst -1 "S")))))
                           (then (expand "length" 1)
                            (expand "length" 1) (assert)))))
                        (spread (inst 1 "0")
                         ((then (expand "solution_odes?") (flatten)
                           (expand "env_at_t?" -5)
                           (expand "env_at_t?" -8) (inst -5 "i")
                           (inst -8 "i") (assert))
                          (then (hide-all-but 1) (typepred "S")
                           (hide -2) (expand "dd?" -1)
                           (spread (split -1)
                            ((then (skeep) (grind)) (grind)))))))))
                     (then (hide 2 3 4) (lemma "solution_odes_sub")
                      (inst -1 "D" "turn_tr_odes(c)" "envi"
                       "fs_tr(envi,c)" "S")
                      (assert) (expand "solution_odes?" -1) (flatten)
                      (expand "derivable_odes?" -1) (inst -1 "i")
                      (expand "restrict" -1) (propax))
                     (then (assert) (expand "solution_odes?" -5)
                      (flatten) (expand "derivable_odes?" -5)
                      (inst -5 "i") (assert) (expand "restrict" -5)
                      (propax)))))
                  (then (hide -) (hide-all-but 1) (typepred "S")
                   (hide -2) (expand "dd?" -1)
                   (spread (split -1)
                    ((then (skeep)
                      (spread (inst 1 "0" "b")
                       ((grind) (grind) (grind))))
                     (spread (inst 1 "0" "1")
                      ((grind) (grind) (grind))))))))
                (then (lemma "dd_noe") (inst -1 "S"))
                (then (lemma "dd_con") (inst -1 "S"))))
              (then (assert) (hide -) (typepred "i") (hide 4)
               (grind)))))))))
       (then (skeep)
        (spread (lemma "derivs_funs_equal[(flight_turn_example.S)]")
         ((spread (case "EXISTS(a,b:(S)): a<b")
           ((then (skeep) (skeep) (inst -2 "a" "b" "_" "_")
             (spread
              (inst -2 "LAMBDA(s:(S)): ff(2)(s)"
               "LAMBDA(s:(S)): fs_tr(envi,c)(2)(s)")
              ((spread (split -2)
                ((then (decompose-equality -1) (inst -1 "t")) (propax)
                 (then (assert) (hide 3) (skeep) (expand "fs_tr" 1)
                  (expand "solution_odes?" -3) (flatten)
                  (inst -5 "x!1"
                   "env_at_t(turn_tr_odes(c),ff,envi)(x!1)")
                  (expand "sol_at_t?" -5) (inst -5 "2")
                  (expand "restrict" -5) (replace -5)
                  (expand "turn_tr_odes" 1 1) (expand "nth" 1)
                  (expand "nth" 1) (expand "nth" 1) (expand "cnst" 1)
                  (hide -) (hide 2) (label good 1) (hide good)
                  (deriv
                   "LAMBDA (s: real): s + envi(dlvar_index(theta))")
                  (reveal good)
                  (lemma
                   "deriv_subtype_dd[real,(flight_turn_example.S)]")
                  (inst -1
                   "LAMBDA(s:real): s + envi(dlvar_index(theta))")
                  (assert)
                  (spread (split -1)
                   ((spread (decompose-equality -1)
                     ((then (inst -1 "x!1") (decompose-equality -2)
                       (inst -1 "x!1") (assert) (expand "restrict")
                       (assert))
                      (then (lemma "dd_noe") (inst -1 "S"))
                      (then (lemma "dd_deriv_domain") (inst -1 "S"))))
                    (then (lemma "dd_deriv_domain") (inst -1 "S"))
                    (then (lemma "dd_noe") (inst -1 "S")))))
                 (spread (inst 1 "0")
                  ((then (expand "solution_odes?") (flatten)
                    (expand "env_at_t?" -6) (expand "env_at_t?" -3)
                    (inst -3 "2") (inst -6 "2") (assert))
                   (then (hide-all-but 1) (typepred "S")
                    (expand "dd?" -1)
                    (spread (split -1)
                     ((then (skeep) (grind)) (grind))))))))
               (then (lemma "solution_odes_sub")
                (inst -1 "D" "turn_tr_odes(c)" "envi" "fs_tr(envi,c)"
                 "S")
                (assert) (expand "solution_odes?" -1) (flatten)
                (expand "derivable_odes?" -1) (inst -1 "2")
                (expand "restrict") (propax))
               (then (expand "solution_odes?" -3) (flatten)
                (expand "derivable_odes?" -3) (inst -3 "2")
                (expand "restrict" -3) (propax)))))
            (then (hide-all-but 1) (typepred "S") (expand "dd?" -1)
             (spread (split -1)
              ((then (skeep)
                (spread (inst 1 "0" "b") ((grind) (grind) (grind))))
               (spread (inst 1 "0" "1") ((grind) (grind) (grind))))))))
          (then (lemma "dd_noe") (inst -1 "S"))
          (then (lemma "dd_con") (inst -1 "S")))))
       (then (skeep) (expand "turn_tr_odes" 1) (expand "length" 1)
        (expand "length" 1) (expand "length" 1) (expand "length" 1)
        (assert)))))
    nil)
   ((turn_tr_sol formula-decl nil flight_turn_example nil)
    (dd? const-decl "bool" hp_expr dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (fs_tr const-decl "real" flight_turn_example nil)
    (below type-eq-decl nil naturalnumbers nil)
    (turn_tr_odes const-decl "ODEs" flight_turn_example nil)
    (ODEs type-eq-decl nil hp_def dL)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (length def-decl "nat" list_props nil)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (derivable_sin formula-decl nil sincos_def trig)
    (derivative_sin formula-decl nil sincos_def trig)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (solution_odes? const-decl "bool" hp_expr dL)
    (env_at_t const-decl
     "{env: (env_at_t?(odes, fs, envi, t)) | FORALL (env2: (env_at_t?(odes, fs, envi, t))): env = env2}"
     hp_expr dL)
    (env_at_t? const-decl "bool" hp_expr dL)
    (dd_con formula-decl nil hp_expr dL)
    (solution_odes_sub formula-decl nil ODEs_equiv dL)
    (derivable_odes? const-decl "bool" hp_expr dL)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (hp const-decl "bool" interval_def ODEs)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (closed_interval const-decl "(closed_interval?(a, b))" interval_def
     ODEs)
    (sol_at_t? const-decl "bool" hp_expr dL)
    (restrict const-decl "R" restrict nil)
    (nth def-decl "T" list_props nil)
    (cnst const-decl "real" hp_def dL)
    (sin_re const-decl "real" flight_turn_example nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (x const-decl "dLVar" flight_turn_example nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (theta const-decl "dLVar" flight_turn_example nil)
    (y const-decl "dLVar" flight_turn_example nil)
    (cos_re const-decl "real" flight_turn_example nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (sin_range application-judgement "real_abs_le1" sincos trig)
    (cos_range application-judgement "real_abs_le1" sincos trig)
    (real_times_real_is_real application-judgement "real" reals nil)
    (sin const-decl "real" sincos_def trig)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (deriv_subtype_dd formula-decl nil derivatives_subtype analysis)
    (zero_times1 formula-decl nil real_props nil)
    (deriv_id_lam formula-decl nil derivatives_lam analysis)
    (derivative_cos formula-decl nil sincos_def trig)
    (chain_rule formula-decl nil chain_rule analysis)
    (deriv_const_lam formula-decl nil derivatives_lam analysis)
    (deriv_add_lam formula-decl nil derivatives_lam analysis)
    (deriv_scal1_lam formula-decl nil derivatives_lam analysis)
    (deriv_sub_lam formula-decl nil derivatives_lam analysis)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (deriv const-decl "[T -> real]" derivatives analysis)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (derivable_add_lam formula-decl nil derivatives_lam analysis)
    (comp_derivable_fun formula-decl nil chain_rule analysis)
    (derivable_id_lam formula-decl nil derivatives_lam analysis)
    (derivable_const_lam formula-decl nil derivatives_lam analysis)
    (derivable_cos formula-decl nil sincos_def trig)
    (derivable_scal1_lam formula-decl nil derivatives_lam analysis)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (cos const-decl "real" sincos_def trig)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (deriv_domain? const-decl "bool" deriv_domain_def analysis)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (not_one_element formula-decl nil integral_split analysis)
    (deriv_domain_real formula-decl nil deriv_domain analysis)
    (TRUE const-decl "bool" booleans nil)
    (minus_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (pi_bound name-judgement
     "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig)
    (dd_deriv_domain formula-decl nil hp_expr dL)
    (dd_noe formula-decl nil hp_expr dL)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (length_singleton formula-decl nil more_list_props structures)
    (val const-decl "real" hp_def dL)
    (deriv_fun type-eq-decl nil derivatives analysis)
    (derivable? const-decl "bool" derivatives analysis)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (connected? const-decl "bool" deriv_domain_def analysis)
    (derivs_funs_equal formula-decl nil derivative_props analysis)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (solution_odes_u? const-decl "bool" hp_expr dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (turn_sol_TCC1 0
  (turn_sol_TCC1-1 nil 3882178734 ("" (then (skeep) (grind)) nil)
   ((length def-decl "nat" list_props nil)
    (turn_odes const-decl "ODEs" flight_turn_example nil)
    (y const-decl "dLVar" flight_turn_example nil)
    (x const-decl "dLVar" flight_turn_example nil))
   nil
   (turn_sol subtype
    "flight_turn_example.fs_r(flight_turn_example.envi)"
    "[naturalnumbers.below(list_props[MapExpr].length(flight_turn_example.turn_odes)) -> [real -> real]]")))
 (turn_sol 0
  (turn_sol-1 nil 3882178735
   (""
    (then (skeep) (expand "solution_odes?" 1)
     (spread (split 1)
      ((then (expand "derivable_odes?" 1) (skeep) (expand "restrict")
        (typepred "k")
        (spread (case "k=0")
         ((then (replace -1) (expand "fs_r" 1) (hide -)
           (spread
            (case " derivable?[real](LAMBDA (s: real): envi(dlvar_index(x)) * cos(s) - envi(dlvar_index(y)) * sin(s))")
            ((then (lemma "derivable_subtype[real,(D)]") (inst?)
              (assert) (expand "restrict" -1) (lemma "dd_deriv_domain")
              (lemma "dd_noe") (inst?) (inst?) (assert))
             (then (hide 2) (derivable)))))
          (spread (case "k=1")
           ((then (replace -1) (hide -) (expand "fs_r" 2)
             (spread
              (case " derivable?[real](LAMBDA (s: real): envi(dlvar_index(x)) * sin(s) + envi(dlvar_index(y)) * cos(s))")
              ((then (lemma "derivable_subtype[real,(D)]") (inst?)
                (assert) (expand "restrict") (lemma "dd_noe")
                (lemma "dd_deriv_domain") (inst?) (inst?) (assert))
               (then (hide 2 3) (derivable)))))
            (then (hide 3) (grind)))))))
       (then (expand "env_at_t?") (skeep)
        (spread (case "k=0")
         ((then (replace -1) (expand "fs_r" 1) (expand "nth" 1)
           (expand "turn_odes") (assert) (lemma "sin_0")
           (lemma "cos_0") (assert))
          (spread (case "k=1")
           ((then (replace -1) (expand "turn_odes") (expand "nth" 2)
             (expand "nth" 2) (expand "fs_r") (lemma "sin_0")
             (lemma "cos_0") (assert))
            (then (typepred "k") (grind)))))))
       (then (skeep) (expand "sol_at_t?" 1) (skeep)
        (spread (case "k=0")
         ((then (replace -1) (expand "nth") (expand "turn_odes")
           (expand "fs_r") (expand "val") (expand "-")
           (expand "restrict")
           (spread
            (case "deriv[real](LAMBDA (s: real): envi(dlvar_index(x)) * cos(s) - envi(dlvar_index(y)) * sin(s))(t) = -env(dlvar_index(y))")
            ((then (lemma "  deriv_subtype_dd[real,(D)]") (inst?)
              (assert) (expand "restrict")
              (spread (split -1)
               ((then (decompose-equality -1) (inst -1 "t") (assert))
                (then (hide 2 -1) (derivable))
                (then (hide -1 2) (lemma "dd_deriv_domain") (inst?))
                (then (assert) (lemma "dd_noe") (inst?)))))
             (then (assert) (hide 2) (deriv) (typepred "env")
              (expand "env_at_t?" -1) (flatten)
              (spread (inst -2 "1")
               ((then (expand "turn_odes") (expand "nth")
                 (expand "nth") (expand "fs_r") (assert))
                (then (hide -) (hide 2) (grind)))))
             (then (hide 2) (derivable)))))
          (spread (case "k=1")
           ((then (replace -1) (expand "restrict") (expand "nth")
             (expand "nth") (expand "fs_r") (expand "turn_odes")
             (expand "val")
             (spread
              (case "deriv[real](LAMBDA (s: real): envi(dlvar_index(x)) * sin(s) + envi(dlvar_index(y)) * cos(s))(t) = env(dlvar_index(x))")
              ((then (lemma "  deriv_subtype_dd[real,(D)]") (inst?)
                (spread (split -1)
                 ((spread (decompose-equality -1)
                   ((then (inst -1 "t") (expand "restrict") (assert))
                    (then (hide 3) (hide -) (derivable))
                    (then (lemma "dd_noe") (inst?))
                    (then (lemma "dd_deriv_domain") (inst?))))
                  (then (assert) (hide -1 2 3) (derivable))
                  (then (lemma "dd_deriv_domain") (inst?))
                  (then (assert) (lemma "dd_noe") (inst?)))))
               (then (assert) (hide 2 3) (typepred "env")
                (expand "env_at_t?") (flatten) (inst -2 "0")
                (expand "turn_odes") (expand "nth") (expand "fs_r")
                (hide -1) (replace -1 1 rl) (hide -1) (deriv))
               (then (hide 2 3) (derivable)))))
            (then (hide 3) (typepred "k") (grind))))))))))
    nil)
   ((solution_odes? const-decl "bool" hp_expr dL)
    (deriv_add_lam formula-decl nil derivatives_lam analysis)
    (val const-decl "real" hp_def dL)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (deriv_sub_lam formula-decl nil derivatives_lam analysis)
    (derivative_cos formula-decl nil sincos_def trig)
    (derivative_sin formula-decl nil sincos_def trig)
    (deriv_mult_lam formula-decl nil derivatives_lam analysis)
    (deriv_scal1_lam formula-decl nil derivatives_lam analysis)
    (derivable_const_lam formula-decl nil derivatives_lam analysis)
    (deriv_const_lam formula-decl nil derivatives_lam analysis)
    (zero_times1 formula-decl nil real_props nil)
    (deriv_subtype_dd formula-decl nil derivatives_subtype analysis)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (deriv const-decl "[T -> real]" derivatives analysis)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (sol_at_t? const-decl "bool" hp_expr dL)
    (env_at_t? const-decl "bool" hp_expr dL)
    (sin_0 formula-decl nil sincos_def trig)
    (cos_0 formula-decl nil sincos_def trig)
    (nth def-decl "T" list_props nil)
    (derivable_odes? const-decl "bool" hp_expr dL)
    (restrict const-decl "R" restrict nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (sin_range application-judgement "real_abs_le1" sincos trig)
    (real_times_real_is_real application-judgement "real" reals nil)
    (cos_range application-judgement "real_abs_le1" sincos trig)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (fs_r const-decl "real" flight_turn_example nil)
    (derivable? const-decl "bool" derivatives analysis)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (x const-decl "dLVar" flight_turn_example nil)
    (cos const-decl "real" sincos_def trig)
    (y const-decl "dLVar" flight_turn_example nil)
    (sin const-decl "real" sincos_def trig)
    (dd_noe formula-decl nil hp_expr dL)
    (dd_deriv_domain formula-decl nil hp_expr dL)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (deriv_domain? const-decl "bool" deriv_domain_def analysis)
    (dd? const-decl "bool" hp_expr dL)
    (derivable_subtype formula-decl nil derivatives_subtype analysis)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (not_one_element formula-decl nil integral_split analysis)
    (deriv_domain_real formula-decl nil deriv_domain analysis)
    (derivable_cos formula-decl nil sincos_def trig)
    (derivable_scal1_lam formula-decl nil derivatives_lam analysis)
    (derivable_sin formula-decl nil sincos_def trig)
    (deriv_fun type-eq-decl nil derivatives analysis)
    (derivable_sub_lam formula-decl nil derivatives_lam analysis)
    (pi_bound name-judgement
     "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig)
    (minus_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (derivable_add_lam formula-decl nil derivatives_lam analysis)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (length def-decl "nat" list_props nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (ODEs type-eq-decl nil hp_def dL)
    (turn_odes const-decl "ODEs" flight_turn_example nil)
    (below type-eq-decl nil naturalnumbers nil))
   shostak))
 (turn_Lip 0
  (turn_Lip-1 nil 3882262254
   (""
    (then (skeep) (expand "Lip_ODEs?" 1) (expand "turn_odes" 1 1)
     (expand "length" 1 1) (assert) (skeep)
     (spread (case "k=0")
      ((then (replace -1) (expand "turn_odes" 1) (expand "nth" 1)
        (inst 1 "1") (skeep) (skeep) (typepred "y1" "y2")
        (expand "const?")
        (typepred
         "env_at_t((: (x, -val(y)), (y, val(x)) :), y1, envi)(t)")
        (expand "env_at_t?" -1) (flatten)
        (spread (inst -2 "1")
         ((then (expand "nth" -2) (expand "nth" -2) (expand "val" 1 1)
           (expand "-" 1 1) (replace -2 1 rl) (expand "val" 1 1)
           (expand "-" 1 3)
           (typepred
            "env_at_t((: (x, -val(y)), (y, val(x)) :), y2, envi)(t)")
           (expand "env_at_t?" -1) (flatten)
           (spread (inst -2 "1")
            ((then (expand "nth" -2) (expand "nth" -2)
              (replace -2 1 rl)
              (typepred
               "max_diff(length((: (x, -val(y)), (y, val(x)) :)))(y1, y2)")
              (spread (inst -2 "1" "t")
               ((then (assert)
                 (spread
                  (case " abs(y1(1)(t) - y2(1)(t)) = abs(-y1(1)(t) - -y2(1)(t))")
                  ((assert)
                   (then (hide -) (hide 2) (lemma "abs_neg")
                    (inst -1 "y1(1)(t)-y2(1)(t)")
                    (spread
                     (case "-(y1(1)(t) - y2(1)(t)) = -y1(1)(t) - -y2(1)(t)")
                     ((assert) (assert)))))))
                (then (expand "length" 1) (assert)))))
             (then (expand "length" 1) (assert)))))
          (then (expand "length" 1) (assert)))))
       (spread (case "k=1")
        ((then (inst 2 "1") (skeep*)
          (typepred "env_at_t(turn_odes, y1, envi)(t)")
          (typepred "env_at_t(turn_odes, y2, envi)(t)")
          (expand "env_at_t?") (flatten) (expand "turn_odes" 2)
          (expand "nth" 2) (assert) (replace -7) (expand "nth" 2)
          (expand "val" 2) (inst -2 "0") (expand "turn_odes")
          (inst -5 "0") (expand "nth" -2) (expand "nth" -5)
          (expand "val") (replace -2 2 rl) (replace -5 2 rl)
          (typepred
           "max_diff(length((: (x, -LAMBDA (env: Environment) -> real: env(dlvar_index(y))), (y, LAMBDA (env: Environment) -> real: env(dlvar_index(x))) :))) (y1, y2)")
          (hide -3 -6)
          (spread (inst -2 "0" "t")
           ((assert) (then (expand "length") (assert)))))
         (then (typepred "k") (expand "turn_odes" -1) (hide 3)
          (grind)))))))
    nil)
   ((real_minus_real_is_real application-judgement "real" reals nil)
    (length def-decl "nat" list_props nil)
    (TRUE const-decl "bool" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nth def-decl "T" list_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (const? const-decl "bool" ODEs_equiv dL)
    (env_at_t const-decl
     "{env: (env_at_t?(odes, fs, envi, t)) | FORALL (env2: (env_at_t?(odes, fs, envi, t))): env = env2}"
     hp_expr dL)
    (<= const-decl "bool" reals nil)
    (y const-decl "dLVar" flight_turn_example nil)
    (val const-decl "real" hp_def dL)
    (x const-decl "dLVar" flight_turn_example nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (env_at_t? const-decl "bool" hp_expr dL)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (max_diff def-decl
     "{x: nnreal | (FORALL (i: below(k), r: real): abs(y1(i)(r) - y2(i)(r)) <= x) AND EXISTS (i: below(k)): x = abs(y1(i)(0) - y2(i)(0))}"
     ODEs_equiv dL)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (abs_neg formula-decl nil abs_lems reals)
    (unary_minus_dist formula-decl nil continuous_linear analysis)
    (minus_real_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnreal type-eq-decl nil real_types nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (Environment type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (ODEs type-eq-decl nil hp_def dL)
    (below type-eq-decl nil naturalnumbers nil)
    (length_singleton formula-decl nil more_list_props structures)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (turn_odes const-decl "ODEs" flight_turn_example nil))
   shostak))
 (turn_cont 0
  (turn_cont-1 nil 3882273339
   (""
    (then (skeep) (expand "cont_ODEs?") (expand "cont_ODEs?") (skeep*)
     (inst 1 "1") (skeep)
     (spread (case "k=0")
      ((then (expand "nth") (assert)
        (typepred "env_at_t(turn_odes, y!1, envi)(t1)"
         "env_at_t(turn_odes, y!1, envi)(t)")
        (expand "turn_odes" 1 1) (expand "turn_odes" 1 2)
        (expand "val" 1) (expand "-" 1) (expand "env_at_t?" -)
        (flatten)
        (spread (inst -2 "1")
         ((then (inst -5 "1") (expand "turn_odes" -2 2)
           (expand "turn_odes" -5 2) (expand "nth" -2)
           (expand "nth" -2) (expand "nth" -5) (expand "nth" -5)
           (replace -2 1 rl) (replace -5 1 rl) (typepred "y!1")
           (expand "const?" -1) (inst -1 "1") (skeep) (inst-cp -1 "t1")
           (inst -1 "t") (assert) (replace -1) (replace -2) (assert)
           (hide -) (grind))
          (then (hide 2) (hide -) (expand "turn_odes" 1)
           (expand "length" 1) (expand "length" 1) (assert)))))
       (spread (case "k=1")
        ((then (replace -1) (expand "turn_odes" 2 1)
          (expand "turn_odes" 2 2) (expand "nth" 2) (expand "nth" 2)
          (expand "val" 2)
          (typepred "env_at_t(turn_odes, y!1, envi)(t1)"
           "env_at_t(turn_odes, y!1, envi)(t)")
          (expand "env_at_t?") (flatten) (inst -2 "0") (inst -5 "0")
          (expand "turn_odes" -2 2) (expand "turn_odes" -5 2)
          (expand "nth" -2) (expand "nth" -5) (replace -2 2 rl)
          (replace -5 2 rl) (typepred "y!1") (expand "const?" -1)
          (inst -1 "0") (skeep) (inst-cp -1 "t1") (inst -1 "t")
          (replace -1) (replace -2) (hide -) (assert) (grind))
         (then (typepred "k") (expand "turn_odes" -1) (hide -2 3)
          (grind)))))))
    nil)
   ((cont_ODEs? const-decl "bool" ODEs_equiv dL)
    (TRUE const-decl "bool" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (x const-decl "dLVar" flight_turn_example nil)
    (y const-decl "dLVar" flight_turn_example nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nth def-decl "T" list_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (env_at_t? const-decl "bool" hp_expr dL)
    (const? const-decl "bool" ODEs_equiv dL)
    (nnreal type-eq-decl nil real_types nil)
    (<= const-decl "bool" reals nil)
    (env_at_t const-decl
     "{env: (env_at_t?(odes, fs, envi, t)) | FORALL (env2: (env_at_t?(odes, fs, envi, t))): env = env2}"
     hp_expr dL)
    (minus_real_is_real application-judgement "real" reals nil)
    (- const-decl "[T -> real]" real_fun_ops reals)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil)
    (val const-decl "real" hp_def dL)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (dLVar type-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (length def-decl "nat" list_props nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (ODEs type-eq-decl nil hp_def dL)
    (turn_odes const-decl "ODEs" flight_turn_example nil)
    (below type-eq-decl nil naturalnumbers nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (cont_ODEs? const-decl "bool" ODEs_equiv dL)
    (real_minus_real_is_real application-judgement "real" reals nil))
   shostak))
 (turn_Lip_dd 0
  (turn_Lip_dd-1 nil 3882273503
   (""
    (then (skeep) (expand "Lip_ODEs?" 1)
     (spread (split 1)
      ((then (flatten) (expand "Lip_ODEs?" 1) (skeep)
        (lemma "turn_Lip") (inst?))
       (then (flatten) (lemma "turn_Lip")
        (spread (inst?)
         ((then (assert)
           (spread (typepred "d_b[D]")
            ((then (typepred "D") (expand "dd?" -1) (assert) (skeep)
              (replace -1) (inst-cp -6 "0")
              (spread (inst -6 "car(cdr(d_b[D]))")
               ((then (assert) (grind)) (grind))))
             (then (typepred "D") (expand "dd?" -1) (skeep) (assert)
              (replace -1) (lemma "ci_ci") (inst?)))))
          (then (typepred "D") (expand "dd?") (assert) (skeep)
           (lemma "ci_ci") (inst?) (assert))))))))
    nil)
   ((Lip_ODEs? const-decl "bool" ODEs_equiv dL)
    (listn_0 name-judgement "listn(0)" vector_arithmetic mv_analysis)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (dd? const-decl "bool" hp_expr dL)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (d_b const-decl
     "{dd: list[real] | (length(dd) = 2 AND (d(car(dd)) AND d(car(cdr(dd))))) AND FORALL (x: real): (car(dd) <= x AND x <= car(cdr(dd))) IFF d(x)}"
     r2v_continuous_extension ODEs)
    (D skolem-const-decl "(dd?)" flight_turn_example nil)
    (closed_interval? const-decl "bool" interval_def ODEs)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (closed_interval? const-decl "bool" interval_def ODEs)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (closed_interval const-decl "(closed_interval?(a, b))" interval_def
     ODEs)
    (ci_ci formula-decl nil interval_def ODEs)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (< const-decl "bool" reals nil)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (nnreal type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (turn_Lip formula-decl nil flight_turn_example nil)
    (Lip_ODEs? const-decl "bool" ODEs_equiv dL))
   shostak))
 (turn_cont_dd 0
  (turn_cont_dd-1 nil 3882273647
   (""
    (then (skeep) (typepred "D") (expand "dd?" -1)
     (spread (split -1)
      ((then (skeep) (replace -1) (expand "cont_ODEs?" 1)
        (spread (split 1)
         ((then (flatten) (hide 1) (decompose-equality -1)
           (inst -1 "b+1") (grind))
          (then (flatten) (lemma "turn_cont")
           (spread (inst?)
            ((then (assert)
              (spread (typepred "d_b[closed_interval(0, b)]")
               ((then (inst-cp -5 "0")
                 (spread (inst -5 "car(d_b[closed_interval(0, b)])")
                  ((grind) (then (hide -) (lemma "ci_ci") (inst?)))))
                (then (assert) (lemma "ci_ci") (inst?)))))
             (then (assert) (lemma "ci_ci") (inst?))))))))
       (then (expand "cont_ODEs?" 1) (assert) (expand "cont_ODEs?" 1)
        (skeep) (expand "cont_ODEs?" 1) (skeep*) (inst 1 "1") (skeep)
        (spread (case "k=0")
         ((then (replace -1) (expand "turn_odes" 1 1)
           (expand "turn_odes" 1 2) (expand "nth" 1) (expand "val" 1)
           (expand "-" 1)
           (typepred "env_at_t(turn_odes, y!1, envi)(t1)")
           (typepred "env_at_t(turn_odes, y!1, envi)(t)")
           (expand "env_at_t?") (flatten)
           (spread (inst -2 "1")
            ((then (inst -5 "1") (expand "turn_odes" -2)
              (expand "turn_odes" -5) (expand "nth") (expand "nth")
              (expand "turn_odes" 1) (replace -2 1 rl)
              (replace -5 1 rl) (hide -) (assert)
              (spread (case "-y!1(1)(t1) - -y!1(1)(t) = 0")
               ((then (assert) (replace -1) (hide -1) (grind))
                (then (hide 2) (assert) (typepred "y!1")
                 (expand "const?" -1) (inst -1 "1") (skeep)
                 (inst-cp -1 "t") (inst-cp -1 "t1") (assert)))))
             (then (hide -) (hide 2) (grind)))))
          (spread (case "k=1")
           ((then (replace -1) (expand "turn_odes") (expand "nth" 2)
             (expand "nth" 2) (expand "val" 2)
             (typepred
              "env_at_t((: (x, -LAMBDA (env: Environment) -> real: env(dlvar_index(y))), (y, LAMBDA (env: Environment) -> real: env(dlvar_index(x))) :), y!1, envi) (t1)")
             (typepred
              " env_at_t((: (x, -LAMBDA (env: Environment) -> real: env(dlvar_index(y))), (y, LAMBDA (env: Environment) -> real: env(dlvar_index(x))) :), y!1, envi) (t)")
             (hide -2) (hide -3) (expand "env_at_t?" -) (flatten)
             (spread (inst -4 "0")
              ((then (inst -2 "0") (expand "nth" -) (replace -2 2 rl)
                (replace -4 2 rl) (hide -) (typepred "y!1")
                (expand "const?" -1) (inst -1 "0") (skeep)
                (inst-cp -1 "t1") (inst -1 "t") (assert) (replace -1)
                (replace -2) (assert) (hide -) (grind))
               (then (expand "length" 1) (assert)))))
            (then (typepred "k") (hide -2 -3 -3) (grind))))))))))
    nil)
   ((dd? const-decl "bool" hp_expr dL)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nnreal_plus_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (hp const-decl "bool" interval_def ODEs)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (closed_interval const-decl "(closed_interval?(a, b))" interval_def
     ODEs)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (turn_cont formula-decl nil flight_turn_example nil)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (ci_ci formula-decl nil interval_def ODEs)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (Environment type-eq-decl nil hp_def dL)
    (d_b const-decl
     "{dd: list[real] | (length(dd) = 2 AND (d(car(dd)) AND d(car(cdr(dd))))) AND FORALL (x: real): (car(dd) <= x AND x <= car(cdr(dd))) IFF d(x)}"
     r2v_continuous_extension ODEs)
    (<= const-decl "bool" reals nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (nnreal type-eq-decl nil real_types nil)
    (TRUE const-decl "bool" booleans nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (length_singleton formula-decl nil more_list_props structures)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (val const-decl "real" hp_def dL)
    (env_at_t? const-decl "bool" hp_expr dL)
    (const? const-decl "bool" ODEs_equiv dL)
    (env_at_t const-decl
     "{env: (env_at_t?(odes, fs, envi, t)) | FORALL (env2: (env_at_t?(odes, fs, envi, t))): env = env2}"
     hp_expr dL)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (y const-decl "dLVar" flight_turn_example nil)
    (x const-decl "dLVar" flight_turn_example nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (nth def-decl "T" list_props nil)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (ODEs type-eq-decl nil hp_def dL)
    (turn_odes const-decl "ODEs" flight_turn_example nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   shostak))
 (turn_sol_u 0
  (turn_sol_u-1 nil 3882273244
   (""
    (then (skeep) (assert) (lemma " diff_sol_eq_dd") (inst?)
     (spread (split -1)
      ((then (lemma "turn_sol") (skeep) (inst?) (inst -1 "D") (assert)
        (copy -2) (expand "solution_odes_u?" -1) (flatten)
        (spread (inst -2 "fs_r(envi)" "D")
         ((then (assert) (expand "solution_odes_u?" 1) (skeep)
           (expand "solution_odes_u?" -4) (inst -4 "ff" "S") (assert)
           (skeep) (inst -4 "i" "t")
           (spread (inst -2 "i" "t")
            ((assert)
             (then (typepred "t") (typepred "S") (inst -2 "t")
              (assert)))))
          (skeep))))
       (then (assert) (lemma "turn_cont_dd") (inst?))
       (then (lemma "turn_Lip_dd") (inst?)))))
    nil)
   ((null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (dLVar type-decl nil hp_def dL)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (ODEs type-eq-decl nil hp_def dL)
    (turn_odes const-decl "ODEs" flight_turn_example nil)
    (dd? const-decl "bool" hp_expr dL)
    (turn_Lip_dd formula-decl nil flight_turn_example nil)
    (turn_cont_dd formula-decl nil flight_turn_example nil)
    (turn_sol formula-decl nil flight_turn_example nil)
    (solution_odes_u? const-decl "bool" hp_expr dL)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (D skolem-const-decl "(dd?)" flight_turn_example nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (fs_r const-decl "real" flight_turn_example nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (t skolem-const-decl "(S)" flight_turn_example nil)
    (S skolem-const-decl
     "{SS: (dd?) | FORALL (x: real): SS(x) IMPLIES D(x)}"
     flight_turn_example nil)
    (diff_sol_eq_dd formula-decl nil ODEs_equiv dL))
   shostak))
 (fs_st_sol_u_TCC1 0
  (fs_st_sol_u_TCC1-1 nil 3882367332 ("" (then (skeep*) (grind)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil)
    (y const-decl "dLVar" flight_turn_example nil)
    (x const-decl "dLVar" flight_turn_example nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (fs_st_sol_u subtype
    "flight_turn_example.fs_st(flight_turn_example.c, flight_turn_example.envi)"
    "[naturalnumbers.below(list_props[MapExpr].length((: (flight_turn_example.x, hp_def.cnst((number_fields.-)(flight_turn_example.c))), (flight_turn_example.y, hp_def.cnst(0)) :))) -> [real -> real]]")))
 (fs_st_sol_u_TCC2 0
  (fs_st_sol_u_TCC2-1 nil 3882367332
   ("" (then (skeep) (eval-expr 1) (assert)) nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (y const-decl "dLVar" flight_turn_example nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (cnst const-decl "real" hp_def dL)
    (x const-decl "dLVar" flight_turn_example nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (dLVar type-decl nil hp_def dL)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL))
   nil
   (fs_st_sol_u subtype
    "(: (flight_turn_example.x, hp_def.cnst((number_fields.-)(flight_turn_example.c))), (flight_turn_example.y, hp_def.cnst(0)) :)"
    "ODEs")))
 (fs_st_sol_u 0
  (fs_st_sol_u-1 nil 3882367352
   (""
    (then (skeep) (expand "solution_odes_u?")
     (spread
      (case "solution_odes?(D, (: (x, cnst(-c)), (y, cnst(0)) :), envi) (fs_st(c, envi))")
      ((then (assert) (skeep) (skeep) (expand "fs_st" 1)
        (spread (case "i=0")
         ((then (assert) (lemma "solution_odes_sub")
           (inst -1 "D" "(: (x, cnst(-c)), (y, cnst(0)) :)" "envi"
            "fs_st(c,envi)" "S")
           (assert)
           (spread (lemma "derivs_funs_equal[(flight_turn_example.S)]")
            ((spread (case "EXISTS(a,b:(S)): a<b")
              ((then (skeep) (inst -2 "a" "b" "_" "_")
                (spread
                 (inst -2 "LAMBDA(X:(S)):ff(i)(X)"
                  "LAMBDA(X:(S)): envi(dlvar_index(x)) + -c*X")
                 ((spread (split -2)
                   ((then (decompose-equality -1) (inst -1 "t"))
                    (propax)
                    (then (hide 2) (skeep) (expand "solution_odes?" -5)
                     (flatten)
                     (inst -7 "x_1"
                      "env_at_t((:(x,cnst(-c)),(y,cnst(0)):),ff,envi)(x_1)")
                     (expand "sol_at_t?" -7) (inst -7 "i")
                     (expand "restrict" -7) (replace -3)
                     (expand "nth" -7) (expand "cnst" -7) (assert)
                     (replace -7 1 lr) (hide -) (label good 1)
                     (hide good)
                     (deriv
                      "(LAMBDA (p: real): envi(dlvar_index(x)) + -c * p)")
                     (reveal 1)
                     (lemma
                      "deriv_subtype_dd[real,(flight_turn_example.S)]")
                     (inst?)
                     (spread (split -1)
                      ((then (decompose-equality -2)
                        (spread (decompose-equality -2)
                         ((then (inst -1 "x_1") (inst -2 "x_1")
                           (assert) (expand "restrict") (assert))
                          (then (lemma "dd_noe") (inst -1 "S"))
                          (then (lemma "dd_deriv_domain")
                           (inst -1 "S")))))
                       (propax)
                       (then (lemma "dd_deriv_domain") (inst -1 "S"))
                       (then (lemma "dd_noe") (inst -1 "S")))))
                    (spread (inst 1 "0")
                     ((then (expand "solution_odes?" -5) (flatten)
                       (expand "env_at_t?" -6) (inst -6 "i")
                       (expand "nth" -6) (assert))
                      (then (hide -) (hide 2) (typepred "S") (hide -2)
                       (expand "dd?")
                       (spread (split -1)
                        ((then (skeep) (grind)) (grind))))))))
                  (then (hide-all-but 1) (derivable))
                  (then (expand "solution_odes?" -5) (flatten)
                   (expand "derivable_odes?" -5) (inst -5 "i")
                   (expand "restrict" -5) (propax)))))
               (then (hide -) (hide 2) (typepred "S") (hide -2)
                (expand "dd?" -1)
                (spread (split -1)
                 ((then (skeep)
                   (spread (inst 1 "0" "b") ((grind) (grind) (grind))))
                  (spread (inst 1 "0" "1")
                   ((grind) (grind) (grind))))))))
             (then (lemma "dd_noe") (inst -1 "S"))
             (then (lemma "dd_con") (inst -1 "S")))))
          (then (assert)
           (spread (lemma "derivs_funs_equal[(flight_turn_example.S)]")
            ((spread (case "EXISTS(a,b:(S)): a<b")
              ((then (skeep) (inst -2 "a" "b" "_" "_")
                (spread
                 (inst -2 "LAMBDA(X:(S)):ff(i)(X)"
                  "LAMBDA(X:(S)): envi(dlvar_index(y))")
                 ((then (assert)
                   (spread (split -2)
                    ((then (decompose-equality -1) (inst -1 "t"))
                     (then (skeep) (expand "solution_odes?" -3)
                      (flatten)
                      (inst -5 "x!1"
                       "env_at_t((:(x,cnst(-c)),(y,cnst(0)):),ff,envi)(x!1)")
                      (expand "sol_at_t?" -5) (inst -5 "i")
                      (expand "restrict" -5) (replace -5)
                      (expand "nth" 1)
                      (spread (case "i=1")
                       ((then (expand "nth" 1) (assert)
                         (expand "cnst" 1)
                         (spread
                          (lemma
                           "deriv_const[(flight_turn_example.S)]")
                          ((then (inst -1 "envi(dlvar_index(y))" "x!1")
                            (assert) (expand "const_fun" -1) (assert)
                            (expand "deriv" 1) (assert))
                           (then (lemma "dd_deriv_domain")
                            (inst -1 "S")))))
                        (then (hide -) (typepred "i") (hide 2)
                         (grind)))))
                     (spread (inst 1 "0")
                      ((then (expand "solution_odes?" -3) (flatten)
                        (expand "env_at_t?" -4) (inst -4 "i")
                        (replace -4)
                        (spread (case "i=1")
                         ((then (expand "nth" 1) (expand "nth" 1)
                           (assert))
                          (then (hide -) (typepred "i") (grind)))))
                       (then (hide -) (hide 2 3) (typepred "S")
                        (expand "dd?" -1)
                        (spread (split -1) ((grind) (grind)))))))))
                  (spread
                   (lemma "derivable_const[(flight_turn_example.S)]")
                   ((then (inst -1 "envi(dlvar_index(y))")
                     (expand "const_fun" -1) (propax))
                    (then (lemma "dd_deriv_domain") (inst -1 "S"))))
                  (then (expand "solution_odes?" -3) (flatten)
                   (expand "derivable_odes?" -3) (inst -3 "i")
                   (expand "restrict" -3) (propax)))))
               (then (hide -) (typepred "S") (expand "dd?" -1)
                (spread (split -1)
                 ((then (skeep)
                   (spread (inst 1 "0" "b") ((grind) (grind) (grind))))
                  (spread (inst 1 "0" "1")
                   ((then (hide 2 3) (hide -2) (grind)) (grind)
                    (grind))))))))
             (then (lemma "dd_noe") (inst -1 "S"))
             (then (lemma "dd_con") (inst -1 "S"))))))))
       (then (hide 2) (expand "solution_odes?")
        (spread
         (case "derivable_odes?(D, length((: (x, cnst(-c)), (y, cnst(0)) :))) (fs_st(c, envi))")
         ((then (assert)
           (spread (split 1)
            ((then (expand "env_at_t?" 1) (skeep)
              (spread (case "k=0")
               ((then (replace -1) (expand "nth" 1) (expand "fs_st" 1)
                 (propax))
                (spread (case "k=1")
                 ((then (replace -1) (expand "nth" 2)
                   (expand "fs_st" 2) (expand "nth" 2) (propax))
                  (then (typepred "k") (hide -2) (hide 3) (grind)))))))
             (then (skeep) (expand "sol_at_t?" 1) (skeep)
              (spread (case "k=0")
               ((then (replace -1) (expand "restrict" 1)
                 (expand "nth" 1) (expand "cnst" 1) (expand "fs_st" 1)
                 (hide -2) (label "good" 1) (hide good)
                 (deriv
                  "LAMBDA (s: real): envi(dlvar_index(x)) + -c * s")
                 (reveal good) (assert)
                 (lemma "deriv_subtype_dd[real,(D)]") (inst?) (assert)
                 (spread (split -1)
                  ((then (expand "restrict" -1) (decompose-equality -1)
                    (decompose-equality -2) (inst -1 "t") (inst -2 "t")
                    (assert))
                   (then (lemma "dd_deriv_domain") (inst?))
                   (then (lemma "dd_noe") (inst -1 "D")))))
                (then (assert)
                 (spread (case "k=1")
                  ((then (replace -1) (expand "nth" 2) (expand "nth" 2)
                    (expand "cnst" 2) (expand "restrict" 2) (hide -2)
                    (expand "fs_st" 2)
                    (spread (lemma "deriv_const[(D)]")
                     ((then (inst -1 "envi(dlvar_index(y))" "t")
                       (expand "deriv" 2) (assert)
                       (expand "const_fun" -1) (propax))
                      (then (lemma "dd_noe") (inst -1 "D"))
                      (then (lemma "dd_deriv_domain") (inst -1 "D")))))
                   (then (typepred "k") (hide -2 3) (grind)))))))))))
          (then (assert) (hide 2) (expand "derivable_odes?" 1) (skeep)
           (spread (case "k=0")
            ((then (replace -1) (expand "fs_st" 1)
              (expand "restrict" 1) (derivable 1))
             (spread (case "k=1")
              ((then (expand "restrict") (expand "fs_st" 2) (assert)
                (spread (lemma "derivable_const[(D)]")
                 ((then (inst -1 "envi(dlvar_index(y))")
                   (expand "const_fun" -1) (propax))
                  (then (lemma "dd_noe") (inst -1 "D"))
                  (then (lemma "dd_deriv_domain") (inst -1 "D")))))
               (then (typepred "k") (hide 3) (grind))))))))))
       (then (hide 2) (eval-expr 1) (assert))
       (then (hide 2) (skeep) (grind)))))
    nil)
   ((solution_odes_u? const-decl "bool" hp_expr dL)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (solution_odes_sub formula-decl nil ODEs_equiv dL)
    (dd_con formula-decl nil hp_expr dL)
    (derivable_odes? const-decl "bool" hp_expr dL)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sol_at_t? const-decl "bool" hp_expr dL)
    (restrict const-decl "R" restrict nil)
    (nth def-decl "T" list_props nil)
    (dd_deriv_domain formula-decl nil hp_expr dL)
    (dd_noe formula-decl nil hp_expr dL)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (deriv_subtype_dd formula-decl nil derivatives_subtype analysis)
    (deriv_id_lam formula-decl nil derivatives_lam analysis)
    (deriv_const_lam formula-decl nil derivatives_lam analysis)
    (deriv_add_lam formula-decl nil derivatives_lam analysis)
    (deriv_scal1_lam formula-decl nil derivatives_lam analysis)
    (deriv const-decl "[T -> real]" derivatives analysis)
    (derivable_add_lam formula-decl nil derivatives_lam analysis)
    (derivable_id_lam formula-decl nil derivatives_lam analysis)
    (derivable_scal1_lam formula-decl nil derivatives_lam analysis)
    (derivable_const_lam formula-decl nil derivatives_lam analysis)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (deriv_domain? const-decl "bool" deriv_domain_def analysis)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (not_one_element formula-decl nil integral_split analysis)
    (deriv_domain_real formula-decl nil deriv_domain analysis)
    (TRUE const-decl "bool" booleans nil)
    (minus_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (pi_bound name-judgement
     "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig)
    (env_at_t? const-decl "bool" hp_expr dL)
    (env_at_t const-decl
     "{env: (env_at_t?(odes, fs, envi, t)) | FORALL (env2: (env_at_t?(odes, fs, envi, t))): env = env2}"
     hp_expr dL)
    (hp const-decl "bool" interval_def ODEs)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (closed_interval const-decl "(closed_interval?(a, b))" interval_def
     ODEs)
    (deriv_fun type-eq-decl nil derivatives analysis)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (derivable? const-decl "bool" derivatives analysis)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (connected? const-decl "bool" deriv_domain_def analysis)
    (derivs_funs_equal formula-decl nil derivative_props analysis)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (deriv_const formula-decl nil derivatives_def analysis)
    (constant_seq1 application-judgement "(convergent?)"
     convergence_ops analysis)
    (const_fun const-decl "[T -> real]" real_fun_ops reals)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (derivable_const judgement-tcc nil derivatives analysis)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (minus_real_is_real application-judgement "real" reals nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (dd? const-decl "bool" hp_expr dL)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (ODEs type-eq-decl nil hp_def dL) (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (solution_odes? const-decl "bool" hp_expr dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (x const-decl "dLVar" flight_turn_example nil)
    (cnst const-decl "real" hp_def dL)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (y const-decl "dLVar" flight_turn_example nil)
    (fs_st const-decl "real" flight_turn_example nil))
   shostak))
 (dyn_equiv 0
  (dyn_equiv-1 nil 3882203946
   (""
    (then (skeep) (expand "dyn_tr") (expand "dyn") (expand "b1_tr")
     (expand "b1") (expand "b2") (expand "straight")
     (spread (split 1)
      ((then (flatten) (skeep) (expand "semantic_rel") (flatten)
        (spread (split -1)
         ((then (expand "semantic_rel") (skeep) (expand "turn_tr" -2)
           (expand "turn")
           (inst 1 "env WITH [theta := ei(dlvar_index(theta))]")
           (spread (split 1)
            ((then (hide 2) (hide -2) (expand "semantic_rel") (flatten)
              (eval-expr "theta = x") (assert) (expand "val" -1)
              (expand ">") (expand "cnst") (assert) (expand "val" 2)
              (propax))
             (then (hide 2) (expand "semantic_rel") (flatten) (skeep)
              (inst 1 "D") (expand "semantic_rel_diff") (skeep) (skeep)
              (typepred "fs") (lemma "turn_tr_sol_u") (inst?) (copy -1)
              (expand "solution_odes_u?" -1) (flatten)
              (spread (inst -2 "fs" "D")
               ((then (assert) (expand "solution_odes_u?" -4) (flatten)
                 (assert) (hide -4 -5) (hide -1) (lemma "turn_sol_u")
                 (inst -1 "D"
                  "env WITH [ theta := ei(dlvar_index(theta))]")
                 (lemma "fs_tr_r_equiv") (inst -1 "ei" "c") (assert)
                 (flatten)
                 (spread
                  (inst 1 "r_1"
                   "fs_r(env WITH [theta := ei(dlvar_index(theta))])")
                  ((spread (split 1)
                    ((then (expand "env_at_t?" 1)
                      (expand "env_at_t?" -8) (flatten)
                      (spread (split 1)
                       ((then (skeep)
                         (spread (case "i= theta")
                          ((assert)
                           (then (assert)
                            (spread (inst -8 "i")
                             ((then (typepred "i") (replace -9 2)
                               (assert))
                              (then (expand "turn_tr_odes" 1)
                               (hide-all-but (-1 1 2)) (typepred "i")
                               (hide -2) (expand "not_in_map") (skeep)
                               (spread
                                (case "i_1 = 2")
                                ((then
                                  (expand "nth" -3)
                                  (expand "nth" -3)
                                  (assert)
                                  (expand "nth" -3)
                                  (assert))
                                 (spread
                                  (inst -1 "i_1")
                                  ((spread
                                    (case "i_1=0")
                                    ((then
                                      (replace -1)
                                      (expand "nth")
                                      (propax))
                                     (then
                                      (assert)
                                      (expand "nth")
                                      (spread
                                       (case "i_1=1")
                                       ((then
                                         (replace -1)
                                         (expand "nth")
                                         (propax))
                                        (then
                                         (assert)
                                         (typepred "i_1")
                                         (hide -2 4 5)
                                         (grind)))))))
                                   (then
                                    (expand "length" 1)
                                    (expand "length" 1)
                                    (expand "length" 1)
                                    (assert)
                                    (typepred "i_1")
                                    (hide -2)
                                    (expand "length" -1)
                                    (expand "length" -1)
                                    (expand "length" -1)
                                    (expand "length" -1)
                                    (assert)))))))))))))
                        (then (skeep) (typepred "k")
                         (spread (case "k=0")
                          ((spread (inst -11 "0")
                            ((then (expand "nth" -11)
                              (expand "turn_tr_odes" -11) (replace -1)
                              (spread
                               (case
                                "ei = env WITH [theta := ei(dlvar_index(theta))]")
                               ((then
                                 (decompose-equality -4)
                                 (inst -1 "r_1")
                                 (assert)
                                 (inst -7 "0" "r_1")
                                 (assert)
                                 (expand "nth" 1 1)
                                 (spread
                                  (case "NOT x = theta")
                                  ((then
                                    (assert)
                                    (replace -12 2 rl)
                                    (replace -7 2 lr)
                                    (replace -10 -1 rl)
                                    (replace -1 2)
                                    (replace -2 2 rl)
                                    (propax))
                                   (then (eval-expr -1) (assert)))))
                                (assert))))
                             (then (hide-all-but 1) (grind))))
                           (spread (case "k=1")
                            ((then (replace -1)
                              (spread
                               (case
                                "ei = env WITH [theta := ei(dlvar_index(theta))]")
                               ((spread
                                 (inst -7 "1" "r_1")
                                 ((then
                                   (inst -12 "1")
                                   (expand "turn_tr_odes" -12)
                                   (expand "nth" -12)
                                   (expand "nth" -12)
                                   (expand "nth" 2)
                                   (expand "nth" 2)
                                   (spread
                                    (case "NOT y = theta")
                                    ((then
                                      (assert)
                                      (replace -1 3 rl)
                                      (replace -5 3 rl)
                                      (replace -10 3 rl)
                                      (assert))
                                     (then (eval-expr -1) (assert)))))
                                  (then (hide-all-but 1) (grind))))
                                (assert))))
                             (then (hide-all-but (1 2 -1))
                              (grind))))))))))
                     (then (skeep) (typepred "env_1")
                      (spread
                       (inst -10 "t"
                        "env_1 WITH [theta := fs_tr(ei WITH [theta := 0], c)(2)(t)]")
                       ((then (hide-all-but (-10 1)) (expand ">=" 1)
                         (expand ">=") (expand "val") (expand "cnst")
                         (assert)
                         (spread (case "NOT x = theta")
                          ((assert) (then (eval-expr -1) (assert)))))
                        (then (expand "env_at_t?") (flatten)
                         (spread (split 1)
                          ((then (skeep)
                            (spread (inst -1 "i")
                             ((then (assert)
                               (spread
                                (case "NOT i = theta")
                                ((assert)
                                 (then
                                  (typepred "i")
                                  (expand "turn_tr_odes" -1)
                                  (expand "not_in_map" -1)
                                  (spread
                                   (inst -1 "2")
                                   ((then
                                     (expand "nth" -1)
                                     (assert)
                                     (expand "nth" 1)
                                     (expand "nth" 1)
                                     (assert))
                                    (then
                                     (expand "length" 1)
                                     (expand "length" 1)
                                     (expand "length" 1)
                                     (expand "length" 1)
                                     (assert))))))))
                              (then (typepred "i")
                               (hide-all-but (-1 1))
                               (expand "not_in_map") (skeep)
                               (expand "turn_tr_odes") (typepred "i_1")
                               (expand "length" -1)
                               (expand "length" -1)
                               (expand "length" -1)
                               (spread
                                (inst -2 "i_1")
                                ((spread
                                  (case "i_1=0")
                                  ((grind) (grind)))
                                 (then (hide -2) (grind))))))))
                           (then (skeep)
                            (spread (case "k=2")
                             ((spread (inst -7 "2" "t")
                               ((then
                                 (replace -1)
                                 (replace -7 1)
                                 (expand "nth" 1)
                                 (expand "turn_tr_odes" 1)
                                 (expand "nth" 1)
                                 (expand "nth" 1)
                                 (assert))
                                (then
                                 (expand "turn_tr_odes" 1)
                                 (hide-all-but (1))
                                 (grind))))
                              (spread (case "k=0")
                               ((then
                                 (replace -1)
                                 (expand "turn_tr_odes" 2)
                                 (expand "nth" 2)
                                 (spread
                                  (case "NOT theta = x")
                                  ((then
                                    (assert)
                                    (typepred "env_1")
                                    (expand "env_at_t?" -1)
                                    (flatten)
                                    (spread
                                     (inst -2 "0")
                                     ((then
                                       (expand "nth" -2)
                                       (replace -2 3 rl)
                                       (inst -9 "0" "t")
                                       (decompose-equality -6)
                                       (inst -1 "t")
                                       (spread
                                        (case
                                         "ei = env WITH [theta := ei(dlvar_index(theta))]")
                                        ((then
                                          (assert)
                                          (replace -10 3)
                                          (replace -1 3 rl)
                                          (replace -13 3)
                                          (propax))
                                         (assert))))
                                      (then
                                       (hide-all-but (1))
                                       (grind)))))
                                   (then
                                    (assert)
                                    (eval-expr -1)
                                    (assert)))))
                                (spread
                                 (case "k=1")
                                 ((then
                                   (replace -1)
                                   (expand "turn_tr_odes" 3)
                                   (expand "nth" 3)
                                   (expand "nth" 3)
                                   (spread
                                    (case "NOT theta = y")
                                    ((then
                                      (assert)
                                      (spread
                                       (inst -3 "1")
                                       ((then
                                         (expand "nth" -3)
                                         (expand "nth" -3)
                                         (replace -3 4 rl)
                                         (inst -7 "1" "t")
                                         (replace -7 4 lr)
                                         (spread
                                          (case
                                           "ei = env WITH [theta := ei(dlvar_index(theta))]")
                                          ((then
                                            (replace -1 4 rl)
                                            (replace -11 4)
                                            (assert))
                                           (assert))))
                                        (then
                                         (hide-all-but 1)
                                         (grind)))))
                                     (then (eval-expr -1) (assert)))))
                                  (then
                                   (assert)
                                   (hide -)
                                   (typepred "k")
                                   (hide 4 5)
                                   (grind)))))))))))))))))
                   (spread (split 1)
                    ((then (skeep) (hide-all-but 1) (grind))
                     (then (expand "turn_odes" -3) (propax)))))))
                (then (hide 2) (skeep))))))))
          (then (expand "semantic_rel" -1) (skeep)
           (expand "semantic_rel" -1) (flatten) (expand "<=" -1)
           (expand "val" -1) (expand "cnst" -1) (assert)
           (spread (case "NOT x = theta")
            ((assert) (then (eval-expr -1) (assert))))))))
       (then (flatten) (expand "semantic_rel")
        (spread (split -1)
         ((then (expand "semantic_rel" -1) (skeep) (expand "turn")
           (expand "semantic_rel" -2) (skeep)
           (expand "semantic_rel_diff" -2) (skeep*) (inst 1 "r")
           (flatten) (hide 2) (expand "semantic_rel")
           (inst 1 "env WITH [theta:= 0]") (assert)
           (spread (split 1)
            ((then (hide -2) (expand "semantic_rel")
              (spread (split 1)
               ((then (flatten) (grind)) (then (flatten) (assert)))))
             (then (expand "turn_tr" 1) (expand "turn_tr_odes")
              (expand "semantic_rel") (flatten) (expand ">" -1)
              (expand "cnst" -1) (expand "val" -1) (lemma "turn_sol_u")
              (inst?) (expand "turn_odes" -1) (inst -1 "env") (copy -1)
              (expand "solution_odes_u?" -1) (flatten)
              (spread (inst -2 "fs" "D")
               ((then (assert) (hide -4 -5) (hide -1)
                 (lemma "turn_tr_sol_u")
                 (inst -1 "c" "D" "env WITH [ theta := 0]")
                 (lemma "fs_tr_r_equiv") (inst -1 "ei" "c") (assert)
                 (flatten) (expand "turn_tr_odes" -3) (inst 1 "D")
                 (expand "semantic_rel_diff" 1)
                 (inst 1 "r" "fs_tr(env WITH [theta := 0],c)")
                 (spread (split 1)
                  ((then (expand "env_at_t?" 1) (expand "env_at_t?" -6)
                    (flatten)
                    (spread (split 1)
                     ((then (skeep) (typepred "i")
                       (spread (case "i= theta")
                        ((then (expand "not_in_map" -2)
                          (spread (inst -2 "2")
                           ((then (expand "nth" -2) (expand "nth" 1)
                             (expand "nth" 1) (assert))
                            (then (expand "length" 1)
                             (expand "length" 1) (expand "length" 1)
                             (expand "length" 1) (assert)))))
                         (then (assert)
                          (spread (inst -7 "i")
                           ((assert)
                            (then (hide-all-but (-1 1))
                             (expand "not_in_map") (skeep)
                             (spread (inst -2 "i_1")
                              ((spread
                                (case "i_1=0")
                                ((then (expand "nth") (assert))
                                 (spread
                                  (case "i_1=1")
                                  ((then
                                    (replace -1)
                                    (expand "nth" -)
                                    (assert)
                                    (expand "nth")
                                    (propax))
                                   (then
                                    (assert)
                                    (typepred "i_1")
                                    (hide -2 -3)
                                    (expand "length" -1)
                                    (expand "length" -1)
                                    (expand "length" -1)
                                    (assert))))))
                               (then
                                (expand "length" 1)
                                (typepred "i_1")
                                (hide -2)
                                (grind)))))))))))
                      (then (skeep)
                       (spread (case "k=0")
                        ((spread (inst -8 "0")
                          ((then (replace -1) (expand "nth" 1)
                            (expand "nth " -8)
                            (spread (case "NOT x = theta")
                             ((then (assert) (replace -8 2 rl)
                               (typepred "fs")
                               (expand "solution_odes_u?" -1) (flatten)
                               (assert) (hide -1 -2) (inst -5 "0" "r")
                               (replace -5 2) (decompose-equality -2)
                               (inst -1 "r") (assert))
                              (then (eval-expr -1) (assert)))))
                           (then (hide-all-but (1)) (grind))))
                         (then (typepred "fs")
                          (expand "solution_odes_u?" -1) (flatten)
                          (assert) (hide -2) (hide -1)
                          (spread (case "k=1")
                           ((then (replace -1) (expand "nth" 2)
                             (expand "nth" 2) (reveal -1)
                             (spread (inst -9 "1")
                              ((then
                                (expand "nth" -9)
                                (expand "nth" -9)
                                (spread
                                 (case "NOT y = theta")
                                 ((then
                                   (assert)
                                   (replace -9 3 rl)
                                   (inst -6 "1" "r")
                                   (assert))
                                  (then (eval-expr -1) (assert)))))
                               (then (hide-all-but (1)) (grind)))))
                            (spread (case "k=2")
                             ((then (expand "nth" 3) (assert)
                               (expand "nth" 3) (expand "nth" 3)
                               (expand "fs_tr" 3) (propax))
                              (then (hide -) (hide 4) (typepred "k")
                               (grind)))))))))))))
                   (then (skeep) (typepred "fs")
                    (expand "solution_odes_u?" -1) (flatten) (assert)
                    (typepred "env_1")
                    (spread
                     (inst -10 "t"
                      "env_1 WITH [theta := ei(dlvar_index(theta))]")
                     ((then (hide-all-but (-10 1)) (expand ">=" 1)
                       (expand ">=") (expand "val") (expand "cnst")
                       (assert)
                       (spread (case "NOT x = theta")
                        ((assert) (then (eval-expr -1) (assert)))))
                      (then (expand "env_at_t?") (flatten)
                       (spread (split 1)
                        ((then (skeep)
                          (spread (case "i = theta")
                           ((assert)
                            (spread (inst -1 "i")
                             ((assert)
                              (then (typepred "i")
                               (hide-all-but (-1 1 2))
                               (expand "not_in_map") (skeep)
                               (spread
                                (case "i_1 = 2")
                                ((then
                                  (expand "nth" -3)
                                  (assert)
                                  (expand "nth" -3)
                                  (assert)
                                  (expand "nth" -3)
                                  (assert))
                                 (spread
                                  (case "i_1=0")
                                  ((spread
                                    (inst -2 "0")
                                    ((then (expand "nth") (assert))
                                     (then
                                      (expand "length" 1)
                                      (assert))))
                                   (spread
                                    (case "i_1=1")
                                    ((then
                                      (replace -1)
                                      (spread
                                       (inst -2 "1")
                                       ((then
                                         (expand "nth")
                                         (expand "nth")
                                         (propax))
                                        (then
                                         (expand "nth")
                                         (expand "nth")
                                         (assert)
                                         (grind)))))
                                     (then
                                      (typepred "i_1")
                                      (hide -2 -3)
                                      (grind))))))))))))))
                         (then (skeep)
                          (spread (case "k=0")
                           ((then (replace -1) (expand "nth" 1)
                             (spread (case "NOT theta = x")
                              ((then
                                (assert)
                                (spread
                                 (inst -3 "0")
                                 ((then
                                   (expand "nth" -3)
                                   (replace -3 2 rl)
                                   (inst -9 "0" "t")
                                   (decompose-equality -6)
                                   (inst -1 "t")
                                   (spread
                                    (case
                                     "ei = env WITH [theta := ei(dlvar_index(theta))]")
                                    ((assert)
                                     (then (replace -9 3) (assert)))))
                                  (then
                                   (expand "length" 1)
                                   (expand "length" 1)
                                   (assert)))))
                               (then (eval-expr -1) (assert)))))
                            (spread (case "k=1")
                             ((then (replace -1)
                               (spread
                                (case "NOT theta = y")
                                ((then
                                  (assert)
                                  (spread
                                   (inst -3 "1")
                                   ((then
                                     (expand "nth" -3)
                                     (expand "nth" -3)
                                     (expand "nth" 3)
                                     (expand "nth" 3)
                                     (replace -3 3 rl)
                                     (decompose-equality -7)
                                     (inst -1 "t")
                                     (assert)
                                     (typepred "fs")
                                     (inst -10 "1" "t")
                                     (replace -10 3)
                                     (assert))
                                    (then
                                     (expand "length" 1)
                                     (assert)
                                     (expand "length" 1)
                                     (assert)))))
                                 (then (eval-expr -1) (assert)))))
                              (then (typepred "k") (expand "length" -1)
                               (expand "length" -1)
                               (expand "length" -1)
                               (assert))))))))))))))))
                (skeep)))))))
          (then (assert) (hide 1) (expand "semantic_rel") (skeep)
           (expand "semantic_rel") (hide -2) (grind))))))))
    nil)
   ((dyn_tr const-decl "HP" flight_turn_example nil)
    (b1_tr const-decl "HP" flight_turn_example nil)
    (b2 const-decl "HP" flight_turn_example nil)
    (<= const-decl "BoolExpr" bool_expr dL)
    (minus_real_is_real application-judgement "real" reals nil)
    (turn_tr const-decl "HP" flight_turn_example nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (theta const-decl "dLVar" flight_turn_example nil)
    (dd? const-decl "bool" hp_expr dL)
    (turn_tr_odes const-decl "ODEs" flight_turn_example nil)
    (solution_odes_u? const-decl "bool" hp_expr dL)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil) (ODEs type-eq-decl nil hp_def dL)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (turn_odes const-decl "ODEs" flight_turn_example nil)
    (MapExprInj type-eq-decl nil hp_def dL)
    (not_in_map const-decl "bool" hp_def dL)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nth def-decl "T" list_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (cos_re const-decl "real" flight_turn_example nil)
    (sin_re const-decl "real" flight_turn_example nil)
    (fs_tr const-decl "real" flight_turn_example nil)
    (minus_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (pi_bound name-judgement
     "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig)
    (env_at_t? const-decl "bool" hp_expr dL)
    (<= const-decl "bool" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (>= const-decl "BoolExpr" bool_expr dL)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (y const-decl "dLVar" flight_turn_example nil)
    (fs_r const-decl "real" flight_turn_example nil)
    (fs_tr_r_equiv formula-decl nil flight_turn_example nil)
    (turn_sol_u formula-decl nil flight_turn_example nil)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (turn_tr_sol_u formula-decl nil flight_turn_example nil)
    (semantic_rel_diff const-decl "bool" hp_expr dL)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (x const-decl "dLVar" flight_turn_example nil)
    (FALSE const-decl "bool" booleans nil)
    (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (> const-decl "BoolExpr" bool_expr dL)
    (> const-decl "bool" reals nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (turn const-decl "HP" flight_turn_example nil)
    (semantic_rel inductive-decl "bool" hp_expr dL)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (length_singleton formula-decl nil more_list_props structures)
    (straight const-decl "HP" flight_turn_example nil)
    (b1 const-decl "HP" flight_turn_example nil)
    (dyn const-decl "HP" flight_turn_example nil))
   shostak))
 (b_star_dyn 0
  (b_star_dyn-1 nil 3882191872
   (""
    (spread (induct "k")
     ((then (skeep) (expand "BSTAR" 1) (expand "semantic_rel" 1)
       (expand "DLBOOL" 1) (assert)
       (spread (split)
        ((then (flatten) (assert)) (then (flatten) (assert)))))
      (then (skeep) (skeep) (expand "BSTAR" 1)
       (expand "semantic_rel" 1 1)
       (spread (split 1)
        ((then (flatten)
          (spread (split -1)
           ((then (assert)
             (spread (case "eo(dlvar_index(x)) >=0")
              ((then (assert)
                (lemma "semantic_rel_bounded_star_seq_switch") (inst?)
                (assert) (hide -3) (expand "semantic_rel" -1) (skeep)
                (inst -4 "c" "ei" "env") (assert)
                (spread (case "ei= env")
                 ((then (assert) (expand "dyn" -3)
                   (expand "semantic_rel" -3)
                   (spread (split -3)
                    ((then (expand "b1" -1) (expand "semantic_rel" -1)
                      (skeep)
                      (spread (case "env_1=env")
                       ((assert)
                        (then (expand "semantic_rel" -1) (flatten)))))
                     (then (assert) (expand "b2" -1)
                      (expand "semantic_rel" -1) (skeep) (hide 2)
                      (hide -2) (hide -5) (expand "semantic_rel" -1)
                      (grind)))))
                  (then (assert)
                   (spread (case "j=0")
                    ((assert)
                     (then (assert)
                      (spread (split -4)
                       ((then (flatten) (assert) (expand "dyn" -4)
                         (expand "semantic_rel" -4)
                         (spread (split -4)
                          ((then (expand "b1" -1)
                            (expand "semantic_rel" -1) (skeep) (assert)
                            (expand "semantic_rel" -1) (flatten)
                            (assert) (replace -2) (hide -6)
                            (expand "turn") (expand "semantic_rel")
                            (skeep*)
                            (spread (inst 4 "hp(0)")
                             ((then (expand "semantic_rel_diff" 4)
                               (expand "semantic_rel_diff" -) (skeep*)
                               (typepred "fs" "fs!1")
                               (spread
                                (inst 4 "r+r!1")
                                ((then
                                  (lemma "turn_sol_u")
                                  (spread
                                   (inst -1 "hp(0)" "ei")
                                   ((spread
                                     (inst 4 "fs_r(ei)")
                                     ((then
                                       (expand "solution_odes_u?" -1)
                                       (flatten)
                                       (spread
                                        (inst -2 "fs!1" "D!1")
                                        ((then
                                          (assert)
                                          (expand "turn_odes" -2 1)
                                          (spread
                                           (split -2)
                                           ((then
                                             (lemma "turn_sol_u")
                                             (inst -1 "hp(0)" "env")
                                             (expand
                                              "solution_odes_u?"
                                              -1)
                                             (flatten)
                                             (spread
                                              (inst -2 "fs" "D")
                                              ((then
                                                (assert)
                                                (spread
                                                 (split -2)
                                                 ((spread
                                                   (split 4)
                                                   ((then
                                                     (expand
                                                      "env_at_t?"
                                                      1)
                                                     (spread
                                                      (split 1)
                                                      ((then
                                                        (skeep)
                                                        (typepred "i")
                                                        (expand
                                                         "env_at_t?"
                                                         -10)
                                                        (expand
                                                         "env_at_t?"
                                                         -13)
                                                        (flatten)
                                                        (inst -14 "i")
                                                        (inst -10 "i")
                                                        (assert))
                                                       (then
                                                        (skeep)
                                                        (expand
                                                         "env_at_t?"
                                                         -9)
                                                        (flatten)
                                                        (inst -10 "k")
                                                        (replace
                                                         -10
                                                         1
                                                         rl)
                                                        (spread
                                                         (inst
                                                          -1
                                                          "k"
                                                          "r")
                                                         ((then
                                                           (replace
                                                            -1
                                                            1)
                                                           (spread
                                                            (case
                                                             "k=0")
                                                            ((then
                                                              (replace
                                                               -1)
                                                              (expand
                                                               "fs_r"
                                                               1)
                                                              (assert)
                                                              (expand
                                                               "env_at_t?"
                                                               -14)
                                                              (flatten)
                                                              (inst-cp
                                                               -15
                                                               "0")
                                                              (expand
                                                               "nth"
                                                               -16)
                                                              (replace
                                                               -16
                                                               1
                                                               rl)
                                                              (spread
                                                               (inst-cp
                                                                -4
                                                                "0"
                                                                "r!1")
                                                               ((then
                                                                 (replace
                                                                  -5
                                                                  1)
                                                                 (expand
                                                                  "fs_r"
                                                                  1)
                                                                 (assert)
                                                                 (spread
                                                                  (inst
                                                                   -16
                                                                   "1")
                                                                  ((then
                                                                    (expand
                                                                     "nth"
                                                                     -16)
                                                                    (expand
                                                                     "nth"
                                                                     -16)
                                                                    (replace
                                                                     -16
                                                                     1
                                                                     rl)
                                                                    (spread
                                                                     (inst
                                                                      -4
                                                                      "1"
                                                                      "r!1")
                                                                     ((then
                                                                       (replace
                                                                        -4)
                                                                       (expand
                                                                        "fs_r"
                                                                        1)
                                                                       (assert)
                                                                       (lemma
                                                                        " cos_plus")
                                                                       (inst?)
                                                                       (replace
                                                                        -1)
                                                                       (lemma
                                                                        "sin_plus")
                                                                       (inst?)
                                                                       (replace
                                                                        -1)
                                                                       (assert))
                                                                      (then
                                                                       (expand
                                                                        "turn_odes"
                                                                        1)
                                                                       (expand
                                                                        "length"
                                                                        1)
                                                                       (assert)))))
                                                                   (then
                                                                    (expand
                                                                     "length"
                                                                     1)
                                                                    (assert)))))
                                                                (then
                                                                 (hide-all-but
                                                                  1)
                                                                 (grind)))))
                                                             (spread
                                                              (case
                                                               "k=1")
                                                              ((then
                                                                (replace
                                                                 -1)
                                                                (expand
                                                                 "fs_r"
                                                                 2)
                                                                (expand
                                                                 "env_at_t?"
                                                                 -14)
                                                                (flatten)
                                                                (inst-cp
                                                                 -15
                                                                 "0")
                                                                (inst
                                                                 -15
                                                                 "1")
                                                                (expand
                                                                 "nth"
                                                                 -15)
                                                                (expand
                                                                 "nth"
                                                                 -15)
                                                                (expand
                                                                 "nth"
                                                                 -16)
                                                                (replace
                                                                 -15
                                                                 2
                                                                 rl)
                                                                (replace
                                                                 -16
                                                                 2
                                                                 rl)
                                                                (spread
                                                                 (inst-cp
                                                                  -4
                                                                  "1"
                                                                  "r!1")
                                                                 ((spread
                                                                   (inst
                                                                    -4
                                                                    "0"
                                                                    "r!1")
                                                                   ((then
                                                                     (replace
                                                                      -4
                                                                      2)
                                                                     (replace
                                                                      -5
                                                                      2)
                                                                     (expand
                                                                      "fs_r"
                                                                      2)
                                                                     (lemma
                                                                      "sin_plus")
                                                                     (lemma
                                                                      "cos_plus")
                                                                     (inst?)
                                                                     (inst?)
                                                                     (replace
                                                                      -1)
                                                                     (replace
                                                                      -2)
                                                                     (assert))
                                                                    (then
                                                                     (hide-all-but
                                                                      1)
                                                                     (grind))))
                                                                  (then
                                                                   (hide-all-but
                                                                    1)
                                                                   (grind)))))
                                                               (then
                                                                (hide-all-but
                                                                 (1 2))
                                                                (typepred
                                                                 "k")
                                                                (grind)))))))
                                                          (then
                                                           (hide-all-but
                                                            1)
                                                           (typepred
                                                            "k")
                                                           (grind))))))))
                                                    (then
                                                     (skeep)
                                                     (typepred "t")
                                                     (spread
                                                      (case "t<= r!1")
                                                      ((spread
                                                        (inst
                                                         -16
                                                         "t"
                                                         "env!1")
                                                        ((then
                                                          (expand
                                                           "env_at_t?"
                                                           1)
                                                          (spread
                                                           (split 1)
                                                           ((then
                                                             (typepred
                                                              "env!1")
                                                             (expand
                                                              "env_at_t?"
                                                              -1)
                                                             (flatten))
                                                            (then
                                                             (typepred
                                                              "env!1")
                                                             (expand
                                                              " env_at_t?"
                                                              -1)
                                                             (flatten)
                                                             (skeep)
                                                             (inst
                                                              -2
                                                              "k")
                                                             (replace
                                                              -2
                                                              1
                                                              rl)
                                                             (spread
                                                              (inst
                                                               -8
                                                               "k"
                                                               "t")
                                                              ((then
                                                                (assert)
                                                                (typepred
                                                                 "r!1")
                                                                (hide-all-but
                                                                 (-1
                                                                  -4
                                                                  1))
                                                                (typepred
                                                                 "D!1")
                                                                (expand
                                                                 "dd?"
                                                                 -1)
                                                                (skeep)
                                                                (grind)
                                                                (grind)
                                                                (typepred
                                                                 "t")
                                                                (expand
                                                                 "hp"
                                                                 -1)
                                                                (assert))
                                                               (then
                                                                (hide-all-but
                                                                 1)
                                                                (typepred
                                                                 "k")
                                                                (grind))))))))
                                                         (then
                                                          (assert)
                                                          (hide-all-but
                                                           (-1
                                                            -2
                                                            -3
                                                            1))
                                                          (typepred
                                                           "r!1")
                                                          (expand "hp")
                                                          (typepred
                                                           "D!1")
                                                          (expand
                                                           "dd?"
                                                           -1)
                                                          (skeep)
                                                          (grind))))
                                                       (then
                                                        (assert)
                                                        (spread
                                                         (inst
                                                          -12
                                                          "t-r!1"
                                                          "env!1")
                                                         ((then
                                                           (expand
                                                            "env_at_t?"
                                                            1)
                                                           (typepred
                                                            "env!1")
                                                           (expand
                                                            "env_at_t?"
                                                            -1)
                                                           (flatten)
                                                           (assert)
                                                           (spread
                                                            (split 1)
                                                            ((then
                                                              (skeep)
                                                              (inst
                                                               -1
                                                               "i")
                                                              (replace
                                                               -1
                                                               1
                                                               rl)
                                                              (expand
                                                               "env_at_t?"
                                                               -15)
                                                              (flatten)
                                                              (inst
                                                               -15
                                                               "i")
                                                              (assert))
                                                             (then
                                                              (skeep)
                                                              (inst
                                                               -2
                                                               "k")
                                                              (replace
                                                               -2
                                                               1
                                                               rl)
                                                              (spread
                                                               (inst
                                                                -5
                                                                "k"
                                                                "t-r!1")
                                                               ((then
                                                                 (replace
                                                                  -5)
                                                                 (spread
                                                                  (case
                                                                   "k=0")
                                                                  ((then
                                                                    (expand
                                                                     "fs_r"
                                                                     1)
                                                                    (assert)
                                                                    (expand
                                                                     "env_at_t?"
                                                                     -16)
                                                                    (flatten)
                                                                    (inst-cp
                                                                     -17
                                                                     "0")
                                                                    (spread
                                                                     (inst
                                                                      -17
                                                                      "1")
                                                                     ((then
                                                                       (expand
                                                                        "nth"
                                                                        -17)
                                                                       (expand
                                                                        "nth"
                                                                        -17)
                                                                       (expand
                                                                        "nth"
                                                                        -18)
                                                                       (replace
                                                                        -17
                                                                        1
                                                                        rl)
                                                                       (replace
                                                                        -18
                                                                        1
                                                                        rl)
                                                                       (spread
                                                                        (inst-cp
                                                                         -8
                                                                         "0"
                                                                         "r!1")
                                                                        ((spread
                                                                          (inst
                                                                           -8
                                                                           "1"
                                                                           "r!1")
                                                                          ((then
                                                                            (replace
                                                                             -8
                                                                             1)
                                                                            (replace
                                                                             -9
                                                                             1)
                                                                            (expand
                                                                             "fs_r"
                                                                             1)
                                                                            (assert)
                                                                            (lemma
                                                                             "cos_minus")
                                                                            (lemma
                                                                             "sin_minus")
                                                                            (inst?)
                                                                            (inst?)
                                                                            (replace
                                                                             -1)
                                                                            (replace
                                                                             -2)
                                                                            (assert)
                                                                            (spread
                                                                             (case
                                                                              "cos(r!1) * cos(r!1) * cos(t) * ei(dlvar_index(x)) + cos(t) * ei(dlvar_index(x)) * sin(r!1) * sin(r!1) = cos(t)*ei(dlvar_index(x))")
                                                                             ((assert)
                                                                              (then
                                                                               (hide
                                                                                2)
                                                                               (lemma
                                                                                "sin_cos_one ")
                                                                               (inst
                                                                                -1
                                                                                "r!1")
                                                                               (assert)))))
                                                                           (then
                                                                            (hide-all-but
                                                                             1)
                                                                            (grind))))
                                                                         (then
                                                                          (hide-all-but
                                                                           1)
                                                                          (grind)))))
                                                                      (then
                                                                       (hide-all-but
                                                                        1)
                                                                       (grind)))))
                                                                   (spread
                                                                    (case
                                                                     "k=1")
                                                                    ((then
                                                                      (replace
                                                                       -1)
                                                                      (expand
                                                                       "fs_r"
                                                                       2)
                                                                      (lemma
                                                                       "cos_minus")
                                                                      (lemma
                                                                       "sin_minus")
                                                                      (inst?)
                                                                      (inst?)
                                                                      (replace
                                                                       -1)
                                                                      (replace
                                                                       -2)
                                                                      (expand
                                                                       "env_at_t?"
                                                                       -18)
                                                                      (flatten)
                                                                      (inst-cp
                                                                       -19
                                                                       "0")
                                                                      (inst
                                                                       -19
                                                                       "1")
                                                                      (expand
                                                                       "nth"
                                                                       -19)
                                                                      (expand
                                                                       "nth"
                                                                       -19)
                                                                      (expand
                                                                       "nth"
                                                                       -20)
                                                                      (replace
                                                                       -19
                                                                       2
                                                                       rl)
                                                                      (replace
                                                                       -20
                                                                       2
                                                                       rl)
                                                                      (spread
                                                                       (inst-cp
                                                                        -10
                                                                        "0"
                                                                        "r!1")
                                                                       ((spread
                                                                         (inst
                                                                          -10
                                                                          "1"
                                                                          "r!1")
                                                                         ((then
                                                                           (replace
                                                                            -10
                                                                            2)
                                                                           (replace
                                                                            -11
                                                                            2)
                                                                           (expand
                                                                            "fs_r"
                                                                            2)
                                                                           (assert)
                                                                           (lemma
                                                                            "sin_cos_one ")
                                                                           (inst
                                                                            -1
                                                                            "r!1")
                                                                           (assert))
                                                                          (then
                                                                           (hide-all-but
                                                                            1)
                                                                           (grind))))
                                                                        (then
                                                                         (hide-all-but
                                                                          1)
                                                                         (grind)))))
                                                                     (then
                                                                      (typepred
                                                                       "k")
                                                                      (hide-all-but
                                                                       (-1
                                                                        1
                                                                        2))
                                                                      (grind)))))))
                                                                (then
                                                                 (hide-all-but
                                                                  (-4
                                                                   1
                                                                   3))
                                                                 (typepred
                                                                  "r")
                                                                 (typepred
                                                                  "D")
                                                                 (typepred
                                                                  "t")
                                                                 (expand
                                                                  "hp")
                                                                 (expand
                                                                  "dd?"
                                                                  -3)
                                                                 (spread
                                                                  (split
                                                                   -3)
                                                                  ((then
                                                                    (skeep)
                                                                    (grind))
                                                                   (grind))))
                                                                (then
                                                                 (hide-all-but
                                                                  1)
                                                                 (grind)
                                                                 (typepred
                                                                  "k")
                                                                 (grind))))))))
                                                          (then
                                                           (hide-all-but
                                                            (-2 1 2))
                                                           (typepred
                                                            "t"
                                                            "r")
                                                           (typepred
                                                            "D")
                                                           (expand
                                                            "hp")
                                                           (expand
                                                            "dd?"
                                                            -1)
                                                           (spread
                                                            (split -1)
                                                            ((then
                                                              (skeep)
                                                              (grind))
                                                             (grind))))))))))))
                                                  (then
                                                   (expand
                                                    "turn_odes"
                                                    1)
                                                   (expand
                                                    "solution_odes_u?"
                                                    -4)
                                                   (flatten)))))
                                               (then
                                                (hide-all-but 1)
                                                (skeep)
                                                (typepred "D")
                                                (expand "dd?" -1)
                                                (spread
                                                 (split -1)
                                                 ((then
                                                   (skeep)
                                                   (grind))
                                                  (grind))))
                                               (then
                                                (hide-all-but 1)
                                                (skeep)
                                                (grind)))))
                                            (then
                                             (expand
                                              "solution_odes_u?"
                                              -3)
                                             (flatten)))))
                                         (then
                                          (hide-all-but 1)
                                          (skeep)
                                          (typepred "D!1")
                                          (expand "dd?" -1)
                                          (spread
                                           (split -1)
                                           ((then (skeep) (grind))
                                            (grind))))
                                         (then
                                          (hide-all-but 1)
                                          (skeep)
                                          (grind)))))
                                      (spread
                                       (split 1)
                                       ((then
                                         (hide-all-but 1)
                                         (skeep)
                                         (grind))
                                        (then
                                         (expand "turn_odes" -1 1)
                                         (propax))))))
                                    (then (expand "dd?" 1) (propax)))))
                                 (then
                                  (expand "hp" 1)
                                  (assert)
                                  (typepred "r" "r!1")
                                  (hide-all-but (-1 -2 1))
                                  (typepred "D" "D!1")
                                  (expand "dd?")
                                  (grind)))))
                              (then (hide-all-but 1) (expand "dd?")
                               (propax)))))
                           (then (assert) (expand "b2" -1)
                            (expand "semantic_rel" -1) (skeep)
                            (expand "semantic_rel " -1) (assert)
                            (flatten) (expand "<=" -1)
                            (expand "cnst" -1) (expand "val" -1)
                            (assert) (expand "straight" -3)
                            (expand "semantic_rel" -3) (skeep)
                            (expand "semantic_rel_diff" -3) (skeep)
                            (skeep)
                            (spread (case "r = 0")
                             ((spread (case "eo = env_1")
                               ((assert)
                                (then
                                 (decompose-equality 1)
                                 (expand "env_at_t?" -4)
                                 (flatten)
                                 (spread
                                  (inst -4 "x!1")
                                  ((assert)
                                   (then
                                    (expand "not_in_map" 1)
                                    (skeep)
                                    (spread
                                     (case "i=0")
                                     ((then
                                       (expand "nth" -2)
                                       (assert)
                                       (inst -6 "0")
                                       (expand "nth" -6)
                                       (typepred "fs")
                                       (expand "solution_odes_u?" -1)
                                       (flatten)
                                       (hide -2)
                                       (expand "solution_odes?" -1)
                                       (flatten)
                                       (expand "env_at_t?" -2)
                                       (inst -2 "0")
                                       (assert)
                                       (expand "nth" -2)
                                       (assert))
                                      (spread
                                       (case "i=1")
                                       ((then
                                         (expand "nth" -2)
                                         (assert)
                                         (expand "nth" -2)
                                         (assert)
                                         (inst -6 "1")
                                         (expand "nth")
                                         (expand "nth")
                                         (typepred "fs")
                                         (expand "solution_odes_u?" -1)
                                         (flatten)
                                         (hide -2)
                                         (expand "solution_odes?" -1)
                                         (flatten)
                                         (expand "env_at_t?" -2)
                                         (inst -2 "1")
                                         (expand "nth" -2)
                                         (expand "nth" -2)
                                         (assert))
                                        (then
                                         (hide -)
                                         (typepred "i")
                                         (grind))))))))))))
                              (spread
                               (lemma "negative_derivative[(D)]")
                               ((spread
                                 (inst -1 "LAMBDA(t:(D)): fs(0)(t)")
                                 ((spread
                                   (split -1)
                                   ((then
                                     (expand "strict_decreasing?" -1)
                                     (spread
                                      (inst -1 "0" "r")
                                      ((then
                                        (assert)
                                        (spread
                                         (split -1)
                                         ((then
                                           (expand "env_at_t?" -4)
                                           (flatten)
                                           (inst -5 "0")
                                           (expand "nth" -5)
                                           (assert)
                                           (typepred "fs")
                                           (expand
                                            "solution_odes_u?"
                                            -1)
                                           (flatten)
                                           (expand "solution_odes?" -1)
                                           (flatten)
                                           (expand "env_at_t?" -2)
                                           (inst -2 "0")
                                           (expand "nth" -2)
                                           (assert))
                                          (then
                                           (hide -)
                                           (hide 3 4 5 6 7)
                                           (typepred "r")
                                           (typepred "D")
                                           (expand "dd?" -1)
                                           (spread
                                            (split -1)
                                            ((then (skeep) (grind))
                                             (grind)))))))
                                       (then
                                        (hide -)
                                        (typepred "D")
                                        (expand "dd?" -1)
                                        (spread
                                         (split -1)
                                         ((then (skeep) (grind))
                                          (grind)))))))
                                    (then
                                     (typepred "fs")
                                     (expand "solution_odes_u?" -1)
                                     (flatten)
                                     (hide -2)
                                     (expand "solution_odes?" -1)
                                     (flatten)
                                     (skeep)
                                     (inst
                                      -3
                                      "x!1"
                                      "env_at_t((:(x,cnst(-c)),(y,cnst(0)):),fs,env_1)(x!1)")
                                     (expand "sol_at_t?" -3)
                                     (spread
                                      (inst -3 "0")
                                      ((then
                                        (expand "restrict" -3)
                                        (assert)
                                        (expand "nth" -3)
                                        (expand "cnst" -3)
                                        (assert)
                                        (expand "deriv" -3)
                                        (assert))
                                       (then
                                        (hide-all-but 1)
                                        (grind)))))))
                                  (then
                                   (typepred "fs")
                                   (expand "solution_odes_u?" -1)
                                   (flatten)
                                   (expand "solution_odes?" -1)
                                   (flatten)
                                   (expand "derivable_odes?" -1)
                                   (spread
                                    (inst -1 "0")
                                    ((then
                                      (expand "restrict" -1)
                                      (propax))
                                     (then (hide-all-but 1) (grind)))))
                                  (then
                                   (skeep)
                                   (hide-all-but 1)
                                   (grind))))
                                (then (lemma "dd_noe") (inst -1 "D"))
                                (then
                                 (lemma "dd_con")
                                 (inst -1 "D"))))))))))
                        (spread (case "j=1")
                         ((assert)
                          (then (assert) (flatten) (assert) (skeep)
                           (typepred "en") (expand "straight" -4)
                           (expand "semantic_rel" -4) (skeep)
                           (expand "dyn" -6) (expand "semantic_rel" -6)
                           (spread (split -6)
                            ((then (expand "b1" -1)
                              (expand "semantic_rel" -1) (skeep)
                              (expand "semantic_rel" -1) (flatten)
                              (expand ">" -1) (expand "cnst" -1)
                              (expand "val" -1) (assert))
                             (then (expand "b2" -1)
                              (expand "semantic_rel" -1) (skeep)
                              (expand "semantic_rel" -1)
                              (expand "<=" -1) (expand "cnst" -1)
                              (flatten) (expand "val" -1) (assert)
                              (expand "straight" -3)
                              (expand "semantic_rel" -3) (skeep)
                              (expand "semantic_rel_diff" -3) (skeep*)
                              (typepred "fs")
                              (expand "solution_odes_u?" -1) (flatten)
                              (hide -2) (expand "solution_odes?" -1)
                              (flatten) (expand "env_at_t?" -2)
                              (spread (inst -2 "0")
                               ((then
                                 (expand "nth" -2)
                                 (expand "env_at_t?" -6)
                                 (flatten)
                                 (inst -7 "0")
                                 (expand "nth" -7)
                                 (assert)
                                 (spread
                                  (case "r=0")
                                  ((assert)
                                   (then
                                    (expand "derivable_odes?" -1)
                                    (inst -1 "0")
                                    (expand "restrict" -1)
                                    (spread
                                     (lemma
                                      "negative_derivative[(D!1)]")
                                     ((then
                                       (inst
                                        -1
                                        "LAMBDA(s:(D!1)): fs(0)(s)")
                                       (assert)
                                       (spread
                                        (split -1)
                                        ((then
                                          (expand
                                           "strict_decreasing?"
                                           -1)
                                          (spread
                                           (inst -1 "0" "r")
                                           ((then
                                             (assert)
                                             (hide -)
                                             (typepred "r")
                                             (typepred "D!1")
                                             (expand "dd?" -1)
                                             (spread
                                              (split -1)
                                              ((then (skeep) (grind))
                                               (grind))))
                                            (then
                                             (hide -)
                                             (typepred "D!1")
                                             (expand "dd?" -1)
                                             (spread
                                              (split -1)
                                              ((then (skeep) (grind))
                                               (grind)))))))
                                         (then
                                          (skeep)
                                          (inst
                                           -3
                                           "x!1"
                                           "env_at_t((: (x,cnst(-c)), (y,cnst(0)):),fs,env_1)(x!1)")
                                          (expand "sol_at_t?" -3)
                                          (inst -3 "0")
                                          (expand "nth" -3)
                                          (expand "cnst" -3)
                                          (assert)
                                          (expand "restrict" -3)
                                          (assert)
                                          (expand "deriv" -3)
                                          (assert)))))
                                      (then
                                       (lemma "dd_noe")
                                       (inst -1 "D!1"))
                                      (then
                                       (lemma "dd_con")
                                       (inst -1 "D!1"))))))))
                                (then
                                 (hide-all-but 1)
                                 (grind)))))))))))))))))))
               (then (assert) (hide 3)
                (spread (case "j=0")
                 ((then (expand "BSTAR" -2) (assert) (hide -3)
                   (expand "semantic_rel" -2) (assert) (skeep)
                   (expand "semantic_rel" -3) (flatten) (hide -3)
                   (hide 3) (expand "dyn" -2)
                   (expand "semantic_rel" -2)
                   (spread (split -2)
                    ((then (expand "b1" -1) (expand "semantic_rel" -1)
                      (skeep) (expand "semantic_rel" -1) (flatten)
                      (hide -1) (expand "turn" -2)
                      (expand "semantic_rel" -2) (skeep)
                      (expand "semantic_rel_diff" -2) (skeep) (skeep)
                      (spread (inst -3 "r" "eo")
                       ((then (expand ">=" -3) (expand "cnst" -3)
                         (expand "val" -3) (propax))
                        (assert))))
                     (then (expand "b2" -1) (expand "semantic_rel" -1)
                      (skeep) (expand "semantic_rel" -1) (flatten)
                      (expand "<=" -1) (expand "cnst" -1)
                      (expand "val" -1) (assert)))))
                  (then (assert)
                   (lemma "semantic_rel_bounded_star_seq_switch")
                   (inst?) (assert) (hide -2)
                   (expand "semantic_rel" -1 1) (skeep)
                   (inst -3 "c" "ei" "env") (assert)
                   (spread (split -3)
                    ((then (hide 4) (hide -2) (expand "dyn" -2)
                      (expand "semantic_rel" -2) (assert)
                      (spread (split -2)
                       ((then (expand "b1") (expand "semantic_rel" -1)
                         (skeep) (hide -1) (expand "turn" -1)
                         (expand "semantic_rel" -1) (skeep)
                         (expand "semantic_rel_diff" -1) (skeep)
                         (skeep) (inst -2 "r" "eo") (expand ">=" -2)
                         (expand "cnst" -2) (expand "val" -2) (propax))
                        (then (assert) (expand "b2" -1)
                         (expand "semantic_rel" -1) (skeep)
                         (expand "semantic_rel" -1) (flatten)
                         (expand "<=" -1) (expand "cnst" -1)
                         (expand "val" -1) (assert)))))
                     (then (assert) (flatten) (hide -3)
                      (spread (case "env(dlvar_index(x)) > 0 ")
                       ((then (hide 4) (hide -3) (expand "dyn" -3)
                         (expand "semantic_rel" -3)
                         (spread (split -3)
                          ((then (expand "b1")
                            (expand "semantic_rel" -1) (skeep)
                            (expand "semantic_rel" -1) (flatten)
                            (hide -1) (expand "turn" -2)
                            (expand "semantic_rel" -2) (skeep)
                            (expand "semantic_rel_diff" -2) (skeep)
                            (skeep) (inst -3 "r" "eo") (assert)
                            (expand ">=" -3) (expand "cnst" -3)
                            (expand "val" -3) (propax))
                           (then (assert) (expand "b2" -1)
                            (expand "semantic_rel" -1) (skeep)
                            (hide -2) (expand "semantic_rel" -1)
                            (flatten) (expand "<=" -1)
                            (expand "cnst" -1) (expand "val" -1)
                            (assert)))))
                        (spread (case "NOT env(dlvar_index(x))=0")
                         ((assert)
                          (then (hide -2 1) (inst 4 "env") (assert)
                           (hide -2) (expand "dyn" -2)
                           (expand "semantic_rel" -2)
                           (spread (split -2)
                            ((then (expand "b1")
                              (expand "semantic_rel" -1) (skeep)
                              (expand "semantic_rel" -1) (flatten)
                              (hide -1) (expand "turn" -2)
                              (expand "semantic_rel" -2) (skeep)
                              (expand "semantic_rel_diff" -2) (skeep)
                              (skeep) (inst -3 "r" "eo")
                              (expand ">=" -3) (expand "cnst" -3)
                              (expand "val" -3) (propax))
                             (then (assert) (expand "b2" -1)
                              (expand "semantic_rel" -1) (skeep)
                              (expand "semantic_rel" -1) (flatten)
                              (assert))))))))))
                     (then (flatten) (skeep) (assert) (typepred "en")
                      (inst 4 "en") (assert) (hide -6)
                      (expand "dyn" -6) (expand "semantic_rel" -6)
                      (spread (split -6)
                       ((then (expand "b1" -1)
                         (expand "semantic_rel" -1) (skeep)
                         (expand "semantic_rel" -1) (flatten)
                         (expand ">" -1) (expand "cnst" -1)
                         (expand "val" -1) (assert))
                        (then (expand "b2" -1)
                         (expand "semantic_rel" -1) (skeep)
                         (expand "semantic_rel" -1) (flatten) (hide -1)
                         (expand "straight" 4) (expand "straight" -2)
                         (expand "straight" -7) (hide -6)
                         (lemma "fs_st_sol_u") (expand "semantic_rel")
                         (skeep) (skeep)
                         (spread (inst 4 "hp(0)")
                          ((then (expand "semantic_rel_diff") (skeep*)
                            (typepred "fs" "fs!1")
                            (spread (inst-cp -3 "hp(0)" "en" "c")
                             ((spread (inst 4 "r!1+r" "fs_st(c,en)")
                               ((then
                                 (inst-cp -3 "D" "env_1" "c")
                                 (inst -3 "D!1" "en" "c")
                                 (expand "solution_odes_u?" -3)
                                 (expand "solution_odes_u?" -4)
                                 (flatten)
                                 (hide -5)
                                 (hide -3)
                                 (spread
                                  (inst -3 "fs!1" "D!1")
                                  ((then
                                    (assert)
                                    (expand "solution_odes_u?" -2)
                                    (flatten)
                                    (assert)
                                    (hide -3)
                                    (spread
                                     (inst -4 "fs" "D")
                                     ((then
                                       (expand "solution_odes_u?" -1)
                                       (flatten)
                                       (assert)
                                       (hide -2)
                                       (spread
                                        (split 4)
                                        ((then
                                          (expand "env_at_t?" 1)
                                          (spread
                                           (split 1)
                                           ((then
                                             (skeep)
                                             (expand "env_at_t?" -7)
                                             (expand "env_at_t?" -12)
                                             (flatten)
                                             (inst -7 "i")
                                             (inst -13 "i")
                                             (assert))
                                            (then
                                             (skeep)
                                             (expand "env_at_t?" -7)
                                             (expand "env_at_t?" -12)
                                             (flatten)
                                             (spread
                                              (case "k=0")
                                              ((then
                                                (replace -1)
                                                (expand "nth" 1)
                                                (expand "fs_st" 1)
                                                (inst -9 "0")
                                                (expand "nth" -9)
                                                (replace -9 1 rl)
                                                (inst -5 "0" "r")
                                                (replace -5 1)
                                                (expand "fs_st" 1)
                                                (assert)
                                                (inst -15 "0")
                                                (expand "nth" -15)
                                                (replace -7 1 lr)
                                                (replace -15 1 rl)
                                                (inst -4 "0" "r!1")
                                                (replace -4)
                                                (expand "fs_st" 1)
                                                (propax))
                                               (spread
                                                (case "k=1")
                                                ((then
                                                  (replace -1)
                                                  (expand "nth" 2)
                                                  (expand "nth" 2)
                                                  (expand "fs_st" 2)
                                                  (spread
                                                   (inst -9 "1")
                                                   ((then
                                                     (expand "nth" -9)
                                                     (expand "nth" -9)
                                                     (replace -9 2 rl)
                                                     (inst -5 "1" "r")
                                                     (replace -5 2)
                                                     (expand "fs_st" 2)
                                                     (inst -15 "1")
                                                     (expand "nth" -15)
                                                     (expand "nth" -15)
                                                     (replace -7 2 lr)
                                                     (replace -15 2 rl)
                                                     (inst
                                                      -4
                                                      "1"
                                                      "r!1")
                                                     (replace -4 2 lr)
                                                     (expand "fs_st" 2)
                                                     (propax))
                                                    (then
                                                     (hide-all-but 1)
                                                     (grind)))))
                                                 (then
                                                  (hide -)
                                                  (typepred "k")
                                                  (hide 3 4 5 6)
                                                  (grind))))))))))
                                         (then
                                          (skeep)
                                          (expand "DLBOOL" 1)
                                          (propax)))))
                                      (skeep))))
                                   (skeep))))
                                (then
                                 (expand "hp" 1)
                                 (assert)
                                 (hide -)
                                 (typepred "r" "r!1")
                                 (typepred "D" "D!1")
                                 (expand "dd?")
                                 (grind))))
                              (then (hide -) (expand "dd?" 1)
                               (propax)))))
                           (then (expand "dd?" 1)
                            (propax)))))))))))))))))
            (then (inst-cp -2 "c" "ei" "eo") (assert) (assert)
             (spread (split -3)
              ((then (flatten) (assert))
               (then (flatten) (assert))))))))
         (then (flatten)
          (spread (case "j=0")
           ((then (replace -1) (expand "dyn" 1) (expand "BSTAR" 2)
             (expand "semantic_rel" +) (expand "DLBOOL" 2) (assert)
             (inst 1 "eo") (expand "BSTAR" 1)
             (spread (split 1)
              ((then (expand "semantic_rel" 1) (flatten) (expand "b1")
                (expand "b2") (expand "semantic_rel" +) (inst 1 "ei")
                (spread (split 1)
                 ((then (expand "semantic_rel" 1) (grind 1))
                  (propax))))
               (then (expand "semantic_rel" 1) (expand "DLBOOL" 1)
                (propax)))))
            (then (assert)
             (spread (case "ei=eo")
              ((then (assert) (hide -2) (inst -2 "c" "ei" "eo")
                (assert))
               (then (assert)
                (spread (case "eo(dlvar_index(x)) >= 0")
                 ((then (assert) (inst -3 "c" "ei" "eo") (assert))
                  (then (assert) (inst -2 "c" "ei" "eo") (assert)
                   (spread (case "NOT j=1")
                    ((assert)
                     (then (reveal -) (hide -1) (hide -1) (replace -1)
                      (skeep) (hide 5 6) (expand "semantic_rel" 4)
                      (inst 4 "en")
                      (spread (split 4)
                       ((then (expand "dyn" 1)
                         (expand "semantic_rel" 1) (expand "b1")
                         (expand "b2" 1) (flatten)
                         (expand "semantic_rel" +) (inst 1 "ei")
                         (spread (split 1)
                          ((then (hide 2) (expand "semantic_rel" 1)
                            (grind))
                           (propax))))
                        (then (expand "dyn" 1) (expand "BSTAR" 1)
                         (expand "BSTAR" 1) (expand "semantic_rel" 1)
                         (flatten) (typepred "en")
                         (expand "semantic_rel" 1) (inst 1 "eo")
                         (spread (split 1)
                          ((then (expand "b1" 1) (expand "b2" 1)
                            (expand "semantic_rel" 1) (flatten)
                            (expand "semantic_rel" 2) (inst 2 "en")
                            (spread (split 2)
                             ((then (expand "semantic_rel" 1)
                               (hide 2 3) (grind))
                              (propax))))
                           (then (expand "semantic_rel")
                            (expand "DLBOOL")
                            (propax)))))))))))))))))))))))))
    nil)
   ((semantic_rel_bounded_star_seq_switch formula-decl nil
     bounded_star_semantics dL)
    (b1 const-decl "HP" flight_turn_example nil)
    (b2 const-decl "HP" flight_turn_example nil)
    (<= const-decl "BoolExpr" bool_expr dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (negative_derivative formula-decl nil derivative_props analysis)
    (connected? const-decl "bool" deriv_domain_def analysis)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (derivable_odes? const-decl "bool" hp_expr dL)
    (strict_decreasing? const-decl "bool" real_fun_preds reals)
    (env_at_t const-decl
     "{env: (env_at_t?(odes, fs, envi, t)) | FORALL (env2: (env_at_t?(odes, fs, envi, t))): env = env2}"
     hp_expr dL)
    (deriv const-decl "[T -> real]" derivatives analysis)
    (restrict const-decl "R" restrict nil)
    (sol_at_t? const-decl "bool" hp_expr dL)
    (deriv_fun type-eq-decl nil derivatives analysis)
    (derivable? const-decl "bool" derivatives analysis)
    (dd_noe formula-decl nil hp_expr dL)
    (dd_con formula-decl nil hp_expr dL)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (solution_odes? const-decl "bool" hp_expr dL)
    (dd? const-decl "bool" hp_expr dL)
    (hp const-decl "bool" interval_def ODEs)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (ODEs type-eq-decl nil hp_def dL)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (solution_odes_u? const-decl "bool" hp_expr dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (turn_sol_u formula-decl nil flight_turn_example nil)
    (fs_r const-decl "real" flight_turn_example nil)
    (MapExprInj type-eq-decl nil hp_def dL)
    (not_in_map const-decl "bool" hp_def dL)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sin_range application-judgement "real_abs_le1" sincos trig)
    (real_times_real_is_real application-judgement "real" reals nil)
    (cos_range application-judgement "real_abs_le1" sincos trig)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (pi_bound name-judgement
     "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig)
    (minus_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (length_singleton formula-decl nil more_list_props structures)
    (sin_plus formula-decl nil sincos trig)
    (cos_plus formula-decl nil sincos trig)
    (nth def-decl "T" list_props nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (env_at_t? const-decl "bool" hp_expr dL)
    (<= const-decl "bool" reals nil)
    (sin_minus formula-decl nil sincos trig)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (cos const-decl "real" sincos_def trig)
    (sin const-decl "real" sincos_def trig)
    (sin_cos_one formula-decl nil sincos_def trig)
    (cos_minus formula-decl nil sincos trig)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (closed_interval const-decl "(closed_interval?(a, b))" interval_def
     ODEs)
    (turn_odes const-decl "ODEs" flight_turn_example nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (semantic_rel_diff const-decl "bool" hp_expr dL)
    (TRUE const-decl "bool" booleans nil)
    (> const-decl "BoolExpr" bool_expr dL)
    (fs_st_sol_u formula-decl nil flight_turn_example nil)
    (fs_st const-decl "real" flight_turn_example nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (DLBOOL const-decl "bool" bool_expr dL)
    (nat_induction formula-decl nil naturalnumbers nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (straight const-decl "HP" flight_turn_example nil)
    (< const-decl "bool" reals nil) (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (turn const-decl "HP" flight_turn_example nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (dyn const-decl "HP" flight_turn_example nil)
    (BSTAR def-decl "HP" bounded_star_semantics dL)
    (semantic_rel inductive-decl "bool" hp_expr dL)
    (HP type-decl nil HP_adt dL)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (y const-decl "dLVar" flight_turn_example nil)
    (x const-decl "dLVar" flight_turn_example nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (> const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Environment type-eq-decl nil hp_def dL)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (minus_real_is_real application-judgement "real" reals nil))
   shostak))
 (b_star_dyn_tr 0
  (b_star_dyn_tr-1 nil 3882377343
   (""
    (spread (induct "k")
     ((then (skeep) (expand "BSTAR" 1) (expand "semantic_rel" 1)
       (expand "DLBOOL" 1) (assert)
       (spread (split)
        ((then (flatten) (assert)) (then (flatten) (assert)))))
      (then (skeep) (skeep) (expand "BSTAR" 1)
       (expand "semantic_rel" 1 1)
       (spread (split 1)
        ((then (flatten)
          (spread (split -1)
           ((then (assert)
             (spread (case "eo(dlvar_index(x)) >=0")
              ((then (assert)
                (lemma "semantic_rel_bounded_star_seq_switch") (inst?)
                (assert) (hide -3) (expand "semantic_rel" -1) (skeep)
                (inst -4 "c" "ei" "env") (assert)
                (spread (case "ei= env")
                 ((then (assert) (expand "dyn_tr" -3)
                   (expand "semantic_rel" -3)
                   (spread (split -3)
                    ((then (expand "b1_tr" -1)
                      (expand "semantic_rel" -1) (skeep)
                      (spread (case "env_1=env")
                       ((assert)
                        (then (expand "semantic_rel" -1) (flatten)))))
                     (then (assert) (expand "b2" -1)
                      (expand "semantic_rel" -1) (skeep) (hide 2)
                      (hide -2) (hide -5) (expand "semantic_rel" -1)
                      (grind)))))
                  (then (assert)
                   (spread (case "j=0")
                    ((assert)
                     (then (assert)
                      (spread (split -4)
                       ((then (flatten) (assert) (expand "dyn_tr" -4)
                         (expand "semantic_rel" -4)
                         (spread (split -4)
                          ((then (expand "b1_tr" -1)
                            (expand "semantic_rel" -1) (skeep) (assert)
                            (expand "semantic_rel" -1) (flatten)
                            (assert) (replace -2) (hide -6)
                            (expand "turn_tr") (expand "semantic_rel")
                            (skeep*)
                            (spread (inst 4 "hp(0)")
                             ((then (expand "semantic_rel_diff" 4)
                               (expand "semantic_rel_diff" -) (skeep*)
                               (typepred "fs" "fs!1")
                               (spread
                                (inst 4 "r+r!1")
                                ((then
                                  (lemma "turn_tr_sol_u")
                                  (spread
                                   (inst -1 "c" "hp(0)" "ei")
                                   ((then
                                     (inst 4 "fs_tr(ei,c)")
                                     (expand "solution_odes_u?" -1)
                                     (flatten)
                                     (spread
                                      (inst -2 "fs!1" "D!1")
                                      ((then
                                        (assert)
                                        (expand "turn_tr_odes" -2 1)
                                        (spread
                                         (split -2)
                                         ((then
                                           (lemma "turn_tr_sol_u")
                                           (inst -1 "c" "hp(0)" "env")
                                           (expand
                                            "solution_odes_u?"
                                            -1)
                                           (flatten)
                                           (spread
                                            (inst -2 "fs" "D")
                                            ((then
                                              (assert)
                                              (spread
                                               (split -2)
                                               ((spread
                                                 (split 4)
                                                 ((then
                                                   (expand
                                                    "env_at_t?"
                                                    1)
                                                   (spread
                                                    (split 1)
                                                    ((then
                                                      (skeep)
                                                      (typepred "i")
                                                      (expand
                                                       "env_at_t?"
                                                       -10)
                                                      (expand
                                                       "env_at_t?"
                                                       -13)
                                                      (flatten)
                                                      (inst -14 "i")
                                                      (inst -10 "i")
                                                      (assert))
                                                     (then
                                                      (skeep)
                                                      (expand
                                                       "env_at_t?"
                                                       -9)
                                                      (flatten)
                                                      (inst -10 "k")
                                                      (replace
                                                       -10
                                                       1
                                                       rl)
                                                      (inst -1 "k" "r")
                                                      (replace -1 1)
                                                      (spread
                                                       (case "k=0")
                                                       ((then
                                                         (replace -1)
                                                         (expand
                                                          "fs_tr"
                                                          1)
                                                         (assert)
                                                         (expand
                                                          "env_at_t?"
                                                          -14)
                                                         (flatten)
                                                         (inst-cp
                                                          -15
                                                          "0")
                                                         (expand
                                                          "nth"
                                                          -16)
                                                         (expand
                                                          "turn_tr_odes"
                                                          -16)
                                                         (replace
                                                          -16
                                                          1
                                                          rl)
                                                         (inst-cp
                                                          -4
                                                          "0"
                                                          "r!1")
                                                         (replace -5 1)
                                                         (expand
                                                          "fs_tr"
                                                          1)
                                                         (assert)
                                                         (spread
                                                          (inst
                                                           -16
                                                           "2")
                                                          ((then
                                                            (expand
                                                             "turn_tr_odes"
                                                             -16)
                                                            (expand
                                                             "nth"
                                                             -16)
                                                            (expand
                                                             "nth"
                                                             -16)
                                                            (expand
                                                             "nth"
                                                             -16)
                                                            (replace
                                                             -16
                                                             1
                                                             rl)
                                                            (inst
                                                             -4
                                                             "2"
                                                             "r!1")
                                                            (replace
                                                             -4)
                                                            (expand
                                                             "fs_tr"
                                                             1)
                                                            (propax))
                                                           (then
                                                            (expand
                                                             "length"
                                                             1)
                                                            (assert)
                                                            (expand
                                                             "turn_tr_odes"
                                                             1)
                                                            (expand
                                                             "length"
                                                             1)
                                                            (assert)))))
                                                        (spread
                                                         (case "k=1")
                                                         ((then
                                                           (replace -1)
                                                           (expand
                                                            "fs_tr"
                                                            2)
                                                           (expand
                                                            "env_at_t?"
                                                            -14)
                                                           (flatten)
                                                           (inst-cp
                                                            -15
                                                            "1")
                                                           (spread
                                                            (inst
                                                             -15
                                                             "2")
                                                            ((then
                                                              (expand
                                                               "nth"
                                                               -15)
                                                              (expand
                                                               "nth"
                                                               -15)
                                                              (expand
                                                               "nth"
                                                               -16)
                                                              (expand
                                                               "turn_tr_odes"
                                                               -15)
                                                              (expand
                                                               "nth"
                                                               -15)
                                                              (expand
                                                               "turn_tr_odes"
                                                               -16)
                                                              (expand
                                                               "nth"
                                                               -16)
                                                              (replace
                                                               -15
                                                               2
                                                               rl)
                                                              (replace
                                                               -16
                                                               2
                                                               rl)
                                                              (inst-cp
                                                               -4
                                                               "1"
                                                               "r!1")
                                                              (inst
                                                               -4
                                                               "2"
                                                               "r!1")
                                                              (replace
                                                               -4
                                                               2)
                                                              (replace
                                                               -5
                                                               2)
                                                              (expand
                                                               "fs_tr"
                                                               2)
                                                              (propax))
                                                             (then
                                                              (hide-all-but
                                                               1)
                                                              (grind)))))
                                                          (spread
                                                           (case
                                                            "k = 2")
                                                           ((then
                                                             (replace
                                                              -1)
                                                             (expand
                                                              "fs_tr"
                                                              3)
                                                             (expand
                                                              "env_at_t?"
                                                              -14)
                                                             (flatten)
                                                             (inst
                                                              -15
                                                              "2")
                                                             (expand
                                                              "turn_tr_odes"
                                                              -15)
                                                             (expand
                                                              "nth"
                                                              -15)
                                                             (expand
                                                              "nth"
                                                              -15)
                                                             (expand
                                                              "nth"
                                                              -15)
                                                             (replace
                                                              -15
                                                              3
                                                              rl)
                                                             (inst
                                                              -4
                                                              "2"
                                                              "r!1")
                                                             (replace
                                                              -4
                                                              3)
                                                             (expand
                                                              "fs_tr"
                                                              3)
                                                             (propax))
                                                            (then
                                                             (hide -)
                                                             (typepred
                                                              "k")
                                                             (grind))))))))))))
                                                  (then
                                                   (skeep)
                                                   (typepred "t")
                                                   (spread
                                                    (case "t<= r!1")
                                                    ((spread
                                                      (inst
                                                       -16
                                                       "t"
                                                       "env!1")
                                                      ((then
                                                        (expand
                                                         "env_at_t?"
                                                         1)
                                                        (spread
                                                         (split 1)
                                                         ((then
                                                           (typepred
                                                            "env!1")
                                                           (expand
                                                            "env_at_t?"
                                                            -1)
                                                           (flatten))
                                                          (then
                                                           (typepred
                                                            "env!1")
                                                           (expand
                                                            " env_at_t?"
                                                            -1)
                                                           (flatten)
                                                           (skeep)
                                                           (inst
                                                            -2
                                                            "k")
                                                           (replace
                                                            -2
                                                            1
                                                            rl)
                                                           (inst
                                                            -8
                                                            "k"
                                                            "t")
                                                           (assert)
                                                           (typepred
                                                            "r!1")
                                                           (hide-all-but
                                                            (-1 -4 1))
                                                           (typepred
                                                            "D!1")
                                                           (expand
                                                            "dd?"
                                                            -1)
                                                           (skeep)
                                                           (grind)
                                                           (grind)
                                                           (typepred
                                                            "t")
                                                           (expand
                                                            "hp"
                                                            -1)
                                                           (assert)))))
                                                       (then
                                                        (hide-all-but
                                                         (-1 1))
                                                        (typepred
                                                         "D!1")
                                                        (expand
                                                         "dd?"
                                                         -1)
                                                        (spread
                                                         (grind)
                                                         ((then
                                                           (grind)
                                                           (typepred
                                                            "t")
                                                           (expand
                                                            "hp"
                                                            -1)
                                                           (assert)
                                                           (grind)
                                                           (typepred
                                                            "r!1")
                                                           (grind))
                                                          (then
                                                           (typepred
                                                            "t"
                                                            "r!1")
                                                           (grind)))))))
                                                     (then
                                                      (assert)
                                                      (spread
                                                       (inst
                                                        -12
                                                        "t-r!1"
                                                        "env!1")
                                                       ((then
                                                         (expand
                                                          "env_at_t?"
                                                          1)
                                                         (typepred
                                                          "env!1")
                                                         (expand
                                                          "env_at_t?"
                                                          -1)
                                                         (flatten)
                                                         (assert)
                                                         (spread
                                                          (split 1)
                                                          ((then
                                                            (skeep)
                                                            (inst
                                                             -1
                                                             "i")
                                                            (replace
                                                             -1
                                                             1
                                                             rl)
                                                            (expand
                                                             "env_at_t?"
                                                             -15)
                                                            (flatten)
                                                            (inst
                                                             -15
                                                             "i")
                                                            (assert))
                                                           (then
                                                            (skeep)
                                                            (inst
                                                             -2
                                                             "k")
                                                            (replace
                                                             -2
                                                             1
                                                             rl)
                                                            (spread
                                                             (inst
                                                              -5
                                                              "k"
                                                              "t-r!1")
                                                             ((then
                                                               (replace
                                                                -5)
                                                               (spread
                                                                (case
                                                                 "k=0")
                                                                ((then
                                                                  (expand
                                                                   "fs_tr"
                                                                   1)
                                                                  (assert)
                                                                  (expand
                                                                   "env_at_t?"
                                                                   -16)
                                                                  (flatten)
                                                                  (inst-cp
                                                                   -17
                                                                   "0")
                                                                  (spread
                                                                   (inst
                                                                    -17
                                                                    "2")
                                                                   ((then
                                                                     (expand
                                                                      "nth"
                                                                      -17)
                                                                     (expand
                                                                      "nth"
                                                                      -17)
                                                                     (expand
                                                                      "nth"
                                                                      -18)
                                                                     (expand
                                                                      "turn_tr_odes"
                                                                      -17)
                                                                     (expand
                                                                      "turn_tr_odes"
                                                                      -18)
                                                                     (expand
                                                                      "nth"
                                                                      -17)
                                                                     (replace
                                                                      -17
                                                                      1
                                                                      rl)
                                                                     (replace
                                                                      -18
                                                                      1
                                                                      rl)
                                                                     (inst-cp
                                                                      -8
                                                                      "0"
                                                                      "r!1")
                                                                     (replace
                                                                      -9
                                                                      1)
                                                                     (inst
                                                                      -8
                                                                      "2"
                                                                      "r!1")
                                                                     (replace
                                                                      -8
                                                                      1)
                                                                     (expand
                                                                      "fs_tr"
                                                                      1)
                                                                     (propax))
                                                                    (then
                                                                     (hide-all-but
                                                                      1)
                                                                     (grind)))))
                                                                 (spread
                                                                  (case
                                                                   "k=1")
                                                                  ((then
                                                                    (replace
                                                                     -1)
                                                                    (expand
                                                                     "fs_tr"
                                                                     2)
                                                                    (expand
                                                                     "env_at_t?"
                                                                     -16)
                                                                    (flatten)
                                                                    (inst-cp
                                                                     -17
                                                                     "1")
                                                                    (spread
                                                                     (inst
                                                                      -17
                                                                      "2")
                                                                     ((then
                                                                       (expand
                                                                        "turn_tr_odes"
                                                                        -17)
                                                                       (expand
                                                                        "turn_tr_odes"
                                                                        -18)
                                                                       (expand
                                                                        "nth"
                                                                        -17)
                                                                       (expand
                                                                        "nth"
                                                                        -17)
                                                                       (expand
                                                                        "nth"
                                                                        -17)
                                                                       (expand
                                                                        "nth"
                                                                        -18)
                                                                       (expand
                                                                        "nth"
                                                                        -18)
                                                                       (replace
                                                                        -17
                                                                        2
                                                                        rl)
                                                                       (replace
                                                                        -18
                                                                        2
                                                                        rl)
                                                                       (inst-cp
                                                                        -8
                                                                        "1"
                                                                        "r!1")
                                                                       (inst
                                                                        -8
                                                                        "2"
                                                                        "r!1")
                                                                       (replace
                                                                        -8
                                                                        2)
                                                                       (replace
                                                                        -9
                                                                        2)
                                                                       (expand
                                                                        "fs_tr"
                                                                        2)
                                                                       (propax))
                                                                      (then
                                                                       (hide-all-but
                                                                        1)
                                                                       (grind)))))
                                                                   (spread
                                                                    (case
                                                                     "k=2")
                                                                    ((then
                                                                      (expand
                                                                       "env_at_t?"
                                                                       -16)
                                                                      (flatten)
                                                                      (expand
                                                                       "fs_tr"
                                                                       3)
                                                                      (assert)
                                                                      (inst
                                                                       -17
                                                                       "2")
                                                                      (expand
                                                                       "turn_tr_odes"
                                                                       -17)
                                                                      (expand
                                                                       "nth"
                                                                       -17)
                                                                      (expand
                                                                       "nth"
                                                                       -17)
                                                                      (expand
                                                                       "nth"
                                                                       -17)
                                                                      (replace
                                                                       -17
                                                                       3
                                                                       rl)
                                                                      (inst
                                                                       -8
                                                                       "2"
                                                                       "r!1")
                                                                      (replace
                                                                       -8
                                                                       3
                                                                       lr)
                                                                      (expand
                                                                       "fs_tr"
                                                                       3)
                                                                      (propax))
                                                                     (then
                                                                      (hide
                                                                       -)
                                                                      (typepred
                                                                       "k")
                                                                      (grind)))))))))
                                                              (then
                                                               (hide-all-but
                                                                (-4
                                                                 1
                                                                 3))
                                                               (typepred
                                                                "r")
                                                               (typepred
                                                                "D")
                                                               (typepred
                                                                "t")
                                                               (expand
                                                                "hp")
                                                               (expand
                                                                "dd?"
                                                                -3)
                                                               (spread
                                                                (split
                                                                 -3)
                                                                ((then
                                                                  (skeep)
                                                                  (grind))
                                                                 (grind))))))))))
                                                        (then
                                                         (hide-all-but
                                                          (-2 1 2))
                                                         (typepred "r")
                                                         (typepred "D")
                                                         (typepred "t")
                                                         (grind))))))))))
                                                (then
                                                 (assert)
                                                 (expand
                                                  "solution_odes_u?"
                                                  -4)
                                                 (propax)))))
                                             (then
                                              (hide-all-but 1)
                                              (skeep)
                                              (typepred "D")
                                              (expand "dd?" -1)
                                              (spread
                                               (split -1)
                                               ((then (skeep) (grind))
                                                (grind)))))))
                                          (then
                                           (expand
                                            "solution_odes_u?"
                                            -3)
                                           (flatten)
                                           (assert)
                                           (expand "turn_tr_odes" -)
                                           (propax)))))
                                       (then
                                        (hide-all-but 1)
                                        (skeep)
                                        (typepred "D!1")
                                        (expand "dd?" -1)
                                        (spread
                                         (split -1)
                                         ((then (skeep) (grind))
                                          (grind)))))))
                                    (then (hide-all-but 1) (grind)))))
                                 (then
                                  (hide-all-but 1)
                                  (grind)
                                  (typepred "r!1" "r")
                                  (grind)
                                  (typepred "D!1" "D")
                                  (grind)))))
                              (then (hide-all-but 1) (expand "dd?")
                               (propax)))))
                           (then (assert) (expand "b2" -1)
                            (expand "semantic_rel" -1) (skeep)
                            (expand "semantic_rel " -1) (assert)
                            (flatten) (expand "<=" -1)
                            (expand "cnst" -1) (expand "val" -1)
                            (assert) (expand "straight" -3)
                            (expand "semantic_rel" -3) (skeep)
                            (expand "semantic_rel_diff" -3) (skeep)
                            (skeep)
                            (spread (case "r = 0")
                             ((spread (case "eo = env_1")
                               ((assert)
                                (then
                                 (decompose-equality 1)
                                 (expand "env_at_t?" -4)
                                 (flatten)
                                 (spread
                                  (inst -4 "x!1")
                                  ((assert)
                                   (then
                                    (expand "not_in_map" 1)
                                    (skeep)
                                    (spread
                                     (case "i=0")
                                     ((then
                                       (expand "nth" -2)
                                       (assert)
                                       (inst -6 "0")
                                       (expand "nth" -6)
                                       (typepred "fs")
                                       (expand "solution_odes_u?" -1)
                                       (flatten)
                                       (hide -2)
                                       (expand "solution_odes?" -1)
                                       (flatten)
                                       (expand "env_at_t?" -2)
                                       (inst -2 "0")
                                       (assert)
                                       (expand "nth" -2)
                                       (assert))
                                      (spread
                                       (case "i=1")
                                       ((then
                                         (expand "nth" -2)
                                         (assert)
                                         (expand "nth" -2)
                                         (assert)
                                         (inst -6 "1")
                                         (expand "nth")
                                         (expand "nth")
                                         (typepred "fs")
                                         (expand "solution_odes_u?" -1)
                                         (flatten)
                                         (hide -2)
                                         (expand "solution_odes?" -1)
                                         (flatten)
                                         (expand "env_at_t?" -2)
                                         (inst -2 "1")
                                         (expand "nth" -2)
                                         (expand "nth" -2)
                                         (assert))
                                        (then
                                         (hide -)
                                         (typepred "i")
                                         (grind))))))))))))
                              (spread
                               (lemma "negative_derivative[(D)]")
                               ((spread
                                 (inst -1 "LAMBDA(t:(D)): fs(0)(t)")
                                 ((spread
                                   (split -1)
                                   ((then
                                     (expand "strict_decreasing?" -1)
                                     (spread
                                      (inst -1 "0" "r")
                                      ((then
                                        (assert)
                                        (spread
                                         (split -1)
                                         ((then
                                           (expand "env_at_t?" -4)
                                           (flatten)
                                           (inst -5 "0")
                                           (expand "nth" -5)
                                           (assert)
                                           (typepred "fs")
                                           (expand
                                            "solution_odes_u?"
                                            -1)
                                           (flatten)
                                           (expand "solution_odes?" -1)
                                           (flatten)
                                           (expand "env_at_t?" -2)
                                           (inst -2 "0")
                                           (expand "nth" -2)
                                           (assert))
                                          (then
                                           (hide -)
                                           (hide 3 4 5 6 7)
                                           (typepred "r")
                                           (typepred "D")
                                           (expand "dd?" -1)
                                           (spread
                                            (split -1)
                                            ((then (skeep) (grind))
                                             (grind)))))))
                                       (then
                                        (hide -)
                                        (typepred "D")
                                        (expand "dd?" -1)
                                        (spread
                                         (split -1)
                                         ((then (skeep) (grind))
                                          (grind)))))))
                                    (then
                                     (typepred "fs")
                                     (expand "solution_odes_u?" -1)
                                     (flatten)
                                     (hide -2)
                                     (expand "solution_odes?" -1)
                                     (flatten)
                                     (skeep)
                                     (inst
                                      -3
                                      "x!1"
                                      "env_at_t((:(x,cnst(-c)),(y,cnst(0)):),fs,env_1)(x!1)")
                                     (expand "sol_at_t?" -3)
                                     (spread
                                      (inst -3 "0")
                                      ((then
                                        (expand "restrict" -3)
                                        (assert)
                                        (expand "nth" -3)
                                        (expand "cnst" -3)
                                        (assert)
                                        (expand "deriv" -3)
                                        (assert))
                                       (then
                                        (hide-all-but 1)
                                        (grind)))))))
                                  (then
                                   (typepred "fs")
                                   (expand "solution_odes_u?" -1)
                                   (flatten)
                                   (expand "solution_odes?" -1)
                                   (flatten)
                                   (expand "derivable_odes?" -1)
                                   (spread
                                    (inst -1 "0")
                                    ((then
                                      (expand "restrict" -1)
                                      (propax))
                                     (then (hide-all-but 1) (grind)))))
                                  (then
                                   (skeep)
                                   (hide-all-but 1)
                                   (grind))))
                                (then (lemma "dd_noe") (inst -1 "D"))
                                (then
                                 (lemma "dd_con")
                                 (inst -1 "D"))))))))))
                        (spread (case "j=1")
                         ((assert)
                          (then (assert) (flatten) (assert) (skeep)
                           (typepred "en") (expand "straight" -4)
                           (expand "semantic_rel" -4) (skeep)
                           (expand "dyn_tr" -6)
                           (expand "semantic_rel" -6)
                           (spread (split -6)
                            ((then (expand "b1_tr" -1)
                              (expand "semantic_rel" -1) (skeep)
                              (expand "semantic_rel" -1) (flatten)
                              (expand ">" -1) (expand "cnst" -1)
                              (expand "val" -1) (assert))
                             (then (expand "b2" -1)
                              (expand "semantic_rel" -1) (skeep)
                              (expand "semantic_rel" -1)
                              (expand "<=" -1) (expand "cnst" -1)
                              (flatten) (expand "val" -1) (assert)
                              (expand "straight" -3)
                              (expand "semantic_rel" -3) (skeep)
                              (expand "semantic_rel_diff" -3) (skeep*)
                              (typepred "fs")
                              (expand "solution_odes_u?" -1) (flatten)
                              (hide -2) (expand "solution_odes?" -1)
                              (flatten) (expand "env_at_t?" -2)
                              (spread (inst -2 "0")
                               ((then
                                 (expand "nth" -2)
                                 (expand "env_at_t?" -6)
                                 (flatten)
                                 (inst -7 "0")
                                 (expand "nth" -7)
                                 (assert)
                                 (spread
                                  (case "r=0")
                                  ((assert)
                                   (then
                                    (expand "derivable_odes?" -1)
                                    (inst -1 "0")
                                    (expand "restrict" -1)
                                    (spread
                                     (lemma
                                      "negative_derivative[(D!1)]")
                                     ((then
                                       (inst
                                        -1
                                        "LAMBDA(s:(D!1)): fs(0)(s)")
                                       (assert)
                                       (spread
                                        (split -1)
                                        ((then
                                          (expand
                                           "strict_decreasing?"
                                           -1)
                                          (spread
                                           (inst -1 "0" "r")
                                           ((then
                                             (assert)
                                             (hide -)
                                             (typepred "r")
                                             (typepred "D!1")
                                             (expand "dd?" -1)
                                             (spread
                                              (split -1)
                                              ((then (skeep) (grind))
                                               (grind))))
                                            (then
                                             (hide -)
                                             (typepred "D!1")
                                             (expand "dd?" -1)
                                             (spread
                                              (split -1)
                                              ((then (skeep) (grind))
                                               (grind)))))))
                                         (then
                                          (skeep)
                                          (inst
                                           -3
                                           "x!1"
                                           "env_at_t((: (x,cnst(-c)), (y,cnst(0)):),fs,env_1)(x!1)")
                                          (expand "sol_at_t?" -3)
                                          (inst -3 "0")
                                          (expand "nth" -3)
                                          (expand "cnst" -3)
                                          (assert)
                                          (expand "restrict" -3)
                                          (assert)
                                          (expand "deriv" -3)
                                          (assert)))))
                                      (then
                                       (lemma "dd_noe")
                                       (inst -1 "D!1"))
                                      (then
                                       (lemma "dd_con")
                                       (inst -1 "D!1"))))))))
                                (then
                                 (hide-all-but 1)
                                 (grind)))))))))))))))))))
               (then (assert) (hide 3)
                (spread (case "j=0")
                 ((then (expand "BSTAR" -2) (assert) (hide -3)
                   (expand "semantic_rel" -2) (assert) (skeep)
                   (expand "semantic_rel" -3) (flatten) (hide -3)
                   (hide 3) (expand "dyn_tr" -2)
                   (expand "semantic_rel" -2)
                   (spread (split -2)
                    ((then (expand "b1_tr" -1)
                      (expand "semantic_rel" -1) (skeep)
                      (expand "semantic_rel" -1) (flatten) (hide -1)
                      (expand "turn_tr" -2) (expand "semantic_rel" -2)
                      (skeep) (expand "semantic_rel_diff" -2) (skeep)
                      (skeep)
                      (spread (inst -3 "r" "eo")
                       ((then (expand ">=" -3) (expand "cnst" -3)
                         (expand "val" -3) (propax))
                        (assert))))
                     (then (expand "b2" -1) (expand "semantic_rel" -1)
                      (skeep) (expand "semantic_rel" -1) (flatten)
                      (expand "<=" -1) (expand "cnst" -1)
                      (expand "val" -1) (assert)))))
                  (then (assert)
                   (lemma "semantic_rel_bounded_star_seq_switch")
                   (inst?) (assert) (hide -2)
                   (expand "semantic_rel" -1 1) (skeep)
                   (inst -3 "c" "ei" "env") (assert)
                   (spread (split -3)
                    ((then (hide 4) (hide -2) (expand "dyn_tr" -2)
                      (expand "semantic_rel" -2) (assert)
                      (spread (split -2)
                       ((then (expand "b1_tr")
                         (expand "semantic_rel" -1) (skeep) (hide -1)
                         (expand "turn_tr" -1)
                         (expand "semantic_rel" -1) (skeep)
                         (expand "semantic_rel_diff" -1) (skeep)
                         (skeep) (inst -2 "r" "eo") (expand ">=" -2)
                         (expand "cnst" -2) (expand "val" -2) (propax))
                        (then (assert) (expand "b2" -1)
                         (expand "semantic_rel" -1) (skeep)
                         (expand "semantic_rel" -1) (flatten)
                         (expand "<=" -1) (expand "cnst" -1)
                         (expand "val" -1) (assert)))))
                     (then (assert) (flatten) (hide -3)
                      (spread (case "env(dlvar_index(x)) > 0 ")
                       ((then (hide 4) (hide -3) (expand "dyn_tr" -3)
                         (expand "semantic_rel" -3)
                         (spread (split -3)
                          ((then (expand "b1_tr")
                            (expand "semantic_rel" -1) (skeep)
                            (expand "semantic_rel" -1) (flatten)
                            (hide -1) (expand "turn_tr" -2)
                            (expand "semantic_rel" -2) (skeep)
                            (expand "semantic_rel_diff" -2) (skeep)
                            (skeep) (inst -3 "r" "eo") (assert)
                            (expand ">=" -3) (expand "cnst" -3)
                            (expand "val" -3) (propax))
                           (then (assert) (expand "b2" -1)
                            (expand "semantic_rel" -1) (skeep)
                            (hide -2) (expand "semantic_rel" -1)
                            (flatten) (expand "<=" -1)
                            (expand "cnst" -1) (expand "val" -1)
                            (assert)))))
                        (spread (case "NOT env(dlvar_index(x))=0")
                         ((assert)
                          (then (hide -2 1) (inst 4 "env") (assert)
                           (hide -2) (expand "dyn_tr" -2)
                           (expand "semantic_rel" -2)
                           (spread (split -2)
                            ((then (expand "b1_tr")
                              (expand "semantic_rel" -1) (skeep)
                              (expand "semantic_rel" -1) (flatten)
                              (hide -1) (expand "turn_tr" -2)
                              (expand "semantic_rel" -2) (skeep)
                              (expand "semantic_rel_diff" -2) (skeep)
                              (skeep) (inst -3 "r" "eo")
                              (expand ">=" -3) (expand "cnst" -3)
                              (expand "val" -3) (propax))
                             (then (assert) (expand "b2" -1)
                              (expand "semantic_rel" -1) (skeep)
                              (expand "semantic_rel" -1) (flatten)
                              (assert))))))))))
                     (then (flatten) (skeep) (assert) (typepred "en")
                      (inst 4 "en") (assert) (hide -6)
                      (expand "dyn_tr" -6) (expand "semantic_rel" -6)
                      (spread (split -6)
                       ((then (expand "b1_tr" -1)
                         (expand "semantic_rel" -1) (skeep)
                         (expand "semantic_rel" -1) (flatten)
                         (expand ">" -1) (expand "cnst" -1)
                         (expand "val" -1) (assert))
                        (then (expand "b2" -1)
                         (expand "semantic_rel" -1) (skeep)
                         (expand "semantic_rel" -1) (flatten) (hide -1)
                         (expand "straight" 4) (expand "straight" -2)
                         (expand "straight" -7) (hide -6)
                         (lemma "fs_st_sol_u") (expand "semantic_rel")
                         (skeep) (skeep)
                         (spread (inst 4 "hp(0)")
                          ((then (expand "semantic_rel_diff") (skeep*)
                            (typepred "fs" "fs!1")
                            (spread (inst-cp -3 "hp(0)" "en" "c")
                             ((spread (inst 4 "r!1+r" "fs_st(c,en)")
                               ((then
                                 (inst-cp -3 "D" "env_1" "c")
                                 (inst -3 "D!1" "en" "c")
                                 (expand "solution_odes_u?" -3)
                                 (expand "solution_odes_u?" -4)
                                 (flatten)
                                 (hide -5)
                                 (hide -3)
                                 (spread
                                  (inst -3 "fs!1" "D!1")
                                  ((then
                                    (assert)
                                    (expand "solution_odes_u?" -2)
                                    (flatten)
                                    (assert)
                                    (hide -3)
                                    (spread
                                     (inst -4 "fs" "D")
                                     ((then
                                       (expand "solution_odes_u?" -1)
                                       (flatten)
                                       (assert)
                                       (hide -2)
                                       (spread
                                        (split 4)
                                        ((then
                                          (expand "env_at_t?" 1)
                                          (spread
                                           (split 1)
                                           ((then
                                             (skeep)
                                             (expand "env_at_t?" -7)
                                             (expand "env_at_t?" -12)
                                             (flatten)
                                             (inst -7 "i")
                                             (inst -13 "i")
                                             (assert))
                                            (then
                                             (skeep)
                                             (expand "env_at_t?" -7)
                                             (expand "env_at_t?" -12)
                                             (flatten)
                                             (spread
                                              (case "k=0")
                                              ((then
                                                (replace -1)
                                                (expand "nth" 1)
                                                (expand "fs_st" 1)
                                                (inst -9 "0")
                                                (expand "nth" -9)
                                                (replace -9 1 rl)
                                                (inst -5 "0" "r")
                                                (replace -5 1)
                                                (expand "fs_st" 1)
                                                (assert)
                                                (inst -15 "0")
                                                (expand "nth" -15)
                                                (replace -7 1 lr)
                                                (replace -15 1 rl)
                                                (inst -4 "0" "r!1")
                                                (replace -4)
                                                (expand "fs_st" 1)
                                                (propax))
                                               (spread
                                                (case "k=1")
                                                ((then
                                                  (replace -1)
                                                  (expand "nth" 2)
                                                  (expand "nth" 2)
                                                  (expand "fs_st" 2)
                                                  (spread
                                                   (inst -9 "1")
                                                   ((then
                                                     (expand "nth" -9)
                                                     (expand "nth" -9)
                                                     (replace -9 2 rl)
                                                     (inst -5 "1" "r")
                                                     (replace -5 2)
                                                     (expand "fs_st" 2)
                                                     (inst -15 "1")
                                                     (expand "nth" -15)
                                                     (expand "nth" -15)
                                                     (replace -7 2 lr)
                                                     (replace -15 2 rl)
                                                     (inst
                                                      -4
                                                      "1"
                                                      "r!1")
                                                     (replace -4 2 lr)
                                                     (expand "fs_st" 2)
                                                     (propax))
                                                    (then
                                                     (hide-all-but 1)
                                                     (grind)))))
                                                 (then
                                                  (hide -)
                                                  (typepred "k")
                                                  (hide 3 4 5 6)
                                                  (grind))))))))))
                                         (then
                                          (skeep)
                                          (expand "DLBOOL" 1)
                                          (propax)))))
                                      (skeep))))
                                   (skeep))))
                                (then
                                 (expand "hp" 1)
                                 (assert)
                                 (hide -)
                                 (typepred "r" "r!1")
                                 (typepred "D" "D!1")
                                 (expand "dd?")
                                 (grind))))
                              (then (hide -) (expand "dd?" 1)
                               (propax)))))
                           (then (expand "dd?" 1)
                            (propax)))))))))))))))))
            (then (inst-cp -2 "c" "ei" "eo") (assert) (assert)
             (spread (split -3)
              ((then (flatten) (assert))
               (then (flatten) (assert))))))))
         (then (flatten)
          (spread (case "j=0")
           ((then (replace -1) (expand "dyn_tr" 1) (expand "BSTAR" 2)
             (expand "semantic_rel" +) (expand "DLBOOL" 2) (assert)
             (inst 1 "eo") (expand "BSTAR" 1)
             (spread (split 1)
              ((then (expand "semantic_rel" 1) (flatten)
                (expand "b1_tr") (expand "b2")
                (expand "semantic_rel" +) (inst 1 "ei")
                (spread (split 1)
                 ((then (expand "semantic_rel" 1) (grind 1))
                  (propax))))
               (then (expand "semantic_rel" 1) (expand "DLBOOL" 1)
                (propax)))))
            (then (assert)
             (spread (case "ei=eo")
              ((then (assert) (hide -2) (inst -2 "c" "ei" "eo")
                (assert))
               (then (assert)
                (spread (case "eo(dlvar_index(x)) >= 0")
                 ((then (assert) (inst -3 "c" "ei" "eo") (assert))
                  (then (assert) (inst -2 "c" "ei" "eo") (assert)
                   (spread (case "NOT j=1")
                    ((assert)
                     (then (reveal -) (hide -1) (hide -1) (replace -1)
                      (skeep) (hide 5 6) (expand "semantic_rel" 4)
                      (inst 4 "en")
                      (spread (split 4)
                       ((then (expand "dyn_tr" 1)
                         (expand "semantic_rel" 1) (expand "b1_tr")
                         (expand "b2" 1) (flatten)
                         (expand "semantic_rel" +) (inst 1 "ei")
                         (spread (split 1)
                          ((then (hide 2) (expand "semantic_rel" 1)
                            (grind))
                           (propax))))
                        (then (expand "dyn_tr" 1) (expand "BSTAR" 1)
                         (expand "BSTAR" 1) (expand "semantic_rel" 1)
                         (flatten) (typepred "en")
                         (expand "semantic_rel" 1) (inst 1 "eo")
                         (spread (split 1)
                          ((then (expand "b2" 1)
                            (expand "semantic_rel" 1) (flatten)
                            (expand "semantic_rel" 2) (inst 2 "en")
                            (spread (split 2)
                             ((then (expand "semantic_rel" 1)
                               (hide 2 3) (grind))
                              (propax))))
                           (then (expand "semantic_rel")
                            (expand "DLBOOL")
                            (propax)))))))))))))))))))))))))
    nil)
   ((semantic_rel_bounded_star_seq_switch formula-decl nil
     bounded_star_semantics dL)
    (b1_tr const-decl "HP" flight_turn_example nil)
    (b2 const-decl "HP" flight_turn_example nil)
    (<= const-decl "BoolExpr" bool_expr dL)
    (theta const-decl "dLVar" flight_turn_example nil)
    (turn_tr_odes const-decl "ODEs" flight_turn_example nil)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (negative_derivative formula-decl nil derivative_props analysis)
    (connected? const-decl "bool" deriv_domain_def analysis)
    (not_one_element? const-decl "bool" deriv_domain_def analysis)
    (derivable_odes? const-decl "bool" hp_expr dL)
    (strict_decreasing? const-decl "bool" real_fun_preds reals)
    (env_at_t const-decl
     "{env: (env_at_t?(odes, fs, envi, t)) | FORALL (env2: (env_at_t?(odes, fs, envi, t))): env = env2}"
     hp_expr dL)
    (deriv const-decl "[T -> real]" derivatives analysis)
    (restrict const-decl "R" restrict nil)
    (sol_at_t? const-decl "bool" hp_expr dL)
    (deriv_fun type-eq-decl nil derivatives analysis)
    (derivable? const-decl "bool" derivatives analysis)
    (dd_noe formula-decl nil hp_expr dL)
    (dd_con formula-decl nil hp_expr dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (solution_odes? const-decl "bool" hp_expr dL)
    (dd? const-decl "bool" hp_expr dL)
    (hp const-decl "bool" interval_def ODEs)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (ODEs type-eq-decl nil hp_def dL)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (solution_odes_u? const-decl "bool" hp_expr dL)
    (turn_tr_sol_u formula-decl nil flight_turn_example nil)
    (fs_tr const-decl "real" flight_turn_example nil)
    (MapExprInj type-eq-decl nil hp_def dL)
    (not_in_map const-decl "bool" hp_def dL)
    (cos_range application-judgement "real_abs_le1" sincos trig)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (length_singleton formula-decl nil more_list_props structures)
    (nth def-decl "T" list_props nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (pi_bound name-judgement
     "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig)
    (minus_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (sin_range application-judgement "real_abs_le1" sincos trig)
    (env_at_t? const-decl "bool" hp_expr dL)
    (<= const-decl "bool" reals nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (closed_interval const-decl "(closed_interval?(a, b))" interval_def
     ODEs)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (semantic_rel_diff const-decl "bool" hp_expr dL)
    (TRUE const-decl "bool" booleans nil)
    (> const-decl "BoolExpr" bool_expr dL)
    (fs_st_sol_u formula-decl nil flight_turn_example nil)
    (fs_st const-decl "real" flight_turn_example nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (DLBOOL const-decl "bool" bool_expr dL)
    (nat_induction formula-decl nil naturalnumbers nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (straight const-decl "HP" flight_turn_example nil)
    (< const-decl "bool" reals nil) (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (turn_tr const-decl "HP" flight_turn_example nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (dyn_tr const-decl "HP" flight_turn_example nil)
    (BSTAR def-decl "HP" bounded_star_semantics dL)
    (semantic_rel inductive-decl "bool" hp_expr dL)
    (HP type-decl nil HP_adt dL)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (y const-decl "dLVar" flight_turn_example nil)
    (x const-decl "dLVar" flight_turn_example nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (> const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Environment type-eq-decl nil hp_def dL)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (minus_real_is_real application-judgement "real" reals nil))
   shostak))
 (b_star_dyns_equiv 0
  (b_star_dyns_equiv-1 nil 3882192034
   (""
    (then (skeep)
     (spread (split 1)
      ((then (flatten) (skeep) (lemma "b_star_dyn")
        (lemma "b_star_dyn_tr")
        (inst -1 "k" "c" "ei WITH [theta := 0]"
         "eo WITH [theta := th]")
        (assert)
        (inst -2 "k" "c" "ei"
         "eo WITH [theta := ei(dlvar_index(theta))]")
        (assert)
        (spread (case "NOT x = theta")
         ((spread (case "NOT y = theta")
           ((then (assert) (flatten)
             (spread (split -1)
              ((then (decompose-equality -1) (decompose-equality 3)
                (inst -1 "x!1") (assert)
                (spread (case "x!1 = theta") ((assert) (assert))))
               (then (flatten) (assert) (hide 6) (hide -3 6)
                (lemma "dyn_equiv") (inst -1 "ei" "eo" "c") (assert)
                (flatten)
                (spread (split -1)
                 ((then (hide -2) (expand "dyn" -1) (expand "b1" -1)
                   (expand "b2" -1) (expand "semantic_rel" -1)
                   (spread (split -1)
                    ((then (expand "semantic_rel" -1) (skeep)
                      (expand "semantic_rel" -1) (flatten) (assert))
                     (then (expand "semantic_rel" -1) (skeep)
                      (expand "semantic_rel" -1) (flatten)
                      (expand "<=" -1) (expand "cnst" -1)
                      (expand "val" -1) (assert)))))
                  (then (hide -1) (inst 1 "th") (expand "dyn_tr" 1)
                   (expand "b1_tr" 1) (expand "b2" 1)
                   (expand "semantic_rel" 1) (flatten)
                   (expand "semantic_rel" 1)
                   (inst 1 "ei WITH [theta := 0]") (assert)
                   (expand "semantic_rel" 1) (expand ">" 1)
                   (expand "cnst" 1) (expand "val" 1) (assert)))))
               (then (flatten) (skeep) (assert) (hide 6 4)
                (inst 4 "en WITH [theta :=ei(dlvar_index(theta))]")
                (spread (split 4)
                 ((then (hide -5) (lemma "dyn_equiv")
                   (inst -1 "ei" "en" "c") (assert) (flatten)
                   (spread (split -1)
                    ((then (hide -2) (expand "turn" 1)
                      (expand "dyn" -1) (expand "semantic_rel" -1)
                      (expand "b1" -1) (expand "b2" -1)
                      (spread (split -1)
                       ((then (expand "semantic_rel" -1) (skeep)
                         (expand "turn" -2) (expand "semantic_rel" -1)
                         (flatten) (assert))
                        (then (expand "semantic_rel" -1) (skeep)
                         (expand "semantic_rel" -1) (flatten)
                         (expand "<=" -1) (expand "cnst" -1)
                         (expand "val" -1) (assert)))))
                     (then (inst 1 "en(dlvar_index(theta))") (assert)
                      (expand "dyn_tr" 1) (expand "b1_tr" 1)
                      (expand "b2" 1) (expand "semantic_rel" 1)
                      (flatten) (expand "semantic_rel" 1)
                      (inst 1 "ei WITH [theta :=0]") (assert)
                      (spread
                       (case "en = en WITH [theta := en(dlvar_index(theta))]")
                       ((spread (split 1)
                         ((then (expand "semantic_rel" 1)
                           (expand ">" 1) (expand "cnst" 1)
                           (expand "val" 1) (assert))
                          (then (assert) (replace -1 1 rl) (propax))))
                        (then (decompose-equality 1)
                         (spread (case "x!1 = theta")
                          ((assert) (assert))))))))))
                  (then (lemma " fresh_be_semantic_rel")
                   (inst -1 "straight(-c,0)" "theta" "en"
                    "eo WITH [theta := th]" "ei(dlvar_index(theta))")
                   (assert) (expand "straight" 1) (expand "fresh_hp?")
                   (lemma "fresh_be_DLTRUE") (inst?) (assert)
                   (hide-all-but 1) (expand "fresh_li?")
                   (expand "fresh_li?") (expand "fresh_li?")
                   (rewrites ("fresh_re_val" "fresh_re_cnst"
                              "fresh_re_prod" "fresh_re_pow"
                              "fresh_re_exp" "fresh_re_sum"
                              "fresh_re_minus" "fresh_re_div"
                              "fresh_re_div_safe" "fresh_re_sqrt_safe")
                             :fnums 1 :target-fnums 1)
                   (rewrites ("fresh_re_val" "fresh_re_cnst"
                              "fresh_re_prod" "fresh_re_pow"
                              "fresh_re_exp" "fresh_re_sum"
                              "fresh_re_minus" "fresh_re_div"
                              "fresh_re_div_safe" "fresh_re_sqrt_safe")
                             :fnums 1 :target-fnums 1))))))))
            (then (assert) (flatten) (assert) (eval-expr -1)
             (assert))))
          (then (eval-expr -1) (assert)))))
       (then (flatten) (lemma "b_star_dyn") (inst?) (assert) (hide -2)
        (lemma "b_star_dyn_tr")
        (inst -1 "k" "c" "ei WITH [theta := 0]" "_")
        (lemma "dyn_equiv")
        (spread (split -3)
         ((then (inst 1 "0") (assert) (inst -3 "eo WITH [theta := 0]")
           (assert) (hide 2)
           (spread (case "x = theta")
            ((then (eval-expr -1) (assert))
             (then (assert)
              (spread (case "y = theta")
               ((then (eval-expr -1) (assert)) (assert)))))))
          (then (flatten) (assert)
           (inst -3 "ei" "eo WITH [theta := ei(dlvar_index(theta))]"
            "c")
           (assert) (flatten)
           (spread (split -4)
            ((then (skeep) (inst 2 "r")
              (inst -5 "eo WITH [ theta := r]") (assert)
              (spread (case " NOT theta = x")
               ((then (assert)
                 (spread (case "NOT theta = y")
                  ((then (assert) (flatten) (hide 6)
                    (expand "dyn_tr" -1) (expand "b1_tr" -1)
                    (expand "b2" -1) (expand "semantic_rel" -1)
                    (spread (split -1)
                     ((then (expand "semantic_rel" -1) (skeep)
                       (expand "semantic_rel" -1) (flatten) (assert))
                      (then (expand "semantic_rel" -1) (skeep)
                       (expand "semantic_rel" -1) (flatten)
                       (expand "<=" -1) (expand "cnst" -1)
                       (expand "val" -1) (assert)))))
                   (then (eval-expr -1) (assert)))))
                (then (assert) (eval-expr -1) (assert)))))
             (then (assert) (expand "dyn" 1) (expand "semantic_rel" 1)
              (flatten) (expand "b1" 1) (expand "semantic_rel" 1)
              (inst 1 "ei") (assert) (expand "semantic_rel" 1)
              (expand ">" 1) (expand "cnst" 1) (expand "val" 1)
              (assert)))))
          (then (flatten) (assert) (skeep -3) (lemma "dyn_equiv")
           (inst-cp -1 "ei" "en" "c") (assert) (flatten)
           (spread (split -3)
            ((then (skeep) (inst 1 "r")
              (inst -9 "eo WITH [ theta := r]") (assert)
              (spread (case "x = theta")
               ((then (eval-expr -1) (assert))
                (spread (case "y = theta")
                 ((then (eval-expr -1) (assert))
                  (then (assert) (flatten) (assert) (hide 5)
                   (inst 4 "en WITH [ theta := r]")
                   (spread (split 4)
                    ((then (expand "turn_tr" 1) (expand "dyn_tr" -1)
                      (expand "semantic_rel" -1)
                      (spread (split -1)
                       ((then (expand "b1_tr" -1)
                         (expand "semantic_rel" -1) (skeep)
                         (expand "semantic_rel" -1) (flatten)
                         (expand ">" -1) (expand "val" -1)
                         (expand "turn_tr" -3) (assert))
                        (then (expand "b2" -1)
                         (expand "semantic_rel" -1) (skeep)
                         (expand "semantic_rel" -1) (expand "<=" -1)
                         (expand "cnst" -1) (expand "val" -1)
                         (propax)))))
                     (then (assert) (lemma " fresh_be_semantic_rel")
                      (inst -1 "straight(-c,0)" "theta" "en"
                       "eo WITH [theta := ei(dlvar_index(theta))]" "r")
                      (spread (split -1)
                       ((assert)
                        (then (hide -) (hide 2) (expand "straight" 1)
                         (expand "fresh_hp?" 1) (prove-fresh_re-goal))
                        (propax))))))))))))
             (then (assert) (hide 3) (hide 2) (expand "dyn" 1)
              (expand "semantic_rel" 1) (flatten) (expand "b1" 1)
              (expand "semantic_rel" 1) (inst 1 "ei") (assert)
              (spread (split 1)
               ((then (expand "semantic_rel" 1) (expand ">" 1)
                 (expand "val" 1) (expand "cnst" 1) (assert))
                (then (assert) (hide-all-but (-4 1))
                 (spread
                  (case "en = en WITH [theta := ei(dlvar_index(theta))]")
                  ((then (assert) (replace -1 1 rl) (propax))
                   (then (decompose-equality 1)
                    (spread (case "NOT x!1 = theta")
                     ((assert)
                      (then (expand "turn") (expand "semantic_rel")
                       (skeep) (inst 2 "D")
                       (expand "semantic_rel_diff") (assert) (skeep)
                       (skeep) (expand "env_at_t?" -2) (flatten)
                       (spread (inst -2 "theta")
                        ((assert)
                         (then (hide -2 -3) (hide 3) (eval-expr 1)
                          (assert)))))))))))))))))))))))
    nil)
   ((b_star_dyn_tr formula-decl nil flight_turn_example nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (y const-decl "dLVar" flight_turn_example nil)
    (fresh_be_semantic_rel formula-decl nil fresh_props dL)
    (fresh_hp? inductive-decl "bool" hp_expr dL)
    (fresh_re_cnst formula-decl nil fresh_props dL)
    (TRUE const-decl "bool" booleans nil)
    (fresh_li? inductive-decl "bool" hp_expr dL)
    (fresh_be_DLTRUE formula-decl nil fresh_props dL)
    (HP type-decl nil HP_adt dL)
    (straight const-decl "HP" flight_turn_example nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (turn const-decl "HP" flight_turn_example nil)
    (dyn_equiv formula-decl nil flight_turn_example nil)
    (dyn const-decl "HP" flight_turn_example nil)
    (b2 const-decl "HP" flight_turn_example nil)
    (cnst const-decl "real" hp_def dL)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (val const-decl "real" hp_def dL)
    (<= const-decl "BoolExpr" bool_expr dL)
    (semantic_rel inductive-decl "bool" hp_expr dL)
    (b1 const-decl "HP" flight_turn_example nil)
    (b1_tr const-decl "HP" flight_turn_example nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (> const-decl "BoolExpr" bool_expr dL)
    (dyn_tr const-decl "HP" flight_turn_example nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (FALSE const-decl "bool" booleans nil)
    (x const-decl "dLVar" flight_turn_example nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (theta const-decl "dLVar" flight_turn_example nil)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (b_star_dyn formula-decl nil flight_turn_example nil)
    (semantic_rel_diff const-decl "bool" hp_expr dL)
    (env_at_t? const-decl "bool" hp_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (MapExprInj type-eq-decl nil hp_def dL)
    (not_in_map const-decl "bool" hp_def dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (dd? const-decl "bool" hp_expr dL)
    (turn_tr const-decl "HP" flight_turn_example nil))
   shostak))
 (star_dyn_equiv 0
  (star_dyn_equiv-1 nil 3882376660
   (""
    (then (skeep) (beta) (assert) (flatten) (lemma "b_star_dyns_equiv")
     (spread (split 1)
      ((then (flatten) (skeep) (lemma "semantic_rel_star_bounded_star")
        (lemma "semantic_rel_star_bounded_star_con")
        (inst -1 "dyn(c)" "ei"
         "eo WITH [ theta := ei(dlvar_index(theta))]" "_")
        (inst -2 "dyn_tr(c)" "ei WITH  [theta := 0]"
         "eo WITH [ theta := th]")
        (assert) (skeep) (inst -1 "i") (inst -3 "i" "c" "ei" "eo")
        (assert) (inst 3 "th"))
       (then (flatten) (lemma "semantic_rel_star_bounded_star_con")
        (lemma "semantic_rel_star_bounded_star")
        (inst -1 "dyn(c)" "ei"
         "eo WITH [ theta := ei(dlvar_index(theta))]")
        (assert) (skeep) (inst -4 "i" "c" "ei" "eo") (assert) (skeep)
        (inst 1 "th")
        (inst -2 "dyn_tr(c)" "ei WITH [ theta := 0]"
         "eo WITH [theta := th]" "i")
        (assert)))))
    nil)
   ((semantic_rel_star_bounded_star_con formula-decl nil
     bounded_star_semantics dL)
    (dyn_tr const-decl "HP" flight_turn_example nil)
    (theta const-decl "dLVar" flight_turn_example nil)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (dyn const-decl "HP" flight_turn_example nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (HP type-decl nil HP_adt dL)
    (semantic_rel_star_bounded_star formula-decl nil
     bounded_star_semantics dL)
    (b_star_dyns_equiv formula-decl nil flight_turn_example nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   shostak))
 (dyns_allruns_equiv 0
  (dyns_allruns_equiv-1 nil 3882380092
   (""
    (then (skeep) (beta)
     (spread (split 1)
      ((then (flatten) (rewrite "dlSequent_equiv")
        (rewrite "dlSequent_equiv") (expand "dlSequent") (skeep)
        (inst 1 "0") (expand "nth" 1) (expand "DLIMPLIES" 1) (flatten)
        (inst -1 "env") (assert)
        (spread (split -1)
         ((then (skeep) (typepred "j") (expand "length" -1)
           (expand "length" -1) (expand "nth" -2) (assert)
           (expand "DLIMPLIES" -2)
           (spread (split -2)
            ((then (lemma "star_dyn_equiv") (expand "ALLRUNS") (skeep)
              (beta)
              (inst -1 "c" "env"
               "envo WITH [theta := env(dlvar_index(theta))]")
              (assert)
              (spread (split -1)
               ((then (flatten) (assert)
                 (spread (split -1)
                  ((then (assert)
                    (inst -3
                     "envo WITH [theta := env(dlvar_index(theta))]")
                    (assert) (typepred "Q") (expand "fresh?" -1)
                    (inst -1 "envo" "env(dlvar_index(theta))")
                    (assert))
                   (then (inst 1 "envo(dlvar_index(theta))") (assert)
                    (spread (case "env = env WITH [ theta := 0]")
                     ((spread
                       (case "envo = envo WITH [theta := envo(dlvar_index(theta))]")
                       ((then (assert) (replace -1 1 rl)
                         (replace -2 1 rl) (propax))
                        (then (decompose-equality 1)
                         (spread (case "x!1 = theta")
                          ((assert) (assert))))))
                      (then (decompose-equality 1)
                       (spread (case "x!1 = theta")
                        ((then (hide-all-but (-6 1))
                          (expand "DLAND" -1) (flatten) (expand "=")
                          (expand "cnst") (expand "val") (expand ">")
                          (assert) (reveal -) (assert))
                         (assert))))))))))
                (then (hide-all-but -4) (expand "DLAND" -1) (flatten)
                 (expand ">" -3) (expand "cnst" -3) (assert) (reveal +)
                 (propax))
                (then (hide-all-but (-4 1)) (expand "DLAND") (flatten)
                 (expand "=") (expand "cnst" -1) (expand "val" -1)
                 (propax))
                (then (hide-all-but (-4 1)) (expand "DLAND" -1)
                 (flatten) (expand "=" -2) (expand "cnst" -2)
                 (expand "val" -2) (propax)))))
             (then (hide 2 -2 -1) (grind)))))
          (propax))))
       (then (flatten) (rewrite "dlSequent_equiv")
        (rewrite "dlSequent_equiv") (expand "dlSequent") (skeep)
        (inst 1 "0") (expand "nth" 1) (expand "DLIMPLIES" 1) (flatten)
        (expand "ALLRUNS" 1) (skeep) (lemma "star_dyn_equiv")
        (inst -2 "env WITH [ theta := 0]")
        (spread (split -2)
         ((then (skeep) (typepred "j") (expand "length" -1)
           (expand "length" -1) (expand "nth" -2) (assert)
           (expand "DLIMPLIES" -2)
           (spread (split -2)
            ((then (expand "ALLRUNS" -1) (inst -3 "c" "env" "envo")
              (expand "DLAND" -5) (flatten) (expand "=" -5)
              (expand "=" -6) (expand ">" -7) (expand "cnst" -5)
              (expand "cnst" -6) (expand "cnst" -7) (expand "val" -5)
              (expand "val" -6) (assert) (flatten) (assert)
              (spread (split -4)
               ((then (skeep) (inst -2 "envo WITH [ theta := th]")
                 (assert) (typepred "Q") (expand "fresh?" -1)
                 (inst -1 "envo" "th") (assert))
                (then (lemma " fresh_be_semantic_rel")
                 (inst -1 "STAR(dyn(c))" "theta" "env" "envo"
                  "env(dlvar_index(theta))")
                 (assert)
                 (spread (split -1)
                  ((spread
                    (case "env = env WITH [ theta := env(dlvar_index(theta))]")
                    ((then (assert) (replace -1 -2 rl) (propax))
                     (then (decompose-equality 1)
                      (spread (case "x!1 = theta")
                       ((assert) (assert))))))
                   (then (hide 2 3) (expand "fresh_hp?" 1)
                    (expand "dyn" 1) (expand "fresh_hp?" 1)
                    (expand "b1" 1) (expand "b2" 1)
                    (expand "fresh_hp?" 1) (expand "turn" 1)
                    (expand "straight" 1) (expand "fresh_hp?" 1)
                    (hide -) (hide 2) (expand "fresh_li?")
                    (expand "fresh_li?") (expand "fresh_li?")
                    (spread
                     (rewrites ("fresh_be_DLTRUE"
                                "fresh_be_DLFALSE"
                                "fresh_be_eq"
                                "fresh_be_neq"
                                "fresh_be_le"
                                "fresh_be_lt"
                                "fresh_be_ge"
                                "fresh_be_gt"
                                "fresh_be_or"
                                "fresh_be_and"
                                "fresh_be_implies"
                                "fresh_be_not"
                                "fresh_be_IFF")
                               :fnums 1 :target-fnums 1)
                     ((spread
                       (rewrites ("fresh_re_val"
                                  "fresh_re_cnst"
                                  "fresh_re_prod"
                                  "fresh_re_pow"
                                  "fresh_re_exp"
                                  "fresh_re_sum"
                                  "fresh_re_minus"
                                  "fresh_re_div"
                                  "fresh_re_div_safe"
                                  "fresh_re_sqrt_safe")
                                 :fnums 1 :target-fnums 1)
                       ((then
                         (rewrites ("fresh_re_val"
                                    "fresh_re_cnst"
                                    "fresh_re_prod"
                                    "fresh_re_pow"
                                    "fresh_re_exp"
                                    "fresh_re_sum"
                                    "fresh_re_minus"
                                    "fresh_re_div"
                                    "fresh_re_div_safe"
                                    "fresh_re_sqrt_safe")
                                   :fnums 1 :target-fnums 1)
                         (rewrite "fresh?")
                         (spread (split 1)
                          ((then (eval-expr -1) (assert))
                           (then (skeep) (grind))
                           (then (eval-expr -1) (assert))
                           (then (eval-expr -1) (assert))
                           (then (eval-expr -1) (assert)))))
                        (then (hide-all-but 1) (eval-formula *))))
                      (then
                       (rewrites ("fresh_re_val"
                                  "fresh_re_cnst"
                                  "fresh_re_prod"
                                  "fresh_re_pow"
                                  "fresh_re_exp"
                                  "fresh_re_sum"
                                  "fresh_re_minus"
                                  "fresh_re_div"
                                  "fresh_re_div_safe"
                                  "fresh_re_sqrt_safe")
                                 :fnums 1 :target-fnums 1)
                       (hide-all-but 1) (eval-formula *))
                      (rewrites ("fresh_re_val"
                                 "fresh_re_cnst"
                                 "fresh_re_prod"
                                 "fresh_re_pow"
                                 "fresh_re_exp"
                                 "fresh_re_sum"
                                 "fresh_re_minus"
                                 "fresh_re_div"
                                 "fresh_re_div_safe"
                                 "fresh_re_sqrt_safe")
                                :fnums 1 :target-fnums 1)
                      (then
                       (rewrites ("fresh_re_val"
                                  "fresh_re_cnst"
                                  "fresh_re_prod"
                                  "fresh_re_pow"
                                  "fresh_re_exp"
                                  "fresh_re_sum"
                                  "fresh_re_minus"
                                  "fresh_re_div"
                                  "fresh_re_div_safe"
                                  "fresh_re_sqrt_safe")
                                 :fnums 1 :target-fnums 1)
                       (hide-all-but 1) (eval-formula *))
                      (rewrites ("fresh_re_val"
                                 "fresh_re_cnst"
                                 "fresh_re_prod"
                                 "fresh_re_pow"
                                 "fresh_re_exp"
                                 "fresh_re_sum"
                                 "fresh_re_minus"
                                 "fresh_re_div"
                                 "fresh_re_div_safe"
                                 "fresh_re_sqrt_safe")
                                :fnums 1 :target-fnums 1)
                      (then
                       (rewrites ("fresh_re_val"
                                  "fresh_re_cnst"
                                  "fresh_re_prod"
                                  "fresh_re_pow"
                                  "fresh_re_exp"
                                  "fresh_re_sum"
                                  "fresh_re_minus"
                                  "fresh_re_div"
                                  "fresh_re_div_safe"
                                  "fresh_re_sqrt_safe")
                                 :fnums 1 :target-fnums 1)
                       (hide-all-but 1) (eval-formula *))
                      (rewrites ("fresh_re_val"
                                 "fresh_re_cnst"
                                 "fresh_re_prod"
                                 "fresh_re_pow"
                                 "fresh_re_exp"
                                 "fresh_re_sum"
                                 "fresh_re_minus"
                                 "fresh_re_div"
                                 "fresh_re_div_safe"
                                 "fresh_re_sqrt_safe")
                                :fnums 1 :target-fnums 1))))))))))
             (then (hide -2) (hide -4) (hide -2) (expand "DLAND")
              (flatten) (grind)))))
          (then (hide 2) (hide -) (skeep) (typepred "i") (grind))))))))
    nil)
   ((fresh_be_semantic_rel formula-decl nil fresh_props dL)
    (b1 const-decl "HP" flight_turn_example nil)
    (straight const-decl "HP" flight_turn_example nil)
    (fresh_li? inductive-decl "bool" hp_expr dL)
    (fresh_re_val formula-decl nil fresh_props dL)
    (/= const-decl "boolean" notequal nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (fresh_re_cnst formula-decl nil fresh_props dL)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (pi_bound name-judgement
     "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig)
    (minus_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (FALSE const-decl "bool" booleans nil)
    (fresh_be_gt formula-decl nil fresh_props dL)
    (fresh_be_ge formula-decl nil fresh_props dL)
    (TRUE const-decl "bool" booleans nil)
    (fresh_be_le formula-decl nil fresh_props dL)
    (fresh_be_DLTRUE formula-decl nil fresh_props dL)
    (turn const-decl "HP" flight_turn_example nil)
    (b2 const-decl "HP" flight_turn_example nil)
    (fresh_hp? inductive-decl "bool" hp_expr dL)
    (dyn_tr const-decl "HP" flight_turn_example nil)
    (nth def-decl "T" list_props nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (star_dyn_equiv formula-decl nil flight_turn_example nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (length_singleton formula-decl nil more_list_props structures)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (dlSequent const-decl "bool" dynamic_logic dL)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (theta const-decl "dLVar" flight_turn_example nil)
    (dyn const-decl "HP" flight_turn_example nil)
    (STAR adt-constructor-decl "[HP -> (star?)]" HP_adt dL)
    (star? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (HP type-decl nil HP_adt dL) (> const-decl "BoolExpr" bool_expr dL)
    (y const-decl "dLVar" flight_turn_example nil)
    (cnst const-decl "real" hp_def dL)
    (x const-decl "dLVar" flight_turn_example nil)
    (val const-decl "real" hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (DLAND const-decl "bool" bool_expr dL)
    (DLIMPLIES const-decl "bool" bool_expr dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (Formulas type-eq-decl nil bool_expr dL)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (dlSequent_equiv formula-decl nil dynamic_logic dL))
   shostak))
 (dyns_someruns_equiv 0
  (dyns_someruns_equiv-1 nil 3882439244
   (""
    (then (skeep) (beta)
     (spread (split 1)
      ((then (flatten) (rewrite "dlSequent_equiv")
        (rewrite "dlSequent_equiv") (expand "dlSequent") (skeep)
        (inst 1 "0") (expand "nth" 1) (expand "DLIMPLIES" 1) (flatten)
        (inst -1 "env") (assert)
        (spread (split -1)
         ((then (skeep) (typepred "j") (expand "length" -1)
           (expand "length" -1) (expand "nth" -2) (assert)
           (expand "DLIMPLIES" -2)
           (spread (split -2)
            ((then (lemma "star_dyn_equiv") (expand "SOMERUNS") (skeep)
              (beta)
              (inst -1 "c" "env"
               "envo WITH [theta := env(dlvar_index(theta))]")
              (assert)
              (spread (split -1)
               ((then (flatten)
                 (spread (split -2)
                  ((then (skeep) (inst 1 "envo WITH [ theta := th]")
                    (spread (split 1)
                     ((spread (case "env = env WITH [ theta := 0]")
                       ((then (assert) (replace -1 -2 rl) (propax))
                        (then (decompose-equality 1)
                         (spread (case "x!1 = theta")
                          ((then (assert) (hide-all-but (-1 -8 1))
                            (grind))
                           (assert))))))
                      (then (typepred "Q") (expand "fresh?" -1)
                       (inst -1 "envo" "th") (assert)))))
                   (then (hide 2) (lemma " fresh_be_semantic_rel")
                    (inst -1 "STAR(dyn(c))" "theta" "env" "envo"
                     "env(dlvar_index(theta))")
                    (assert)
                    (spread (split -1)
                     ((spread
                       (case "env = env WITH [ theta := env(dlvar_index(theta))]")
                       ((then (assert) (replace -1 -2 rl) (propax))
                        (then (decompose-equality 1)
                         (spread (case "x!1 = theta")
                          ((assert) (assert))))))
                      (then (expand "fresh_hp?" 1) (expand "dyn" 1)
                       (expand "fresh_hp?" 1) (expand "b1" 1)
                       (expand "b2" 1) (expand "fresh_hp?" 1)
                       (expand "turn" 1) (expand "straight" 1)
                       (expand "fresh_hp?" 1) (hide -) (hide 2)
                       (expand "fresh_li?") (expand "fresh_li?")
                       (expand "fresh_li?")
                       (spread
                        (rewrites ("fresh_be_DLTRUE"
                                   "fresh_be_DLFALSE"
                                   "fresh_be_eq"
                                   "fresh_be_neq"
                                   "fresh_be_le"
                                   "fresh_be_lt"
                                   "fresh_be_ge"
                                   "fresh_be_gt"
                                   "fresh_be_or"
                                   "fresh_be_and"
                                   "fresh_be_implies"
                                   "fresh_be_not"
                                   "fresh_be_IFF")
                                  :fnums 1 :target-fnums 1)
                        ((spread
                          (rewrites ("fresh_re_val"
                                     "fresh_re_cnst"
                                     "fresh_re_prod"
                                     "fresh_re_pow"
                                     "fresh_re_exp"
                                     "fresh_re_sum"
                                     "fresh_re_minus"
                                     "fresh_re_div"
                                     "fresh_re_div_safe"
                                     "fresh_re_sqrt_safe")
                                    :fnums 1 :target-fnums 1)
                          ((then
                            (rewrites ("fresh_re_val"
                                       "fresh_re_cnst"
                                       "fresh_re_prod"
                                       "fresh_re_pow"
                                       "fresh_re_exp"
                                       "fresh_re_sum"
                                       "fresh_re_minus"
                                       "fresh_re_div"
                                       "fresh_re_div_safe"
                                       "fresh_re_sqrt_safe")
                                      :fnums 1 :target-fnums 1)
                            (rewrite "fresh?")
                            (spread (split 1)
                             ((then (eval-expr -1) (assert))
                              (then (skeep) (grind))
                              (then (eval-expr -1) (assert))
                              (then (eval-expr -1) (assert))
                              (then (eval-expr -1) (assert)))))
                           (then (hide-all-but 1) (eval-formula *))))
                         (then
                          (rewrites ("fresh_re_val"
                                     "fresh_re_cnst"
                                     "fresh_re_prod"
                                     "fresh_re_pow"
                                     "fresh_re_exp"
                                     "fresh_re_sum"
                                     "fresh_re_minus"
                                     "fresh_re_div"
                                     "fresh_re_div_safe"
                                     "fresh_re_sqrt_safe")
                                    :fnums 1 :target-fnums 1)
                          (eval-expr 1) (assert))
                         (then (hide 2) (hide 2)
                          (lemma "fresh_re_cnst")
                          (inst -1 "0" "theta"))
                         (then (hide 2 3) (lemma "fresh_re_val")
                          (inst?) (eval-expr 1) (assert))
                         (then (hide -2 3) (hide 2)
                          (lemma "fresh_re_cnst") (inst?))
                         (then (lemma "fresh_re_val") (inst?)
                          (eval-expr 1) (assert))
                         (then (lemma "fresh_re_cnst")
                          (inst?)))))))))))
                (grind) (then (hide-all-but (-5 1)) (grind))
                (then (hide-all-but (-5 1)) (grind)))))
             (then (hide-all-but (-3 1)) (grind)))))
          (propax))))
       (then (flatten) (rewrite "dlSequent_equiv")
        (rewrite "dlSequent_equiv") (expand "dlSequent") (skeep)
        (inst 1 "0") (expand "nth" 1) (expand "DLIMPLIES" 1) (flatten)
        (inst -1 "env WITH [theta := 0]")
        (spread (split -1)
         ((then (skeep) (typepred "j") (expand "length" -1)
           (expand "length" -1) (expand "nth" -2) (assert)
           (expand "DLIMPLIES" -2)
           (spread (split -2)
            ((then (lemma "star_dyn_equiv") (expand "SOMERUNS") (skeep)
              (beta) (inst -1 "c" "env" "envo") (assert)
              (spread (split -1)
               ((then (flatten)
                 (spread (split -1)
                  ((then
                    (inst 1
                     "envo WITH [theta := env(dlvar_index(theta))]")
                    (assert) (typepred "Q") (expand "fresh?" -1)
                    (inst -1 "envo" "env(dlvar_index(theta))")
                    (assert))
                   (then (hide 2) (inst 1 "envo(dlvar_index(theta))")
                    (spread
                     (case "envo = envo WITH [ theta := envo(dlvar_index(theta))]")
                     ((then (replace -1 1 rl) (propax))
                      (then (decompose-equality 1)
                       (spread (case "x!1 = theta")
                        ((assert) (assert))))))))))
                (then (hide-all-but (-5 1)) (grind))
                (then (hide-all-but (-5 1)) (grind))
                (then (hide-all-but (-5 1)) (grind)))))
             (then (hide-all-but (-3 1)) (grind)))))
          (then (skeep) (typepred "i") (hide -2) (hide -2) (hide 2)
           (grind))))))))
    nil)
   ((dyn_tr const-decl "HP" flight_turn_example nil)
    (nth def-decl "T" list_props nil)
    (star_dyn_equiv formula-decl nil flight_turn_example nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (fresh_be_semantic_rel formula-decl nil fresh_props dL)
    (fresh_hp? inductive-decl "bool" hp_expr dL)
    (b2 const-decl "HP" flight_turn_example nil)
    (turn const-decl "HP" flight_turn_example nil)
    (fresh_be_DLTRUE formula-decl nil fresh_props dL)
    (fresh_be_le formula-decl nil fresh_props dL)
    (TRUE const-decl "bool" booleans nil)
    (fresh_be_ge formula-decl nil fresh_props dL)
    (fresh_be_gt formula-decl nil fresh_props dL)
    (FALSE const-decl "bool" booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (minus_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (pi_bound name-judgement
     "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (fresh_re_cnst formula-decl nil fresh_props dL)
    (minus_real_is_real application-judgement "real" reals nil)
    (/= const-decl "boolean" notequal nil)
    (fresh_re_val formula-decl nil fresh_props dL)
    (fresh_li? inductive-decl "bool" hp_expr dL)
    (straight const-decl "HP" flight_turn_example nil)
    (b1 const-decl "HP" flight_turn_example nil)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (length_singleton formula-decl nil more_list_props structures)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (dlSequent const-decl "bool" dynamic_logic dL)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (theta const-decl "dLVar" flight_turn_example nil)
    (dyn const-decl "HP" flight_turn_example nil)
    (STAR adt-constructor-decl "[HP -> (star?)]" HP_adt dL)
    (star? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (SOMERUNS const-decl "bool" bool_expr dL)
    (HP type-decl nil HP_adt dL) (> const-decl "BoolExpr" bool_expr dL)
    (y const-decl "dLVar" flight_turn_example nil)
    (cnst const-decl "real" hp_def dL)
    (x const-decl "dLVar" flight_turn_example nil)
    (val const-decl "real" hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (DLAND const-decl "bool" bool_expr dL)
    (DLIMPLIES const-decl "bool" bool_expr dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (Formulas type-eq-decl nil bool_expr dL)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (dlSequent_equiv formula-decl nil dynamic_logic dL))
   shostak)))

